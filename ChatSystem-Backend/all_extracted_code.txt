--- FILE: ./entrypoint.sh ---
内容:
#!/bin/bash

#./entrypoint.sh -h 127.0.0.1 -p 3306,2379,6379 -c '/im/bin/file_server -flagfile=./xx.conf'

# 1. 编写一个端口探测函数，端口连接不上则循环等待
# wait_for 127.0.0.1 3306
wait_for() {
    while ! nc -z $1 $2 
    do
        echo "$2 端口连接失败，休眠等待！";
        sleep 1;
    done
    echo "$1:$2 检测成功！";
}
# 2. 对脚本运行参数进行解析，获取到ip，port，command
declare ip
declare ports
declare command
while getopts "h:p:c:" arg
do
    case $arg in
        h)
            ip=$OPTARG;;
        p)
            ports=$OPTARG;;
        c)
            command=$OPTARG;;
    esac
done
# 3. 通过执行脚本进行端口检测
# ${port //,/ } 针对port中的内容，以空格替换字符串中的,  shell中数组--一种以空格间隔的字符串
for port in ${ports//,/ }
do
    wait_for $ip $port
done
# 4. 执行command
#  eval 对一个字符串进行二次检测，将其当作命令进行执行
eval $command

--- FILE: ./CMakeLists.txt ---
内容:
cmake_minimum_required(VERSION 3.1.3)
project(all-test)

# 设置安装路径为当前目录下的 bin 文件夹
set(CMAKE_INSTALL_PREFIX ${CMAKE_CURRENT_BINARY_DIR}/bin)
install(TARGET )

set(CMAKE_CXX_FLAGS_DEBUG "")
set(CMAKE_C_FLAGS_DEBUG "")
set(CMAKE_BUILD_TYPE "Release")
set(CMAKE_INSTALL_PREFIX ${CMAKE_CURRENT_BINARY_DIR})

add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/1.Speech_Server)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/2.File_Server)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/3.User_Server)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/4.Message_Transmit_Server)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/5.Message_Store_Server)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/6.Friend_Server)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/7.Gateway_Server)

--- FILE: ./all_extracted_code.txt ---
内容:


--- FILE: ./docker-compose.yaml ---
内容:
version: "3.8"


#   etcd:
#     image: etcd:latest

#   mysql:
#     image: mysql:latest

#   redis:
#     image: redis:latest

#   elasticsearch:
#     image: elasticsearch:latest

#   rabbitmq:
#     image: rabbitmq:latest


services:

  speech_server:
    build: ./1.Speech_Server
    image: speech_server:v2
    container_name: speech_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/speech_server.conf:/im/conf/speech_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host
    ports:
      - 10001:10001
    restart: always
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379 -c "/im/bin/speech_server -flagfile=/im/conf/speech_server.conf"

  file_server:
    build: ./2.File_Server
    image: file_server:v2
    container_name: file_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/file_server.conf:/im/conf/file_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host
    ports:
      - 10002:10002
    restart: always
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379 -c "/im/bin/file_server -flagfile=/im/conf/file_server.conf"

  user_server:
    build: ./3.User_Server
    image: user_server:v2
    container_name: user_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/user_server.conf:/im/conf/user_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host
    ports:
      - 10003:10003
    restart: always
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379,3306,5672,9200 -c "/im/bin/user_server -flagfile=/im/conf/user_server.conf"

  message_transmit_server:
    build: ./4.Message_Transmit_Server
    image: message_transmit_server:v2
    container_name: message_transmit_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/message_transmit_server.conf:/im/conf/message_transmit_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host
    ports:
      - 10004:10004
    restart: always
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379,3306,5672 -c "/im/bin/message_transmit_server -flagfile=/im/conf/message_transmit_server.conf"

  message_store_server:
    build: ./5.Message_Store_Server
    image: message_store_server:v2
    container_name: message_store_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/message_store_server.conf:/im/conf/message_store_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host
    ports:
      - 10005:10005
    restart: always
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379,3306,9200,5672 -c "/im/bin/message_store_server -flagfile=/im/conf/message_store_server.conf"

  friend_server:
    build: ./6.Friend_Server
    image: friend_server:v2
    container_name: friend_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/friend_server.conf:/im/conf/friend_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host  
    ports:
      - 10006:10006
    restart: always
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379,3306,9200 -c "/im/bin/friend_server -flagfile=/im/conf/friend_server.conf"
  
  gateway_server:
    build: ./7.Gateway_Server
    image: gateway_server:v2
    container_name: gateway_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/gateway_server.conf:/im/conf/gateway_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    network_mode: host
    ports:
      - 9000:9000
      - 9001:9001
    restart: always
    depends_on:
      - speech_server
      - file_server
      - user_server
      - message_transmit_server
      - message_store_server
      - friend_server
    # entrypoint:
    #   # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
    #   /im/bin/entrypoint.sh -h 127.0.0.1 -p 2379,6379 -c "/im/bin/gateway_server -flagfile=/im/conf/gateway_server.conf"


--- FILE: ./0_extract_content.py ---
内容:
import os

def is_image_dir(path):
    return os.path.basename(os.path.normpath(path)) == "image"

def process_source_file(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"【无法读取文件内容，可能是二进制文件或编码问题：{e}】"

def main():
    output_filename = "all_extracted_code.txt"
    with open(output_filename, 'w', encoding='utf-8') as out_file:
        # 从当前目录开始递归遍历
        for root, dirs, files in os.walk('.'):
            # 排除名为 build 的目录
            if 'build' in dirs:
                dirs.remove('build')
            if 'conf' in dirs:
                dirs.remove('conf')
            if 'docker_image_data' in dirs:
                dirs.remove('docker_image_data')
            if 'odb_builds' in dirs:
                dirs.remove('odb_builds')
            if 'api_builds' in dirs:
                dirs.remove('api_builds')

            relative_root = os.path.relpath(root, '.')
            # 判断当前目录是否为 image 目录
            if is_image_dir(root):
                for filename in files:
                    rel_path = os.path.join(relative_root, filename)
                    out_file.write(f"--- IMAGE FILE: {rel_path} ---\n")
                    out_file.write(f"文件名: {filename}\n\n")
            else:
                for filename in files:
                    rel_path = os.path.join(relative_root, filename)
                    out_file.write(f"--- FILE: {rel_path} ---\n")
                    content = process_source_file(os.path.join(root, filename))
                    out_file.write("内容:\n")
                    out_file.write(content + "\n\n")

if __name__ == '__main__':
    main()


--- FILE: ./depends.sh ---
内容:
#!/bin/bash

# 传递两个参数
# 1. 可执行程序的路径名
# 2. 将这个程序的依赖库拷贝到指定目录下

get_depends() {
    depends=$(ldd "$1" | awk '{if (match($3,"/")){print $3}}')
    if [ ! -d "$2" ]; then
        mkdir -p "$2"
    fi
    cp -Lr $depends "$2"
}

# 可执行程序的路径 将这个程序的依赖库拷贝到指定目录
get_depends ./1.Speech_Server/build/speech_server                     ./1.Speech_Server/build/depends
get_depends ./2.File_Server/build/file_server                         ./2.File_Server/build/depends
get_depends ./3.User_Server/build/user_server                         ./3.User_Server/build/depends
get_depends ./4.Message_Transmit_Server/build/message_transmit_server ./4.Message_Transmit_Server/build/depends
get_depends ./5.Message_Store_Server/build/message_store_server       ./5.Message_Store_Server/build/depends
get_depends ./6.Friend_Server/build/friend_server                     ./6.Friend_Server/build/depends
get_depends ./7.Gateway_Server/build/gateway_server                   ./7.Gateway_Server/build/depends


--- FILE: ./docker-compose.yaml.bac1 ---
内容:
version: "3.8"

services:
  etcd:
    image: quay.io/coreos/etcd:v3.3.25
    container_name: etcd-service
    environment:
      - ETCD_NAME=etcd-s1
      - ETCD_DATA_DIR=/var/lib/etcd
      - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
      - ETCD_ADVERTISE_CLIENT_URLS=http://0.0.0.0:2379
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      - ./docker_image_data/etcd:/var/lib/etcd:rw
    ports:
      - 2379:2379
    restart: always

  mysql:
    image: mysql:8.0.39
    container_name: mysql-service
    environment:
      MYSQL_ROOT_PASSWORD: Cydia4384!
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      - ./SQL_Code:/docker-entrypoint-initdb.d/:rw
      - ./docker_image_data/mysql:/var/lib/mysql:rw
    ports:
      - 3306:3306
    restart: always

  redis:
    image: redis:6.0.16
    container_name: redis-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      - ./docker_image_data/redis:/var/lib/redis:rw
    ports:
      - 6379:6379
    restart: always

  elasticsearch:
    image: elasticsearch:7.17.21
    container_name: elasticsearch-service
    environment:
      - "discovery.type=single-node"
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      - ./docker_image_data/elasticsearch:/data:rw
    ports:
      - 9200:9200
      - 9300:9300
    restart: always

  rabbitmq:
    image: rabbitmq:3.9.13
    container_name: rabbitmq-service
    environment:
      RABBITMQ_DEFAULT_USER: root
      RABBITMQ_DEFAULT_PASS: czhuowen
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      - ./docker_image_data/rabbitmq:/var/lib/rabbitmq:rw
    ports:
      - 5672:5672
    restart: always

  file_server:
    build: ./2.File_Server
    image: user_server:v1
    container_name: file_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/file_server.conf:/im/conf/file_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 10002:10002
    restart: always
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379 -c "/im/bin/file_server -flagfile=/im/conf/file_server.conf"
    depends_on:
      - etcd

  friend_server:
    build: ./2.File_Server
    image: file_server:v1
    container_name: friend_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/friend_server.conf:/im/conf/friend_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 10006:10006
    restart: always
    depends_on:
      - etcd
      - mysql
      - elasticsearch
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379,3306,9200 -c "/im/bin/friend_server -flagfile=/im/conf/friend_server.conf"
  
  gateway_server:
    build: ./7.Gateway_Server
    image: gateway_server:v1
    container_name: gateway_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/gateway_server.conf:/im/conf/gateway_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 9000:9000
      - 9001:9001
    restart: always
    depends_on:
      - etcd
      - redis
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379,6379 -c "/im/bin/gateway_server -flagfile=/im/conf/gateway_server.conf"
  
  message_store_server:
    build: ./5.Message_Store_Server
    image: message_store_server:v1
    container_name: message_store_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/message_store_server.conf:/im/conf/message_store_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 10005:10005
    restart: always
    depends_on:
      - etcd
      - mysql
      - elasticsearch
      - rabbitmq
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379,3306,9200,5672 -c "/im/bin/message_store_server -flagfile=/im/conf/message_store_server.conf"
  
  speech_server:
    build: ./1.Speech_Server
    image: speech_server:v1
    container_name: speech_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/speech_server.conf:/im/conf/speech_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 10001:10001
    restart: always
    depends_on:
      - etcd
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379 -c "/im/bin/speech_server -flagfile=/im/conf/speech_server.conf"
  
  message_transmit_server:
    build: ./4.Message_Transmit_Server
    image: message_transmit_server:v1
    container_name: message_transmit_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/message_transmit_server.conf:/im/conf/message_transmit_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 10004:10004
    restart: always
    depends_on:
      - etcd
      - mysql
      - rabbitmq
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379,3306,5672 -c "/im/bin/message_transmit_server -flagfile=/im/conf/message_transmit_server.conf"
  
  user_server:
    build: ./3.User_Server
    image: user_server:v1
    container_name: user_server-service
    volumes:
      # 1. 希望容器内的程序能够访问宿主机上的文件
      # 2. 希望容器内程序运行所产生的数据文件能落在宿主机上
      # 挂载的信息： entrypoint.sh文件 数据目录(im/logs, im/data), 配置文件
      - ./Configs/user_server.conf:/im/conf/user_server.conf
      - ./docker_image_data/logs:/im/logs:rw
      - ./docker_image_data/data:/im/data:rw
      - ./entrypoint.sh:/im/bin/entrypoint.sh
    ports:
      - 10003:10003
    restart: always
    depends_on:
      - etcd
      - mysql
      - redis
      - elasticsearch
    entrypoint:
      # 跟dockerfile中的cmd比较类似，都是容器启动后的默认操作--替代dockerfile中的cmd
      /im/bin/entrypoint.sh -h 172.16.0.3 -p 2379,3306,5672,9200 -c "/im/bin/user_server -flagfile=/im/conf/user_server.conf"
  

--- FILE: Examples/CMakeLists.txt ---
内容:
cmake_minimum_required(VERSION 3.1.3)
project(all_tests)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/6.odb_project_cmake)
set(CMAKE_INSTALL_PREFIX ${CMAKE_CURRENT_BINARY_DIR})

--- FILE: Examples/5.baidu_voice/16k.pcm ---
内容:
【无法读取文件内容，可能是二进制文件或编码问题：'utf-8' codec can't decode byte 0xb2 in position 0: invalid start byte】

--- FILE: Examples/5.baidu_voice/Makefile ---
内容:
voice : voice.cc
	g++ -std=c++17 $^ -o $@  -lcurl -lcrypto -ljsoncpp -lspdlog -lgflags

.PHONY:clean
clean:
	rm -f voice

--- FILE: Examples/5.baidu_voice/voice.cc ---
内容:
#include "../../Common/voice_recognizer.hpp"
#include "../../Common/logger.hpp"
#include <gflags/gflags.h>

DEFINE_string(app_id, "115536313", "语音平台应用ID");
DEFINE_string(api_key, "uxPdTPAgRAZWoV16moQbIt1k", "语音平台API密钥");
DEFINE_string(secret_key, "Hg2prK8pIPxMGYWwJ97ULVd6wzUTgWkb", "语音平台加密密钥");

DEFINE_bool(run_mode, false, "程序的运行模式false-调试; true-发布；");
DEFINE_string(log_file, "", "发布模式下, 用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下, 用于指定日志输出等级");


int main(int argc,char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode,  FLAGS_log_file,  FLAGS_log_level);


    VoiceRecognizerClient client(FLAGS_app_id, FLAGS_api_key, FLAGS_secret_key);

    std::string file_content;
    aip::get_file_content("./16k.pcm", &file_content);
    std::string ret = client.recognize(file_content);

    if(ret.empty() == true) {
        return -1;
    }

    LOG_INFO("转文字结果：{}", ret);

    return 0;
}


--- FILE: Examples/2.elasticsearch/es_test.cc ---
内容:
#include "../../Common/elasticsearch_basic.hpp"
#include "../../Common/logger.hpp"

#include <gflags/gflags.h>



// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");


int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    // 1. 构造ES客户端
    std::shared_ptr<elasticlient::Client> client(new elasticlient::Client({"http://127.0.0.1:9200/"}));

    // 2. 创建索引 POST /user/_doc
    ESIndex index("test_user", "_doc", client);

    bool ret = index.append("nickname")
                    .append("phone", "keyword", "standard", true)
                    .create_and_send();

    if(ret == true) {
        LOG_INFO("向ES服务器创建了一个索引，并且服务器发来了响应，成功！");
    } else {
        LOG_INFO("向ES服务器创建一个索引失败！");
        return -1;
    }
    
    // 3. 新增数据
    ret = ESInsert("test_user", "_doc", client)
            .append("nickname", "张三")
            .append("phone", "23125443532")
            .insert_and_send("00001");
    if(ret == false) {
        LOG_INFO("数据插入失败！");
        return -2;
    }

    // 3. 新增数据
    ret = ESInsert("test_user", "_doc", client)
            .append("nickname", "李四")
            .append("phone", "11122223333")
            .insert_and_send("00002");
    if(ret == false) {
        LOG_INFO("数据插入失败！");
        return -2;
    }

    // 3. 数据修改，依然用insert
    ret = ESInsert("test_user", "_doc", client)
            .append("nickname", "张三")
            .append("phone", "11122223333")
            .insert_and_send("00001");
    if(ret == false) {
        LOG_INFO("数据插入失败！");
        return -3;
    }


    // 4. 数据检索（搜索）
    Json::Value ret_user = chen_im::ESSearch("test_user", "_doc", client)
        .append_should_match("phone.keyword", "11122223333") // keyword表示phone这个词作为关键字搜索
        .search();
    if (ret_user.empty()  || ret_user.isArray() == false ) {
        LOG_ERROR("数据检索的结果为空，或者返回结果不是数组类型");
        return -4;
    } else {
        LOG_DEBUG("打印检索结果");
        int sz = ret_user.size();
        for(int i = 0; i < sz; i++) {
            std::cout << ret_user[i]["_source"]["nickname"].asString() << std::endl;
            std::cout << ret_user[i]["_source"]["phone"].asString() << std::endl;
        }
        LOG_DEBUG("检索结果打印完毕");
    }


    // // 5. 数据删除

    // ret = ESRemove("test_user", "_doc", client)
    //     .remove("00001");
    // if (ret == false) {
    //     LOG_ERROR("删除00001数据失败");
    //     return -5;
    // } else {
    //     LOG_DEBUG("删除00001数据成功");
    // }


    return 0;
}

--- FILE: Examples/2.elasticsearch/Makefile ---
内容:
all:estest
estest:es_test.cc
	g++ -g -std=c++17 -o $@ $^ -lgflags -ljsoncpp -lspdlog -lelasticlient

.PHONY:clean
clean:
	rm -f estest

--- FILE: Examples/1.rpc/main.pb.cc ---
内容:
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

#include "main.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace example {
class EchoRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EchoRequest>
      _instance;
} _EchoRequest_default_instance_;
class EchoResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EchoResponse>
      _instance;
} _EchoResponse_default_instance_;
}  // namespace example
namespace protobuf_main_2eproto {
static void InitDefaultsEchoRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::example::_EchoRequest_default_instance_;
    new (ptr) ::example::EchoRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::example::EchoRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EchoRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEchoRequest}, {}};

static void InitDefaultsEchoResponse() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::example::_EchoResponse_default_instance_;
    new (ptr) ::example::EchoResponse();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::example::EchoResponse::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EchoResponse =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEchoResponse}, {}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_EchoRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EchoResponse.base);
}

::google::protobuf::Metadata file_level_metadata[2];
const ::google::protobuf::ServiceDescriptor* file_level_service_descriptors[1];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::example::EchoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::example::EchoRequest, message_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::example::EchoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::example::EchoResponse, message_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::example::EchoRequest)},
  { 6, -1, sizeof(::example::EchoResponse)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::example::_EchoRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::example::_EchoResponse_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "main.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, NULL, file_level_service_descriptors);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 2);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\nmain.proto\022\007example\"\036\n\013EchoRequest\022\017\n\007"
      "message\030\001 \001(\t\"\037\n\014EchoResponse\022\017\n\007message"
      "\030\001 \001(\t2B\n\013EchoService\0223\n\004Echo\022\024.example."
      "EchoRequest\032\025.example.EchoResponseB\003\200\001\001b"
      "\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 167);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "main.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_main_2eproto
namespace example {

// ===================================================================

void EchoRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EchoRequest::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EchoRequest::EchoRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_main_2eproto::scc_info_EchoRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:example.EchoRequest)
}
EchoRequest::EchoRequest(const EchoRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.message().size() > 0) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  // @@protoc_insertion_point(copy_constructor:example.EchoRequest)
}

void EchoRequest::SharedCtor() {
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EchoRequest::~EchoRequest() {
  // @@protoc_insertion_point(destructor:example.EchoRequest)
  SharedDtor();
}

void EchoRequest::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EchoRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EchoRequest::descriptor() {
  ::protobuf_main_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_main_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EchoRequest& EchoRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_main_2eproto::scc_info_EchoRequest.base);
  return *internal_default_instance();
}


void EchoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:example.EchoRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

bool EchoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:example.EchoRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string message = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->message().data(), static_cast<int>(this->message().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "example.EchoRequest.message"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:example.EchoRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:example.EchoRequest)
  return false;
#undef DO_
}

void EchoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:example.EchoRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (this->message().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->message().data(), static_cast<int>(this->message().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "example.EchoRequest.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:example.EchoRequest)
}

::google::protobuf::uint8* EchoRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:example.EchoRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (this->message().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->message().data(), static_cast<int>(this->message().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "example.EchoRequest.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:example.EchoRequest)
  return target;
}

size_t EchoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:example.EchoRequest)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // string message = 1;
  if (this->message().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EchoRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:example.EchoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const EchoRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EchoRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:example.EchoRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:example.EchoRequest)
    MergeFrom(*source);
  }
}

void EchoRequest::MergeFrom(const EchoRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:example.EchoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.message().size() > 0) {

    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
}

void EchoRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:example.EchoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EchoRequest::CopyFrom(const EchoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:example.EchoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EchoRequest::IsInitialized() const {
  return true;
}

void EchoRequest::Swap(EchoRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EchoRequest::InternalSwap(EchoRequest* other) {
  using std::swap;
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EchoRequest::GetMetadata() const {
  protobuf_main_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_main_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EchoResponse::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EchoResponse::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EchoResponse::EchoResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_main_2eproto::scc_info_EchoResponse.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:example.EchoResponse)
}
EchoResponse::EchoResponse(const EchoResponse& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.message().size() > 0) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  // @@protoc_insertion_point(copy_constructor:example.EchoResponse)
}

void EchoResponse::SharedCtor() {
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EchoResponse::~EchoResponse() {
  // @@protoc_insertion_point(destructor:example.EchoResponse)
  SharedDtor();
}

void EchoResponse::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EchoResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* EchoResponse::descriptor() {
  ::protobuf_main_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_main_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EchoResponse& EchoResponse::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_main_2eproto::scc_info_EchoResponse.base);
  return *internal_default_instance();
}


void EchoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:example.EchoResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

bool EchoResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:example.EchoResponse)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string message = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->message().data(), static_cast<int>(this->message().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "example.EchoResponse.message"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:example.EchoResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:example.EchoResponse)
  return false;
#undef DO_
}

void EchoResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:example.EchoResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (this->message().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->message().data(), static_cast<int>(this->message().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "example.EchoResponse.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:example.EchoResponse)
}

::google::protobuf::uint8* EchoResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:example.EchoResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (this->message().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->message().data(), static_cast<int>(this->message().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "example.EchoResponse.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:example.EchoResponse)
  return target;
}

size_t EchoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:example.EchoResponse)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // string message = 1;
  if (this->message().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EchoResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:example.EchoResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const EchoResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EchoResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:example.EchoResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:example.EchoResponse)
    MergeFrom(*source);
  }
}

void EchoResponse::MergeFrom(const EchoResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:example.EchoResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.message().size() > 0) {

    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
}

void EchoResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:example.EchoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EchoResponse::CopyFrom(const EchoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:example.EchoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EchoResponse::IsInitialized() const {
  return true;
}

void EchoResponse::Swap(EchoResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EchoResponse::InternalSwap(EchoResponse* other) {
  using std::swap;
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata EchoResponse::GetMetadata() const {
  protobuf_main_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_main_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

EchoService::~EchoService() {}

const ::google::protobuf::ServiceDescriptor* EchoService::descriptor() {
  protobuf_main_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_main_2eproto::file_level_service_descriptors[0];
}

const ::google::protobuf::ServiceDescriptor* EchoService::GetDescriptor() {
  return descriptor();
}

void EchoService::Echo(::google::protobuf::RpcController* controller,
                         const ::example::EchoRequest*,
                         ::example::EchoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Echo() not implemented.");
  done->Run();
}

void EchoService::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), protobuf_main_2eproto::file_level_service_descriptors[0]);
  switch(method->index()) {
    case 0:
      Echo(controller,
             ::google::protobuf::down_cast<const ::example::EchoRequest*>(request),
             ::google::protobuf::down_cast< ::example::EchoResponse*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& EchoService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::example::EchoRequest::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::google::protobuf::Message& EchoService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::example::EchoResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

EchoService_Stub::EchoService_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
EchoService_Stub::EchoService_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
EchoService_Stub::~EchoService_Stub() {
  if (owns_channel_) delete channel_;
}

void EchoService_Stub::Echo(::google::protobuf::RpcController* controller,
                              const ::example::EchoRequest* request,
                              ::example::EchoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace example
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::example::EchoRequest* Arena::CreateMaybeMessage< ::example::EchoRequest >(Arena* arena) {
  return Arena::CreateInternal< ::example::EchoRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::example::EchoResponse* Arena::CreateMaybeMessage< ::example::EchoResponse >(Arena* arena) {
  return Arena::CreateInternal< ::example::EchoResponse >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)


--- FILE: Examples/1.rpc/Makefile ---
内容:
all:discovery registry
discovery:discovery.cc main.pb.cc
	g++ -g -std=c++17 -o $@ $^ -lbrpc -lleveldb -lssl -lcrypto -lprotobuf -ldl -lpthread -lgflags -lgtest -letcd-cpp-api -lcpprest
registry:registry.cc main.pb.cc
	g++ -g -std=c++17 -o $@ $^ -lbrpc -lleveldb -lssl -lcrypto -lprotobuf -ldl -lpthread -lgflags -lgtest -letcd-cpp-api -lcpprest

main.pb.cc:main.proto
	protoc --cpp_out=. $^

.PHONY:clean
clean:
	rm -f discovery registry

--- FILE: Examples/1.rpc/discovery.cc ---
内容:
// 关心想关心的服务，调用rpc服务，是rpc的客户端
#include "../../Common/etcd.hpp"
#include "../../Common/logger.hpp"
#include "../../Common/rpc_service_manager.hpp"
#include "main.pb.h"
#include <gflags/gflags.h>
#include <functional>

// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");

// etcd
DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(service_to_call, "/service/echo", "服务监控根目录");

using namespace chen_im;

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    // 1. 先构造Rpc信道管理对象，并关心echo服务
    auto service_manager = std::make_shared<ServiceManager>();
    service_manager->concern(FLAGS_service_to_call);

    // 2. 构造服务发现对象, 先定义新增和删除时的回调
    auto put_cb = std::bind(&ServiceManager::when_service_online, service_manager.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&ServiceManager::when_service_offline, service_manager.get(), std::placeholders::_1, std::placeholders::_2);
    std::shared_ptr<Discovery> dclient = std::make_shared<Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    
    while(true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        // 3. 通过Rpc信道管理对象，获取提供Echo服务的信道
        auto channel = service_manager->get(FLAGS_service_to_call);
        if (!channel) {
            LOG_ERROR("获取信道失败，retry...");
            continue;
        }

        // 4. 发起Echo方法的rpc调用(同步调用)
        example::EchoService_Stub stub(channel.get());

        example::EchoRequest req;
        req.set_message("hello server, I'm client.");

        brpc::Controller ctrl;
        example::EchoResponse resp;
        stub.Echo(&ctrl, &req, &resp, nullptr); // 这是真正的调用

        if (ctrl.Failed()) 
        {
            LOG_DEBUG("调用rpc服务 {} 失败，原因：{}", FLAGS_service_to_call, ctrl.ErrorText());
        } 
        else 
        {
            LOG_DEBUG("收到同步响应：{}", resp.message());
        }
    }
    
    std::this_thread::sleep_for(std::chrono::seconds(600));
    return 0;
}


--- FILE: Examples/1.rpc/main.pb.h ---
内容:
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

#ifndef PROTOBUF_INCLUDED_main_2eproto
#define PROTOBUF_INCLUDED_main_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_main_2eproto 

namespace protobuf_main_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_main_2eproto
namespace example {
class EchoRequest;
class EchoRequestDefaultTypeInternal;
extern EchoRequestDefaultTypeInternal _EchoRequest_default_instance_;
class EchoResponse;
class EchoResponseDefaultTypeInternal;
extern EchoResponseDefaultTypeInternal _EchoResponse_default_instance_;
}  // namespace example
namespace google {
namespace protobuf {
template<> ::example::EchoRequest* Arena::CreateMaybeMessage<::example::EchoRequest>(Arena*);
template<> ::example::EchoResponse* Arena::CreateMaybeMessage<::example::EchoResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace example {

// ===================================================================

class EchoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:example.EchoRequest) */ {
 public:
  EchoRequest();
  virtual ~EchoRequest();

  EchoRequest(const EchoRequest& from);

  inline EchoRequest& operator=(const EchoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EchoRequest(EchoRequest&& from) noexcept
    : EchoRequest() {
    *this = ::std::move(from);
  }

  inline EchoRequest& operator=(EchoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EchoRequest* internal_default_instance() {
    return reinterpret_cast<const EchoRequest*>(
               &_EchoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EchoRequest* other);
  friend void swap(EchoRequest& a, EchoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EchoRequest* New() const final {
    return CreateMaybeMessage<EchoRequest>(NULL);
  }

  EchoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EchoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EchoRequest& from);
  void MergeFrom(const EchoRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:example.EchoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_main_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EchoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:example.EchoResponse) */ {
 public:
  EchoResponse();
  virtual ~EchoResponse();

  EchoResponse(const EchoResponse& from);

  inline EchoResponse& operator=(const EchoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EchoResponse(EchoResponse&& from) noexcept
    : EchoResponse() {
    *this = ::std::move(from);
  }

  inline EchoResponse& operator=(EchoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EchoResponse* internal_default_instance() {
    return reinterpret_cast<const EchoResponse*>(
               &_EchoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EchoResponse* other);
  friend void swap(EchoResponse& a, EchoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EchoResponse* New() const final {
    return CreateMaybeMessage<EchoResponse>(NULL);
  }

  EchoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EchoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EchoResponse& from);
  void MergeFrom(const EchoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:example.EchoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_main_2eproto::TableStruct;
};
// ===================================================================

class EchoService_Stub;

class EchoService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline EchoService() {};
 public:
  virtual ~EchoService();

  typedef EchoService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void Echo(::google::protobuf::RpcController* controller,
                       const ::example::EchoRequest* request,
                       ::example::EchoResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EchoService);
};

class EchoService_Stub : public EchoService {
 public:
  EchoService_Stub(::google::protobuf::RpcChannel* channel);
  EchoService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~EchoService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements EchoService ------------------------------------------

  void Echo(::google::protobuf::RpcController* controller,
                       const ::example::EchoRequest* request,
                       ::example::EchoResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EchoService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EchoRequest

// string message = 1;
inline void EchoRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EchoRequest::message() const {
  // @@protoc_insertion_point(field_get:example.EchoRequest.message)
  return message_.GetNoArena();
}
inline void EchoRequest::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:example.EchoRequest.message)
}
#if LANG_CXX11
inline void EchoRequest::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:example.EchoRequest.message)
}
#endif
inline void EchoRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:example.EchoRequest.message)
}
inline void EchoRequest::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:example.EchoRequest.message)
}
inline ::std::string* EchoRequest::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:example.EchoRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EchoRequest::release_message() {
  // @@protoc_insertion_point(field_release:example.EchoRequest.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EchoRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:example.EchoRequest.message)
}

// -------------------------------------------------------------------

// EchoResponse

// string message = 1;
inline void EchoResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EchoResponse::message() const {
  // @@protoc_insertion_point(field_get:example.EchoResponse.message)
  return message_.GetNoArena();
}
inline void EchoResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:example.EchoResponse.message)
}
#if LANG_CXX11
inline void EchoResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:example.EchoResponse.message)
}
#endif
inline void EchoResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:example.EchoResponse.message)
}
inline void EchoResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:example.EchoResponse.message)
}
inline ::std::string* EchoResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:example.EchoResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EchoResponse::release_message() {
  // @@protoc_insertion_point(field_release:example.EchoResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EchoResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:example.EchoResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace example

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_main_2eproto


--- FILE: Examples/1.rpc/main.proto ---
内容:
syntax="proto3";
package example;

option cc_generic_services = true;

message EchoRequest {
    string message = 1;
};

message EchoResponse {
    string message = 1;
};

// 回显服务
service EchoService {
    rpc Echo(EchoRequest) returns (EchoResponse);
};

--- FILE: Examples/1.rpc/registry.cc ---
内容:
// 启动一个brpc服务器并注册rpc调用逻辑
// 不仅注册了服务，还提供了服务
#include "../../Common/etcd.hpp"
#include "../../Common/logger.hpp"
#include "main.pb.h"
#include <gflags/gflags.h>
#include <brpc/server.h>
#include <butil/logging.h>
#include <thread>

// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");

// etcd
DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(instance_name, "/echo/instance_1", "当前实例名称");

// 宣告的和实际开放的端口理应一致
DEFINE_string(access_host, "127.0.0.1:7777", "当前实例的外部访问地址(对外宣告的)");
DEFINE_uint32(listen_port, 7777, "Rpc服务器监听端口(实际开放的)");


// 创建子类，继承于EchoService创建一个子类，并实现rpc调用
class EchoServiceImpl : public example::EchoService 
{
private:
    /* data */
public:
    virtual void Echo(::google::protobuf::RpcController* controller,
                       const ::example::EchoRequest* request,
                       ::example::EchoResponse* response,
                       ::google::protobuf::Closure* done)
    {
        // 把Closure指针管理起来
        brpc::ClosureGuard closure_guard(done);

        // 处理业务
        std::cout << "处理业务中..." << std::endl;
        std::cout << "收到消息：" << request->message() << std::endl;
        std::string ret = request->message() + "，这是响应!";
        response->set_message(ret);

        // done->Run(); 不需要显式run了，因为closureguard析构的时候自动run了
    }
    EchoServiceImpl() {}
    ~EchoServiceImpl() {}
};


int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    //服务端改造思想
    //1.构造Echo服务
    //2.搭建Rpc服务器
    //3.运行Rpc服务
    //4.注册服务


    // 1. 关闭brpc的日志输出
    logging::LoggingSettings settings;
    settings.logging_dest = logging::LoggingDestination::LOG_TO_NONE;
    logging::InitLogging(settings);

    // 2. 构造服务器对象
    brpc::Server server;

    // 3. 向brpc服务器对象中，新增EchoService服务
    EchoServiceImpl echo_service;
    int ret = server.AddService(&echo_service, brpc::ServiceOwnership::SERVER_DOESNT_OWN_SERVICE); // service是局部变量，不需要被server占有
    if(ret == -1) {
        std::cerr << "添加服务失败" << std::endl;
        return -1;
    }
    brpc::ServerOptions options;
    options.idle_timeout_sec = -1; // 连接空闲超时事件，超时后连接被关闭
    options.num_threads = 1; // io线程数量

    // 4. 启动brpc服务器
    ret = server.Start(FLAGS_listen_port, &options);
    if(ret == -1) {
        std::cerr << "服务启动失败" << std::endl;
        return -1;
    }

    // 5. 向etcd注册键值对 <服务名称:url>
    std::shared_ptr<Registry> rclient = std::make_shared<Registry>(FLAGS_etcd_host);
    rclient->registry(FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);

    // 6. 等待运行结束
    server.RunUntilAskedToQuit();

    // std::this_thread::sleep_for(std::chrono::seconds(600));
    return 0;
}


--- FILE: Examples/4.dms/Makefile ---
内容:
all:dms
dms:testdms.cpp
	g++ -o $@ $^ -std=c++17 -lalibabacloud-sdk-core -lgflags

.PHONY:clean
clean:
	rm -f dms

--- FILE: Examples/4.dms/testdms.cpp ---
内容:
#include "../../Common/dms.hpp"

#include "gflags/gflags.h"
DEFINE_string(key_id, "LTAI5t9gpw1rar662L3ibhEv", "平台访问密钥ID");
DEFINE_string(key_secret, "JlA1SpGIyHFvAWh7zKqSCdJfQ3auci", "平台访问密钥");
DEFINE_bool(run_mode, false, "程序的运行模式, false-调试; true-发布;");
DEFINE_string(log_file, "", "发布模式下, 用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下, 用于指定日志输出等级");


int main(int argc, char* argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode,  FLAGS_log_file,  FLAGS_log_level);

    
    DMSClient client(FLAGS_key_id, FLAGS_key_secret);
    client.send("13636604708", "5678");
    return 0;
}

--- FILE: Examples/6.odb_project_cmake/CMakeLists.txt ---
内容:
# 1. 添加cmake版本声明
cmake_minimum_required(VERSION 3.1.3)

# 2. 声明工程名称
project(odb_test)

# 3. 检测并生成ODB框架代码
set(odb_path ${CMAKE_CURRENT_SOURCE_DIR}/entity)
set(odb_files student.hxx)

set(odb_hxx "")
set(odb_cxx "")
set(odb_srcs "")


# 完整路径指定 ODB 可执行文件
find_program(ODB_EXECUTABLE odb)

if (NOT ODB_EXECUTABLE)
    message(FATAL_ERROR "odb not found. Please install ODB and make sure it's available in your PATH.")
endif()

foreach(odb_file ${odb_files})
    string(REPLACE ".hxx" "-odb.hxx" odb_hxx ${odb_file})
    string(REPLACE ".hxx" "-odb.cxx" odb_cxx ${odb_file})

    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
        add_custom_command(
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
            COMMAND ${ODB_EXECUTABLE}
            ARGS -d mysql --std c++11 --generate-query --generate-schema --profile boost/date-time ${odb_path}/${odb_file}
            DEPENDS ${odb_path}/${odb_file}
            COMMENT "生成ODB框架代码文件：" ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
            VERBATIM
        )
    endif()

    list(APPEND odb_srcs ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)

# 5. 声明目标及依赖
add_executable(main ${src_files} ${odb_srcs})

# 6. 设置头文件的默认搜索路径
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/entity)
include_directories(${CMAKE_CURRENT_BINARY_DIR})

# 7. 设置需要链接的库
target_link_libraries(main odb-mysql odb odb-boost boost_system gflags)




# Install the executable 'main' to the bin directory under CMAKE_INSTALL_PREFIX
install(TARGETS main DESTINATION bin)

# Install any necessary headers, for example:
install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/entity/student.hxx DESTINATION include/entity)

--- FILE: Examples/6.odb_project_cmake/entity/student.hxx ---
内容:
#pragma once
#include <tuple>
#include <iostream>
#include <string>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <odb/core.hxx>
#include <odb/nullable.hxx>


#pragma db object
class Student 
{
    friend odb::access;
public:
    Student() {}
    Student(const Student &) {}
    Student(std::string name, 
            unsigned short age, 
            unsigned long class_id)
        :_name(name)
        , _age(age)
        , _class_id(class_id)
    {}

    // 访问成员的接口
    unsigned long GetStuID() {
        return _stu_id;
    }

    std::string GetName() {
        return _name;
    }

    odb::nullable<unsigned short> GetAge() {
        return _age;
    }

    unsigned long GetClassID() {
        return _class_id;
    }

    // 修改成员的接口
    void SetStuID(unsigned long stuid) {
        _stu_id = stuid;
    }

    void SetName(const std::string & newname) {
        _name = newname;
    }

    void SetAge(unsigned short a) {
        _age = a;
    }

    void SetClassID(unsigned long id) {
        _class_id = id;
    }

    ~Student() {}
private:
#pragma db id auto // 主键、自增
    unsigned long _stu_id;
    std::string _name;
    odb::nullable<unsigned short> _age;
#pragma db index // 索引
    unsigned long _class_id;
};

#pragma db object
class Class 
{
    friend odb::access;
public:
    unsigned long GetClassID() {
        return _class_id;
    }

    void SetClassID(unsigned long id) {
        _class_id = id;
    }

    std::string GetClassName() {
        return _class_name;
    }

    void SetClassName(const std::string &name) {
        _class_name = name;
    }

    Class(std::string name) 
        : _class_name(name)
    {}

    Class() {}
    ~Class() {}

private:
#pragma db id auto 
    unsigned long _class_id;
    std::string _class_name;
};


#pragma db view object(Student)\
                object(Class = Class : Student::_class_id == Class::_class_id)\
                query((?))

struct class_student_view {
    #pragma db column(Student::_stu_id)
    unsigned long _stu_id;
    
    #pragma db column(Student::_name)
    std::string _name;

    #pragma db column(Student::_age)
    odb::nullable<unsigned short> _age;

    #pragma db column(Class::_class_name)
    std::string _class_name;

    class_student_view() {}
    ~class_student_view() {}

};


// #pragma db view query("select name from Student " + (?))


// odb -d mysql  --std c++11 --generate-query --generate-schema --profile boost/date-time student.hxx

--- FILE: Examples/6.odb_project_cmake/source/main.cc ---
内容:
#include <string>
#include <memory>  // std::auto_ptr
#include <cstdlib> // std::exit
#include <iostream>

#include <odb/database.hxx>
#include <odb/mysql/database.hxx>
#include <gflags/gflags.h>

#include "student.hxx"
#include "student-odb.hxx"


DEFINE_string(mysql_host, "127.0.0.1", "这是MySQL的服务地址");
DEFINE_int32(mysql_port, 3306, "这是MySQL的服务端口");
DEFINE_string(db, "TestODB", "使用的数据库名称");
DEFINE_string(user, "chen", "MySQL用户名");
DEFINE_string(passwd, "Cydia4384!", "MySQL用户密码");
DEFINE_string(charset, "utf8", "字符集");
DEFINE_int32(max_pool, 3, "MySQL连接池的最大连接数");


// 插入班级表
bool insert_class(odb::mysql::database &db) 
{
    try {
        odb::mysql::transaction transaction1(db.begin());
        Class c1("一年级1班");
        Class c2("一年级2班");
        Class c3("一年级3班");
        db.persist(c1);
        db.persist(c2);
        db.persist(c3);
        transaction1.commit();
        return true;
    } catch (const std::exception & e) {
        std::cerr << e.what() << std::endl;
        return false;
    }
}

bool insert_student(odb::mysql::database &db) 
{
    try {
        odb::mysql::transaction transaction2(db.begin());
        Student s1("chen"  , 12, 1);
        Student s2("fas"   , 22, 1);
        Student s3("fadsf" , 14, 1);
        Student s4("zdfgho", 23, 2);
        Student s5("zretw" , 25, 2);
        Student s6("h3asdf", 54, 2);
        Student s7("5hq3"  , 34, 3);
        Student s8("qerwfn", 33, 3);
        Student s9("gqwr"  , 25, 3);
        db.persist(s1);
        db.persist(s2);
        db.persist(s3);
        db.persist(s4);
        db.persist(s5);
        db.persist(s6);
        db.persist(s7);
        db.persist(s8);
        db.persist(s9);
        transaction2.commit();
        return true;
    } catch (const std::exception & e) {
        std::cerr << e.what() << std::endl;
        return false;
    }
}

Student select_student(odb::mysql::database &db) 
{
    Student ret;
    try {
        odb::mysql::transaction transaction2(db.begin());

        typedef odb::query<Student> query;
        typedef odb::result<Student> result;
        result r(db.query<Student>(query::name == "chen"));
        if(r.size() != 1) {
            throw "数据数量不对！";
        }

        ret = *r.begin();

        transaction2.commit();
        return ret;
    } catch (const std::exception & e) {
        std::cerr << e.what() << std::endl;
        return ret;
    }
}

// 多表查询
std::vector<struct class_student_view> join_student_class(odb::mysql::database &db) 
{
    try {
        odb::mysql::transaction transaction2(db.begin());

        typedef odb::query<struct class_student_view> query;
        typedef odb::result<struct class_student_view> result;
        result r(db.query<struct class_student_view>(query::Student::class_id == query::Student::class_id));
        if(r.size() < 0) {
            throw "数据数量不对！";
            transaction2.commit();
            return {};
        } else {
            return std::vector<struct class_student_view>(r.begin(), r.end());
        }

    } catch (const std::exception & e) {
        std::cerr << e.what() << std::endl;
        return {};
    }
}

int main(int argc, char* argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    // 1. 构造连接池工厂配置对象 
    std::unique_ptr<odb::mysql::connection_pool_factory> connection_factory(
        new odb::mysql::connection_pool_factory(
            FLAGS_max_pool, 0
        )
    );

    // 2. 构造数据库操作对象
    odb::mysql::database db(
        FLAGS_user,
        FLAGS_passwd,
        FLAGS_db,
        FLAGS_mysql_host,
        FLAGS_mysql_port,
        "",
        FLAGS_charset,
        0,
        std::move(connection_factory)
    );


    // 3. 获取事务操作对象，开启事务
    // 4. 数据的增删查改操作
    // 5. 提交事务

    // insert_class(db);
    // insert_student(db);

    // Student ret = select_student(db);
    // std::cout << ret.GetName() << std::endl;
    // std::cout << (ret.GetAge() ? ret.GetAge().get() : -1) << std::endl;
    // std::cout << ret.GetClassID() << std::endl;
    // std::cout << ret.GetStuID() << std::endl;

    std::vector<struct class_student_view> ret = join_student_class(db);
    for(auto &e : ret) {
        std::cout << (e._age ? *e._age : -1) << "\t"
                  << e._name << "\t"
                  << e._class_name << "\t"
                  << e._stu_id << std::endl;
    }

    return 0;
}

--- FILE: Examples/3.rabbitmq/consumer.cc ---
内容:
/**
 *  @author czw
 */

/**
 *  Dependencies
 */
#include <ev.h>
#include <amqpcpp.h>
#include <amqpcpp/libev.h>
#include <openssl/ssl.h>
#include <openssl/opensslv.h>
#include <amqpcpp/message.h>

#include <functional>
#include <gflags/gflags.h>

#include "../../Common/logger.hpp"
#include "../../Common/rabbitmq.hpp"

// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");


// mq
DEFINE_string(user, "chen", "rabbitmq的用户名");
DEFINE_string(password, "czhuowen", "rabbitmq的密码");
DEFINE_string(rabbitmq_host, "127.0.0.1:5672", "rabbitmq的服务器地址");



void my_cb(const char *msg, size_t size) {
    LOG_INFO("consumer收到消息：{}", msg);
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    // 定义一个客户端
    MQClient rabbit_client(FLAGS_user, FLAGS_password, FLAGS_rabbitmq_host);
    rabbit_client.declear_all_components("exchange1", "queue1");
    rabbit_client.consume_message("queue1", "consume-tag", my_cb);

    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 0;
}

--- FILE: Examples/3.rabbitmq/publisher.cc ---
内容:
/**
 *  @author czw
 */

/**
 *  Dependencies
 */
#include <ev.h>
#include <amqpcpp.h>
#include <amqpcpp/libev.h>
#include <openssl/ssl.h>
#include <openssl/opensslv.h>

#include <gflags/gflags.h>

#include "../../Common/logger.hpp"
#include "../../Common/rabbitmq.hpp"

// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");


// mq
DEFINE_string(user, "chen", "rabbitmq的用户名");
DEFINE_string(password, "czhuowen", "rabbitmq的密码");
DEFINE_string(rabbitmq_host, "127.0.0.1:5672", "rabbitmq的服务器地址");


int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    // 定义一个客户端
    MQClient rabbit_client(FLAGS_user, FLAGS_password, FLAGS_rabbitmq_host);
    rabbit_client.declear_all_components("exchange1", "queue1");
    rabbit_client.publish_message("exchange1", "hello consumer!");
    rabbit_client.publish_message("exchange1", "hello consumer!");
    rabbit_client.publish_message("exchange1", "hello consumer!");
    rabbit_client.publish_message("exchange1", "hello consumer!");
    rabbit_client.publish_message("exchange1", "hello consumer!");
    rabbit_client.publish_message("exchange1", "hello consumer!");
    rabbit_client.publish_message("exchange1", "hello consumer!");



    std::this_thread::sleep_for(std::chrono::seconds(2));

    return 0;
}

--- FILE: Examples/3.rabbitmq/Makefile ---
内容:
all:publisher consumer
publisher: publisher.cc
	g++ -g -o $@ $^ -std=c++17 -lamqpcpp -lev -lpthread -ldl -lgflags
consumer: consumer.cc
	g++ -g -o $@ $^ -std=c++17 -lamqpcpp -lev -lpthread -ldl -lgflags

.PHONY:clean
clean:
	rm -f publisher consumer

--- FILE: 6.Friend_Server/relation.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

USE `chen_im`;

DROP TABLE IF EXISTS `relation`;

CREATE TABLE `relation` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL,
  `peer_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE INDEX `user_id_i`
  ON `relation` (`user_id`);



--- FILE: 6.Friend_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 1. 添加cmake版本说明
cmake_minimum_required(VERSION 3.1.3)
# 2. 声明工程名称
project(friend_server)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

set(target "friend_server")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# 3. 检测并生成ODB框架代码
#   1. 添加所需的proto映射代码文件名称
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files base.proto user.proto message_storage.proto friend.proto)
#   2. 检测框架代码文件是否已经生成
set(proto_hxx "")
set(proto_cxx "")
set(proto_srcs "")
foreach(proto_file ${proto_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file})
    string(REPLACE ".proto" ".pb.h" proto_hh  ${proto_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc
            ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成Protobuf框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 3. 检测并生成ODB框架代码
#   1. 添加所需的odb映射代码文件名称
set(odb_path ${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
set(odb_files chat_session_member.hxx chat_session.hxx friend_apply.hxx relation.hxx message.hxx)
#   2. 检测框架代码文件是否已经生成
set(odb_hxx "")
set(odb_cxx "")
set(odb_srcs "")
foreach(odb_file ${odb_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".hxx" "-odb.hxx" odb_hxx ${odb_file})
    string(REPLACE ".hxx" "-odb.cxx" odb_cxx ${odb_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${odb_cxx})
        add_custom_command(
            PRE_BUILD
            COMMAND odb
            ARGS -d mysql --std c++17 --generate-query --generate-schema --profile boost/date-time ${odb_path}/${odb_file}
            DEPENDS ${odb_path}/${odb_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
            COMMENT "生成ODB框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
        )
    endif()
#   4. 将所有生成的框架源码文件名称保存起来 student-odb.cxx classes-odb.cxx
    list(APPEND odb_srcs ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)
# 5. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs} ${odb_srcs})
# 7. 设置需要连接的库
target_link_libraries(${target} -lgflags 
    -lspdlog -lfmt -lbrpc -lssl -lcrypto 
    -lprotobuf -lleveldb -letcd-cpp-api 
    -lcpprest -lcurl -lodb-mysql -lodb -lodb-boost
    /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
    -lcpr -lelasticlient -ldl -lpthread)


set(test_client "friend_client")
set(test_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test test_files)
add_executable(${test_client} ${test_files} ${proto_srcs})
target_link_libraries(${test_client} -pthread -lgtest -lgflags -lspdlog -lfmt -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19 -ldl)

# 6. 设置头文件默认搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Third-party)

#8. 设置安装路径
INSTALL(TARGETS ${target} ${test_client} RUNTIME DESTINATION bin)

--- FILE: 6.Friend_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/friend_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./friend_server.conf /im/conf

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/friend_server -flagfile=/im/conf/friend_server.conf

--- FILE: 6.Friend_Server/chat_session_member.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `chat_session_member`;

CREATE TABLE `chat_session_member` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `chat_session_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE INDEX `session_id_i`
  ON `chat_session_member` (`session_id`);



--- FILE: 6.Friend_Server/chat_session.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

USE `chen_im`;

DROP TABLE IF EXISTS `chat_session`;

CREATE TABLE `chat_session` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `chat_session_id` varchar(64) NOT NULL,
  `chat_session_name` varchar(64) NOT NULL,
  `chat_session_type` tinyint NOT NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `chat_session_id_i`
  ON `chat_session` (`chat_session_id`);



--- FILE: 6.Friend_Server/friend_server.conf ---
内容:
-run_mode              = false                          # 程序的运行模式，false-调试； true-发布；
-log_file              = /im/logs/friend_server.log     # 发布模式下，用于指定日志的输出文件
-log_level             = 0                              # 发布模式下，用于指定日志输出等级
-registry_host         = http://127.0.0.1:2379         # 服务注册中心地址
-instance_name         = /friend_service/instance       # 当前实例名称
-access_host           = 127.0.0.1:10006               # 当前实例的外部访问地址
-listen_port           = 10006                          # Rpc服务器监听端口
-rpc_timeout           = -1                             # Rpc调用超时时间
-rpc_threads           = 1                              # Rpc的IO线程数量"
-base_service          = /service                       # 服务监控根目录
-user_service          = /service/user_service          # 用户管理子服务名称
-message_store_service = /service/message_store_service # 消息存储子服务名称
-es_host               = http://127.0.0.1:9200/        # ES搜索引擎服务器URL
-mysql_host            = 127.0.0.1                     # Mysql服务器访问地址
-mysql_user            = root                           # Mysql服务器访问用户名
-mysql_pswd            = Cydia4384!                     # Mysql服务器访问密码
-mysql_db              = root_im                        # Mysql默认库名称
-mysql_cset            = utf8                           # Mysql客户端字符集
-mysql_access_port     = 0                              # Mysql服务器访问端口
-mysql_pool_count      = 4                              # Mysql连接池最大连接数量

--- FILE: 6.Friend_Server/friend_apply.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

USE `chen_im`;

DROP TABLE IF EXISTS `friend_apply`;

CREATE TABLE `friend_apply` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `event_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL,
  `peer_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `event_id_i`
  ON `friend_apply` (`event_id`);

CREATE INDEX `user_id_i`
  ON `friend_apply` (`user_id`);

CREATE INDEX `peer_id_i`
  ON `friend_apply` (`peer_id`);



--- FILE: 6.Friend_Server/test/friend_client.cc ---
内容:
#include "etcd.hpp"
#include "rpc_service_manager.hpp"
#include "utility.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <thread>
#include "friend.pb.h"


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(friend_service, "/service/friend_service", "服务监控根目录");

std::shared_ptr<chen_im::ServiceManager> sm;

void apply_test(const std::string &uid1, const std::string &uid2) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::FriendAddReq req;
    chen_im::FriendAddRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    req.set_respondent_id(uid2);
    brpc::Controller cntl;
    stub.FriendAdd(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

void get_apply_list(const std::string &uid1) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::GetPendingFriendEventListReq req;
    chen_im::GetPendingFriendEventListRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    brpc::Controller cntl;
    stub.GetPendingFriendEventList(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    for (int i = 0; i < rsp.event_size(); i++) {
        std::cout << "---------------\n";
        std::cout << rsp.event(i).sender().user_id() << std::endl;
        std::cout << rsp.event(i).sender().nickname() << std::endl;
        std::cout << rsp.event(i).sender().avatar() << std::endl;
    }
}

void process_apply_test(const std::string &uid1, bool agree, const std::string &apply_user_id) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::FriendAddProcessReq req;
    chen_im::FriendAddProcessRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    req.set_agree(agree);
    req.set_apply_user_id(apply_user_id);
    brpc::Controller cntl;
    stub.FriendAddProcess(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    if (agree) {
        std::cout << rsp.new_session_id() << std::endl;
    }
}

void search_test(const std::string &uid1, const std::string &key) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::FriendSearchReq req;
    chen_im::FriendSearchRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    req.set_search_key(key);
    brpc::Controller cntl;
    stub.FriendSearch(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    for (int i = 0; i < rsp.user_info_size(); i++) {
        std::cout << "-------------------\n";
        std::cout << rsp.user_info(i).user_id() << std::endl;
        std::cout << rsp.user_info(i).nickname() << std::endl;
        std::cout << rsp.user_info(i).avatar() << std::endl;
    }
}

void friend_list_test(const std::string &uid1) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::GetFriendListReq req;
    chen_im::GetFriendListRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    brpc::Controller cntl;
    stub.GetFriendList(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    for (int i = 0; i < rsp.friend_list_size(); i++) {
        std::cout << "-------------------\n";
        std::cout << rsp.friend_list(i).user_id() << std::endl;
        std::cout << rsp.friend_list(i).nickname() << std::endl;
        std::cout << rsp.friend_list(i).avatar() << std::endl;
    }
}


void remove_test(const std::string &uid1, const std::string &uid2) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::FriendRemoveReq req;
    chen_im::FriendRemoveRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    req.set_peer_id(uid2);
    brpc::Controller cntl;
    stub.FriendRemove(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}
void create_css_test(const std::string &uid1, const std::vector<std::string> &uidlist) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::ChatSessionCreateReq req;
    chen_im::ChatSessionCreateRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    req.set_chat_session_name("快乐一家人");
    for (auto &id : uidlist) {
        req.add_member_id_list(id);
    }
    brpc::Controller cntl;
    stub.ChatSessionCreate(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    std::cout << rsp.chat_session_info().chat_session_id() << std::endl;
    std::cout << rsp.chat_session_info().chat_session_name() << std::endl;
}


void cssmember_test(const std::string &uid1, const std::string &cssid) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::GetChatSessionMemberReq req;
    chen_im::GetChatSessionMemberRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    req.set_chat_session_id(cssid);
    brpc::Controller cntl;
    stub.GetChatSessionMember(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    for (int i = 0; i < rsp.member_info_list_size(); i++) {
        std::cout << "-------------------\n";
        std::cout << rsp.member_info_list(i).user_id() << std::endl;
        std::cout << rsp.member_info_list(i).nickname() << std::endl;
        std::cout << rsp.member_info_list(i).avatar() << std::endl;
    }
}


void csslist_test(const std::string &uid1) {
    auto channel = sm->get(FLAGS_friend_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::FriendService_Stub stub(channel.get());
    chen_im::GetChatSessionListReq req;
    chen_im::GetChatSessionListRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid1);
    brpc::Controller cntl;
    std::cout << "发送获取聊天会话列表请求！！\n";
    stub.GetChatSessionList(&cntl, &req, &rsp, nullptr);
    std::cout << "请求发送完毕1！！\n";
    ASSERT_FALSE(cntl.Failed());
    std::cout << "请求发送完毕2！！\n";
    ASSERT_TRUE(rsp.success());
    std::cout << "请求发送完毕，且成功！！\n";
    for (int i = 0; i < rsp.chat_session_info_list_size(); i++) {
        std::cout << "-------------------\n";
        std::cout << rsp.chat_session_info_list(i).single_chat_friend_id() << std::endl;
        std::cout << rsp.chat_session_info_list(i).chat_session_id() << std::endl;
        std::cout << rsp.chat_session_info_list(i).chat_session_name() << std::endl;
        std::cout << rsp.chat_session_info_list(i).avatar() << std::endl;
        std::cout << "消息内容：\n";
        std::cout << rsp.chat_session_info_list(i).prev_message().message_id() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().chat_session_id() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().timestamp() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().sender().user_id() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().sender().nickname() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().sender().avatar() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().message().file_message().file_name() << std::endl;
        std::cout << rsp.chat_session_info_list(i).prev_message().message().file_message().file_contents() << std::endl;
    }
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    
    //1. 先构造Rpc信道管理对象
    sm = std::make_shared<chen_im::ServiceManager>();
    sm->concern(FLAGS_friend_service);
    auto put_cb = std::bind(&chen_im::ServiceManager::when_service_online, sm.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&chen_im::ServiceManager::when_service_offline, sm.get(), std::placeholders::_1, std::placeholders::_2);
    //2. 构造服务发现对象
    chen_im::Discovery::ptr dclient = std::make_shared<chen_im::Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    

    // apply_test("731f-50086884-0000", "c4dc-68239a9a-0001");
    // apply_test("31ab-86a1209d-0000", "c4dc-68239a9a-0001");
    // apply_test("053f-04e5e4c5-0001", "c4dc-68239a9a-0001");
    // get_apply_list("c4dc-68239a9a-0001");
    // process_apply_test("c4dc-68239a9a-0001", true, "731f-50086884-0000");
    // process_apply_test("c4dc-68239a9a-0001", false, "31ab-86a1209d-0000");
    // process_apply_test("c4dc-68239a9a-0001", true, "053f-04e5e4c5-0001");
    // std::cout << "**********************\n";
    // search_test("c4dc-68239a9a-0001", "猪");
    // std::cout << "++++++++++++++++++++++\n";
    // search_test("731f-50086884-0000", "猪");
    // std::cout << "======================\n";
    // search_test("31ab-86a1209d-0000", "乔治");
    // friend_list_test("c4dc-68239a9a-0001");
    // std::cout << "++++++++++++++++++++++\n";
    // friend_list_test("731f-50086884-0000");
    // std::cout << "++++++++++++++++++++++\n";
    // friend_list_test("31ab-86a1209d-0000");
    // remove_test("c4dc-68239a9a-0001", "053f-04e5e4c5-0001");
    // std::vector<std::string> uidlist = {
    //     "731f-50086884-0000", 
    //     "c4dc-68239a9a-0001",
    //     "31ab-86a1209d-0000",
    //     "053f-04e5e4c5-0001"};
    // create_css_test("731f-50086884-0000", uidlist);
    // cssmember_test("731f-50086884-0000", "36b5-edaf4987-0000");
    // std::cout << "++++++++++++++++++++++\n";
    // cssmember_test("c4dc-68239a9a-0001", "36b5-edaf4987-0000");

    csslist_test("c4dc-68239a9a-0001");
    return 0;
}

--- FILE: 6.Friend_Server/test/mysql_test/main.cc ---
内容:
#include "mysql_chat_session.hpp"
#include "mysql_apply.hpp"
#include "mysql_relation.hpp"
#include <gflags/gflags.h>

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

void r_insert_test(chen_im::RelationTable &tb) {
    tb.insert("用户ID1", "用户ID2");
    tb.insert("用户ID1", "用户ID3");
}
void r_select_test(chen_im::RelationTable &tb) {
    auto res = tb.get_friends("c4dc-68239a9a-0001");
    for (auto &uid:res) {
        std::cout << uid << std::endl;
    }
}
void r_remove_test(chen_im::RelationTable &tb) {
    tb.remove("用户ID2", "用户ID1");
}
 
void r_exists_test(chen_im::RelationTable &tb) {
    std::cout << tb.exists("用户ID2", "用户ID1") << std::endl;
    std::cout << tb.exists("用户ID3", "用户ID1") << std::endl;
}

void a_insert_test(chen_im::FriendApplyTable &tb) {
    chen_im::FriendApply fa1("uuid1", "用户ID1", "用户ID2");
    tb.insert(fa1);
    
    chen_im::FriendApply fa2("uuid2", "用户ID1", "用户ID3");
    tb.insert(fa2);

    chen_im::FriendApply fa3("uuid3", "用户ID2", "用户ID3");
    tb.insert(fa3);
}
void a_remove_test(chen_im::FriendApplyTable &tb) {
    tb.remove("用户ID2", "用户ID3");
}

void a_select_test(chen_im::FriendApplyTable &tb) {
    // chen_im::FriendApply fa3("uuid3", "用户ID2", "用户ID3");
    // tb.insert(fa3);

    auto res = tb.apply_users("用户ID2");
    for (auto &uid:res) {
        std::cout << uid << std::endl;
    }
}
void a_exists_test(chen_im::FriendApplyTable &tb) {
    std::cout << tb.exists("731f-50086884-0000", "c4dc-68239a9a-0001") << std::endl;
    std::cout << tb.exists("31ab-86a1209d-0000", "c4dc-68239a9a-0001") << std::endl;
    std::cout << tb.exists("053f-04e5e4c5-0001", "c4dc-68239a9a-0001") << std::endl;
}

void c_insert_test(chen_im::ChatSessionTable &tb) {
    chen_im::ChatSession cs1("会话ID1", "会话名称1", chen_im::ChatSessionType::SINGLE);
    tb.insert(cs1);
    chen_im::ChatSession cs2("会话ID2", "会话名称2", chen_im::ChatSessionType::GROUP);
    tb.insert(cs2);
}


void c_select_test(chen_im::ChatSessionTable &tb) {
    auto res = tb.select("会话ID1");
    std::cout << res->chat_session_id() << std::endl;
    std::cout << res->chat_session_name() << std::endl;
    std::cout << (int)res->chat_session_type() << std::endl;
}

void c_single_test(chen_im::ChatSessionTable &tb) {
    auto res = tb.singleChatSession("731f-50086884-0000");
    for (auto &info : res) {
        std::cout << info.chat_session_id << std::endl;
        std::cout << info.friend_id << std::endl;
    }
}
void c_group_test(chen_im::ChatSessionTable &tb) {
    auto res = tb.groupChatSession("用户ID1");
    for (auto &info : res) {
        std::cout << info.chat_session_id << std::endl;
        std::cout << info.chat_session_name << std::endl;
    }
}
void c_remove_test(chen_im::ChatSessionTable &tb) {
    tb.remove("会话ID3");
}
void c_remove_test2(chen_im::ChatSessionTable &tb) {
    tb.remove("731f-50086884-0000", "c4dc-68239a9a-0001");
}
 

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);
    
    auto db = chen_im::ODBFactory::create("root", "123456", "127.0.0.1", "chen_im", "utf8", 0, 1);
    chen_im::RelationTable rtb(db);
    chen_im::FriendApplyTable fatb(db);
    chen_im::ChatSessionTable cstb(db);

    // r_insert_test(rtb);
    r_select_test(rtb);
    // r_remove_test(rtb);
    // r_exists_test(rtb);
    // a_insert_test(fatb);
    // a_remove_test(fatb);
    // a_select_test(fatb);
    // a_exists_test(fatb);
    // c_insert_test(cstb);
    // c_select_test(cstb);
    // c_single_test(cstb);
    // std::cout << "--------------\n";
    // c_group_test(cstb);
    // c_remove_test(cstb);
    // c_remove_test2(cstb);
    return 0;
}

--- FILE: 6.Friend_Server/test/mysql_test/relation.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

use chen_im;
DROP TABLE IF EXISTS `relation`;

CREATE TABLE `relation` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL,
  `peer_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE INDEX `user_id_i`
  ON `relation` (`user_id`);



--- FILE: 6.Friend_Server/test/mysql_test/chat_session_member.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `chat_session_member`;

CREATE TABLE `chat_session_member` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `session_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE INDEX `session_id_i`
  ON `chat_session_member` (`session_id`);



--- FILE: 6.Friend_Server/test/mysql_test/chat_session.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `chat_session`;

CREATE TABLE `chat_session` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `chat_session_id` varchar(64) NOT NULL,
  `chat_session_name` varchar(64) NOT NULL,
  `chat_session_type` tinyint NOT NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `chat_session_id_i`
  ON `chat_session` (`chat_session_id`);



--- FILE: 6.Friend_Server/test/mysql_test/Makefile ---
内容:
CFLAGS = -I/usr/include/mysql -I../../../odb/ -I../../../common -I./ 
OBJS = friend_apply-odb.o  relation-odb.o chat_session_member-odb.o chat_session-odb.o
.PHONY : main
main : main.cc friend_apply-odb.cxx  relation-odb.cxx chat_session_member-odb.cxx chat_session-odb.cxx
	g++ -std=c++17 $^ -o $@   -lodb-mysql $(CFLAGS) -lodb -lodb-boost -lfmt -lspdlog -lgflags

%.o : %.cxx
	g++ -std=c++17 -c $^ -o $@ $(CFLAGS)

--- FILE: 6.Friend_Server/test/mysql_test/friend_apply.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

use chen_im;
DROP TABLE IF EXISTS `friend_apply`;

CREATE TABLE `friend_apply` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `event_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL,
  `peer_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `event_id_i`
  ON `friend_apply` (`event_id`);

CREATE INDEX `user_id_i`
  ON `friend_apply` (`user_id`);

CREATE INDEX `peer_id_i`
  ON `friend_apply` (`peer_id`);



--- FILE: 6.Friend_Server/source/friend_server.cc ---
内容:
//主要实现语音识别子服务的服务器的搭建
#include "friend_server.hpp"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(registry_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(instance_name, "/friend_service/instance", "当前实例名称");
DEFINE_string(access_host, "127.0.0.1:10006", "当前实例的外部访问地址");

DEFINE_int32(listen_port, 10006, "Rpc服务器监听端口");
DEFINE_int32(rpc_timeout, -1, "Rpc调用超时时间");
DEFINE_int32(rpc_threads, 1, "Rpc的IO线程数量");


DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(user_service, "/service/user_service", "用户管理子服务名称");
DEFINE_string(message_store_service, "/service/message_store_service", "消息存储子服务名称");

DEFINE_string(es_host, "http://127.0.0.1:9200/", "ES搜索引擎服务器URL");

DEFINE_string(mysql_host, "127.0.0.1", "Mysql服务器访问地址");
DEFINE_string(mysql_user, "chen", "Mysql服务器访问用户名");
DEFINE_string(mysql_pswd, "Cydia4384!", "Mysql服务器访问密码");
DEFINE_string(mysql_db, "chen_im", "Mysql默认库名称");
DEFINE_string(mysql_cset, "utf8", "Mysql客户端字符集");
DEFINE_int32(mysql_access_port, 0, "Mysql服务器访问端口");
DEFINE_int32(mysql_pool_count, 4, "Mysql连接池最大连接数量");




int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    chen_im::FriendServerFactory fsb;
    fsb.make_es_object({FLAGS_es_host});
    fsb.make_mysql_object(FLAGS_mysql_user, FLAGS_mysql_pswd, FLAGS_mysql_host, 
        FLAGS_mysql_db, FLAGS_mysql_cset, FLAGS_mysql_access_port, FLAGS_mysql_pool_count);
    fsb.make_discovery_object(FLAGS_registry_host, FLAGS_base_service, FLAGS_user_service, FLAGS_message_store_service);
    fsb.make_rpc_server(FLAGS_listen_port, FLAGS_rpc_timeout, FLAGS_rpc_threads);
    fsb.make_registry_object(FLAGS_registry_host, FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);
    auto server = fsb.build();
    server->start();
    return 0;
}

--- FILE: 6.Friend_Server/source/friend_server.hpp ---
内容:
// 实现语音识别子服务
#include <brpc/server.h>
#include <butil/logging.h>

#include "elasticsearch_user.hpp"        // es数据管理客户端封装
#include "mysql_chat_session_member.hpp" // mysql数据管理客户端封装
#include "mysql_chat_session.hpp"        // mysql数据管理客户端封装
#include "mysql_relation.hpp"            // mysql数据管理客户端封装
#include "mysql_apply.hpp"               // mysql数据管理客户端封装
#include "etcd.hpp"                      // 服务注册模块封装
#include "logger.hpp"                    // 日志模块封装
#include "utility.hpp"                   // 基础工具接口
#include "rpc_service_manager.hpp"       // 信道管理模块封装

#include "friend.pb.h"          // protobuf框架代码
#include "base.pb.h"            // protobuf框架代码
#include "user.pb.h"            // protobuf框架代码
#include "message_storage.pb.h" // protobuf框架代码

namespace chen_im
{
    class FriendServiceImpl : public chen_im::FriendService
    {
    public:
        FriendServiceImpl(const std::shared_ptr<elasticlient::Client> &es_client,
                          const std::shared_ptr<odb::mysql::database> &mysql_client,
                          const std::shared_ptr<ServiceManager> &channel_manager,
                          const std::string &user_service_name,
                          const std::string &message_store_service_name) 
            : _es_user(std::make_shared<ESUser>(es_client)),
              _mysql_apply(std::make_shared<FriendApplyTable>(mysql_client)),
              _mysql_chat_session(std::make_shared<ChatSessionTable>(mysql_client)),
              _mysql_chat_session_member(std::make_shared<ChatSessionMemeberTable>(mysql_client)),
              _mysql_relation(std::make_shared<RelationTable>(mysql_client)),
              _user_service_name(user_service_name),
              _message_store_service_name(message_store_service_name),
              _service_manager(channel_manager) 
        {}

        ~FriendServiceImpl() {}

        // 根据用户id获取该用户的好友列表
        virtual void GetFriendList(::google::protobuf::RpcController *controller,
                                   const ::chen_im::GetFriendListReq *request,
                                   ::chen_im::GetFriendListRsp *response,
                                   ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 1. 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };

            // 1. 提取请求中的关键要素：用户ID
            std::string request_id = request->request_id();
            std::string uid = request->user_id();

            // 2. 从数据库中查询获取用户的好友ID
            auto friend_id_lists = _mysql_relation->get_friends(uid);
            std::unordered_set<std::string> user_id_lists;
            for (auto &id : friend_id_lists) {
                user_id_lists.insert(id);
            }

            // 3. 从用户子服务批量获取用户信息
            std::unordered_map<std::string, UserInfo> user_list;
            bool ret = _get_user_info(request_id, user_id_lists, &user_list);
            if (ret == false)
            {
                LOG_ERROR("{} - 批量获取用户信息失败!", request_id);
                return err_response(request_id, "批量获取用户信息失败!");
            }

            // 4. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &user_it : user_list)
            {
                auto user_info = response->add_friend_list();
                user_info->CopyFrom(user_it.second);
            }
        }

        // 删除好友
        virtual void FriendRemove(::google::protobuf::RpcController *controller,
                                  const ::chen_im::FriendRemoveReq *request,
                                  ::chen_im::FriendRemoveRsp *response,
                                  ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };

            // 1. 提取关键要素：当前用户ID，要删除的好友ID
            std::string request_id = request->request_id();
            std::string uid = request->user_id();
            std::string pid = request->peer_id();

            // 2. 从好友关系表中删除好友关系信息
            bool ret = _mysql_relation->remove(uid, pid);
            if (ret == false)
            {
                LOG_ERROR("{} - 从数据库删除好友信息失败！", request_id);
                return err_response(request_id, "从数据库删除好友信息失败！");
            }

            // 3. 从会话信息表中，删除对应的聊天会话 -- 同时删除会话成员表中的成员信息
            ret = _mysql_chat_session->remove(uid, pid);
            if (ret == false)
            {
                LOG_ERROR("{}- 从数据库删除好友会话信息失败！", request_id);
                return err_response(request_id, "从数据库删除好友会话信息失败！");
            }

            // 4. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
        }

        // 用户发起的添加好友请求，把申请信息写入friend_apply表，新生成一个event_id
        // 未来被申请的用户在接收或拒绝好友添加请求的函数（FriendAddProcess）中，可以通过检查friend_apply表，查看是否存在该申请
        virtual void FriendAdd(::google::protobuf::RpcController *controller,
                               const ::chen_im::FriendAddReq *request,
                               ::chen_im::FriendAddRsp *response,
                               ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 提取请求中的关键要素：申请人用户ID； 被申请人用户ID
            std::string request_id = request->request_id();
            std::string uid = request->user_id();       // 申请人用户ID
            std::string pid = request->respondent_id(); // 被申请人用户ID

            // 2. 判断两人是否已经是好友
            bool ret = _mysql_relation->exists(uid, pid);
            if (ret == true) {
                LOG_ERROR("{} - 申请好友失败-两者{}-{}已经是好友关系", request_id, uid, pid);
                return err_response(request_id, "两者已经是好友关系！");
            }

            // 3. 当前是否已经申请过好友
            ret = _mysql_apply->exists(uid, pid);
            if (ret == true) {
                LOG_ERROR("{} - 申请好友失败-已经申请过对方好友！", request_id, uid, pid);
                return err_response(request_id, "已经申请过对方好友！");
            }

            // 4. 向好友申请表中，新增申请信息
            std::string event_id = generate_uuid();
            FriendApply friend_apply_event(event_id, uid, pid);
            ret = _mysql_apply->insert(friend_apply_event);
            if (ret == false) {
                LOG_ERROR("{} - 向数据库新增好友申请事件失败！", request_id);
                return err_response(request_id, "向数据库新增好友申请事件失败！");
            }

            // 5. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            response->set_notify_event_id(event_id);
        }

        // 用户接收到好友请求，选择“接受”或“拒绝”
        virtual void FriendAddProcess(::google::protobuf::RpcController *controller,
                                      const ::chen_im::FriendAddProcessReq *request,
                                      ::chen_im::FriendAddProcessRsp *response,
                                      ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 1. 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 提取请求中的关键要素：申请人用户ID；被申请人用户ID；处理结果；事件ID
            std::string request_id = request->request_id();
            std::string eid = request->notify_event_id();
            std::string uid = request->user_id();       // 被申请人
            std::string pid = request->apply_user_id(); // 申请人
            bool agree = request->agree();              // 是否同意好友请求

            // 2. 判断有没有该申请事件
            bool ret = _mysql_apply->exists(pid, uid);
            if (ret == false) {
                LOG_ERROR("{}- 没有找到{}-{}对应的好友申请事件！", request_id, pid, uid);
                return err_response(request_id, "没有找到对应的好友申请事件!");
            }

            // 3. 如果有： 可以处理； --- 删除申请事件--事件已经处理完毕
            ret = _mysql_apply->remove(pid, uid);
            if (ret == false) {
                LOG_ERROR("{} - 从数据库删除申请好友事件 {}-{} 失败！", request_id, pid, uid);
                return err_response(request_id, "从数据库删除申请好友事件失败!");
            }

            // 4. 如果处理结果是同意：向数据库新增好友关系信息；并新增单聊会话信息及会话成员
            std::string chat_sid;
            if (agree == true)
            {
                ret = _mysql_relation->insert(uid, pid);
                if (ret == false)
                {
                    LOG_ERROR("{} - 新增好友关系信息: {}-{}！", request_id, uid, pid);
                    return err_response(request_id, "新增好友关系信息!");
                }
                chat_sid = generate_uuid();
                ChatSession cs(chat_sid, "", ChatSessionType::SINGLE);
                ret = _mysql_chat_session->insert(cs);
                if (ret == false)
                {
                    LOG_ERROR("{} - 新增单聊会话信息-{}！", request_id, chat_sid);
                    return err_response(request_id, "新增单聊会话信息失败!");
                }
                ChatSessionMember csm1(chat_sid, uid);
                ChatSessionMember csm2(chat_sid, pid);
                std::vector<ChatSessionMember> mlist = {csm1, csm2};
                ret = _mysql_chat_session_member->append(mlist);
                if (ret == false)
                {
                    LOG_ERROR("{} - 没有找到{}-{}对应的好友申请事件！", request_id, pid, uid);
                    return err_response(request_id, "没有找到对应的好友申请事件!");
                }
            }
            // 5. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            response->set_new_session_id(chat_sid);
        }

        // 好友搜索，通过关键字（可能是用户ID，可能是手机号，可能是昵称的一部分）搜索
        virtual void FriendSearch(::google::protobuf::RpcController *controller,
                                  const ::chen_im::FriendSearchReq *request,
                                  ::chen_im::FriendSearchRsp *response,
                                  ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 1. 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 提取请求中的关键要素：搜索关键字（可能是用户ID，可能是手机号，可能是昵称的一部分）
            std::string request_id = request->request_id();
            std::string uid = request->user_id();
            std::string keyword = request->search_key();
            LOG_DEBUG("{} 好友搜索 ： {}", uid, keyword);

            // 2. 根据用户ID，获取用户的好友ID列表
            auto friend_id_lists = _mysql_relation->get_friends(uid);

            // 3. 从ES搜索引擎进行用户信息搜索 --- 过滤掉当前已有的好友
            std::unordered_set<std::string> user_id_lists;
            friend_id_lists.push_back(uid); // 把自己也过滤掉
            std::vector<User> search_res = _es_user->search(keyword, friend_id_lists);
            for (auto &it : search_res) {
                user_id_lists.insert(it.user_id());
            }

            // 4. 根据获取到的用户ID，从用户子服务器进行批量用户信息获取
            std::unordered_map<std::string, UserInfo> user_list;
            bool ret = _get_user_info(request_id, user_id_lists, &user_list);
            if (ret == false) {
                LOG_ERROR("{} - 批量获取用户信息失败!", request_id);
                return err_response(request_id, "批量获取用户信息失败!");
            }

            // 5. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &user_it : user_list)
            {
                auto user_info = response->add_user_info();
                user_info->CopyFrom(user_it.second);
            }
        }

        // 获取当前挂起的好友申请
        virtual void GetPendingFriendEventList(::google::protobuf::RpcController *controller,
                                               const ::chen_im::GetPendingFriendEventListReq *request,
                                               ::chen_im::GetPendingFriendEventListRsp *response,
                                               ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 提取关键要素：当前用户ID
            std::string request_id = request->request_id();
            std::string uid = request->user_id();

            // 2. 从数据库获取待处理的申请事件信息 --- 申请人用户ID列表
            auto res = _mysql_apply->apply_users(uid);
            std::unordered_set<std::string> user_id_lists;
            for (auto &id : res) {
                user_id_lists.insert(id);
            }

            // 3. 向用户子服务批量获取申请人用户信息
            std::unordered_map<std::string, UserInfo> user_list;
            bool ret = _get_user_info(request_id, user_id_lists, &user_list);
            if (ret == false)
            {
                LOG_ERROR("{} - 批量获取用户信息失败!", request_id);
                return err_response(request_id, "批量获取用户信息失败!");
            }
            // 4. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &user_it : user_list)
            {
                auto ev = response->add_event();
                ev->mutable_sender()->CopyFrom(user_it.second);
            }
        }

        // 获取聊天会话列表
        virtual void GetChatSessionList(::google::protobuf::RpcController *controller,
                                        const ::chen_im::GetChatSessionListReq *request,
                                        ::chen_im::GetChatSessionListRsp *response,
                                        ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 1. 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 获取聊天会话的作用：一个用户登录成功后，能够展示自己的历史聊天信息
            // 1. 提取请求中的关键要素：当前请求用户ID
            std::string request_id = request->request_id();
            std::string uid = request->user_id();

            // 2. 从数据库中查询出当前用户的单聊会话列表
            auto sc_list = _mysql_chat_session->singleChatSession(uid);

            //  2.1 从单聊会话列表中，取出所有的好友ID，从用户子服务获取用户信息
            std::unordered_set<std::string> users_id_list;
            for (const auto &f : sc_list)
            {
                users_id_list.insert(f.friend_id);
            }
            std::unordered_map<std::string, UserInfo> user_list; // <user_id, 用户完整信息>
            bool ret = _get_user_info(request_id, users_id_list, &user_list);
            if (ret == false)
            {
                LOG_ERROR("{} - 批量获取用户信息失败！", request_id);
                return err_response(request_id, "批量获取用户信息失败!");
            }
            //  2.2 设置响应会话信息：会话名称就是好友名称；会话头像就是好友头像
            // 3. 从数据库中查询出用户的群聊会话列表
            auto gc_list = _mysql_chat_session->groupChatSession(uid);

            // 4. 根据所有的会话ID，从消息存储子服务获取会话最后一条消息
            // 5. 组织响应
            for (const auto &f : sc_list) // 单聊
            {
                auto chat_session_info = response->add_chat_session_info_list();
                chat_session_info->set_single_chat_friend_id(f.friend_id);
                chat_session_info->set_chat_session_id(f.chat_session_id);
                chat_session_info->set_chat_session_name(user_list[f.friend_id].nickname());
                chat_session_info->set_avatar(user_list[f.friend_id].avatar());
                MessageInfo msg;
                ret = _get_recent_msg(request_id, f.chat_session_id, &msg);
                if (ret == false)
                {
                    continue;
                }
                chat_session_info->mutable_prev_message()->CopyFrom(msg);
            }
            for (const auto &f : gc_list) // 群聊
            {
                auto chat_session_info = response->add_chat_session_info_list();
                chat_session_info->set_chat_session_id(f.chat_session_id);
                chat_session_info->set_chat_session_name(f.chat_session_name);
                MessageInfo msg;
                ret = _get_recent_msg(request_id, f.chat_session_id, &msg);
                if (ret == false)
                {
                    continue;
                }
                chat_session_info->mutable_prev_message()->CopyFrom(msg);
            }
            response->set_request_id(request_id);
            response->set_success(true);
        }

        // 创建会话，写入chat_session表和chat_session_member表
        virtual void ChatSessionCreate(::google::protobuf::RpcController *controller,
                                       const ::chen_im::ChatSessionCreateReq *request,
                                       ::chen_im::ChatSessionCreateRsp *response,
                                       ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 创建会话，其实针对的是用户要创建一个群聊会话
            // 1. 提取请求关键要素：会话名称，会话成员
            std::string request_id = request->request_id();
            std::string uid = request->user_id();
            std::string cssname = request->chat_session_name();

            // 2. 生成会话ID，向数据库添加会话信息，添加会话成员信息
            std::string cssid = generate_uuid();
            ChatSession cs(cssid, cssname, ChatSessionType::GROUP);
            bool ret = _mysql_chat_session->insert(cs);
            if (ret == false) {
                LOG_ERROR("{} - 向数据库添加会话信息失败: {}", request_id, cssname);
                return err_response(request_id, "向数据库添加会话信息失败!");
            }
            std::vector<ChatSessionMember> member_list;
            for (int i = 0; i < request->member_id_list_size(); i++)
            {
                ChatSessionMember csm(cssid, request->member_id_list(i));
                member_list.push_back(csm);
            }
            ret = _mysql_chat_session_member->append(member_list);
            if (ret == false)
            {
                LOG_ERROR("{} - 向数据库添加会话成员信息失败: {}", request_id, cssname);
                return err_response(request_id, "向数据库添加会话成员信息失败!");
            }
            // 3. 组织响应---组织会话信息
            response->set_request_id(request_id);
            response->set_success(true);
            response->mutable_chat_session_info()->set_chat_session_id(cssid);
            response->mutable_chat_session_info()->set_chat_session_name(cssname);
        }

        
        virtual void GetChatSessionMember(::google::protobuf::RpcController *controller,
                                          const ::chen_im::GetChatSessionMemberReq *request,
                                          ::chen_im::GetChatSessionMemberRsp *response,
                                          ::google::protobuf::Closure *done)
        {
            brpc::ClosureGuard rpc_guard(done);
            // 1. 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 用于用户查看群聊成员信息的时候：进行成员信息展示
            // 1. 提取关键要素：聊天会话ID
            std::string request_id = request->request_id();
            std::string uid = request->user_id();
            std::string cssid = request->chat_session_id();
            // 2. 从数据库获取会话成员ID列表
            auto member_id_lists = _mysql_chat_session_member->get_members(cssid);
            std::unordered_set<std::string> uid_list;
            for (const auto &id : member_id_lists)
            {
                uid_list.insert(id);
            }
            // 3. 从用户子服务批量获取用户信息
            std::unordered_map<std::string, UserInfo> user_list;
            bool ret = _get_user_info(request_id, uid_list, &user_list);
            if (ret == false)
            {
                LOG_ERROR("{} - 从用户子服务获取用户信息失败！", request_id);
                return err_response(request_id, "从用户子服务获取用户信息失败!");
            }
            // 4. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &uit : user_list)
            {
                auto user_info = response->add_member_info_list();
                user_info->CopyFrom(uit.second);
            }
        }

    private:
        // 从消息存储子服务中，取某个聊天会话id下的最近一条消息
        bool _get_recent_msg(const std::string &request_id,
                          const std::string &cssid, MessageInfo *msg)
        {
            auto channel = _service_manager->get(_message_store_service_name);
            if (!channel)
            {
                LOG_ERROR("{} - 获取消息子服务信道失败！！", request_id);
                return false;
            }
            GetRecentMsgReq req;
            GetRecentMsgRsp rsp;
            req.set_request_id(request_id);
            req.set_chat_session_id(cssid);
            req.set_msg_count(1);
            brpc::Controller cntl;
            chen_im::MsgStorageService_Stub stub(channel.get());
            stub.GetRecentMsg(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed() == true)
            {
                LOG_ERROR("{} - 消息存储子服务调用失败: {}", request_id, cntl.ErrorText());
                return false;
            }
            if (rsp.success() == false)
            {
                LOG_ERROR("{} - 获取会话 {} 最近消息失败: {}", request_id, cssid, rsp.errmsg());
                return false;
            }
            if (rsp.msg_list_size() > 0)
            {
                msg->CopyFrom(rsp.msg_list(0));
                return true;
            }
            return false;
        }

        // 根据用户id列表，批量从用户子服务，获取一批完整的用户数据，返回一张哈希表
        bool _get_user_info(const std::string &request_id,
                         const std::unordered_set<std::string> &uid_list,
                         std::unordered_map<std::string, UserInfo> *user_list)
        {
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} - 获取用户子服务信道失败！！", request_id);
                return false;
            }
            GetMultiUserInfoReq req;
            GetMultiUserInfoRsp rsp;
            req.set_request_id(request_id);
            for (auto &id : uid_list)
            {
                req.add_users_id(id);
            }
            brpc::Controller cntl;
            chen_im::UserService_Stub stub(channel.get());
            stub.GetMultiUserInfo(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed() == true)
            {
                LOG_ERROR("{} - 用户子服务调用失败: {}", request_id, cntl.ErrorText());
                return false;
            }
            if (rsp.success() == false)
            {
                LOG_ERROR("{} - 批量获取用户信息失败: {}", request_id, rsp.errmsg());
                return false;
            }
            for (const auto &user_it : rsp.users_info())
            {
                user_list->insert(std::make_pair(user_it.first, user_it.second));
            }
            return true;
        }

    private:
        ESUser::ptr _es_user;

        FriendApplyTable::ptr _mysql_apply;
        ChatSessionTable::ptr _mysql_chat_session;
        ChatSessionMemeberTable::ptr _mysql_chat_session_member;
        RelationTable::ptr _mysql_relation;

        // 这边是rpc调用客户端相关对象
        std::string _user_service_name;
        std::string _message_store_service_name;
        std::shared_ptr<ServiceManager> _service_manager;
    };

    class FriendServer
    {
    public:
        using ptr = std::shared_ptr<FriendServer>;
        FriendServer(const Discovery::ptr service_discoverer,
                     const Registry::ptr &reg_client,
                     const std::shared_ptr<elasticlient::Client> &es_client,
                     const std::shared_ptr<odb::mysql::database> &mysql_client,
                     const std::shared_ptr<brpc::Server> &server) : _service_discoverer(service_discoverer),
                                                                    _registry_client(reg_client),
                                                                    _es_client(es_client),
                                                                    _mysql_client(mysql_client),
                                                                    _rpc_server(server) {}
        ~FriendServer() {}
        // 搭建RPC服务器，并启动服务器
        void start()
        {
            _rpc_server->RunUntilAskedToQuit();
        }

    private:
        Discovery::ptr _service_discoverer;
        Registry::ptr _registry_client;
        std::shared_ptr<elasticlient::Client> _es_client;
        std::shared_ptr<odb::mysql::database> _mysql_client;
        std::shared_ptr<brpc::Server> _rpc_server;
    };

    class FriendServerFactory
    {
    public:
        // 构造es客户端对象
        void make_es_object(const std::vector<std::string> host_list)
        {
            _es_client = ESClientFactory::create(host_list);
        }
        // 构造mysql客户端对象
        void make_mysql_object(
            const std::string &user,
            const std::string &pswd,
            const std::string &host,
            const std::string &db,
            const std::string &cset,
            int port,
            int conn_pool_count)
        {
            _mysql_client = ODBFactory::create(user, pswd, db, host, port, cset, conn_pool_count);
        }
        // 用于构造服务发现客户端&信道管理对象
        void make_discovery_object(const std::string &reg_host,
                                   const std::string &base_service_name,
                                   const std::string &user_service_name,
                                   const std::string &message_store_service_name)
        {
            _user_service_name = user_service_name;
            _message_store_service_name = message_store_service_name;
            _service_manager = std::make_shared<ServiceManager>();
            _service_manager->concern(user_service_name);
            _service_manager->concern(message_store_service_name);
            LOG_DEBUG("设置用户子服务为需添加管理的子服务：{}", user_service_name);
            LOG_DEBUG("设置消息子服务为需添加管理的子服务：{}", message_store_service_name);
            auto put_cb = std::bind(&ServiceManager::when_service_online, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            auto del_cb = std::bind(&ServiceManager::when_service_offline, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            _service_discoverer = std::make_shared<Discovery>(reg_host, base_service_name, put_cb, del_cb);
        }
        // 用于构造服务注册客户端对象
        void make_registry_object(const std::string &reg_host,
                                  const std::string &service_name,
                                  const std::string &access_host)
        {
            _registry_client = std::make_shared<Registry>(reg_host);
            _registry_client->registry(service_name, access_host);
        }
        void make_rpc_server(uint16_t port, int32_t timeout, uint8_t num_threads)
        {
            if (!_es_client)
            {
                LOG_ERROR("还未初始化ES搜索引擎模块！");
                abort();
            }
            if (!_mysql_client)
            {
                LOG_ERROR("还未初始化Mysql数据库模块！");
                abort();
            }
            if (!_service_manager)
            {
                LOG_ERROR("还未初始化信道管理模块！");
                abort();
            }
            _rpc_server = std::make_shared<brpc::Server>();

            FriendServiceImpl *friend_service = new FriendServiceImpl(_es_client,
                                                                      _mysql_client, _service_manager, _user_service_name, _message_store_service_name);
            int ret = _rpc_server->AddService(friend_service,
                                              brpc::ServiceOwnership::SERVER_OWNS_SERVICE);
            if (ret == -1)
            {
                LOG_ERROR("添加Rpc服务失败！");
                abort();
            }
            brpc::ServerOptions options;
            options.idle_timeout_sec = timeout;
            options.num_threads = num_threads;
            ret = _rpc_server->Start(port, &options);
            if (ret == -1)
            {
                LOG_ERROR("服务启动失败！");
                abort();
            }
        }
        // 构造RPC服务器对象
        FriendServer::ptr build()
        {
            if (!_service_discoverer)
            {
                LOG_ERROR("还未初始化服务发现模块！");
                abort();
            }
            if (!_registry_client)
            {
                LOG_ERROR("还未初始化服务注册模块！");
                abort();
            }
            if (!_rpc_server)
            {
                LOG_ERROR("还未初始化RPC服务器模块！");
                abort();
            }
            FriendServer::ptr server = std::make_shared<FriendServer>(
                _service_discoverer, _registry_client,
                _es_client, _mysql_client, _rpc_server);
            return server;
        }

    private:
        Registry::ptr _registry_client;

        std::shared_ptr<elasticlient::Client> _es_client;
        std::shared_ptr<odb::mysql::database> _mysql_client;

        std::string _user_service_name;
        std::string _message_store_service_name;
        std::shared_ptr<ServiceManager> _service_manager;
        Discovery::ptr _service_discoverer;

        std::shared_ptr<brpc::Server> _rpc_server;
    };
}

--- FILE: 2.File_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 添加GDB调试支持
set(CMAKE_BUILD_TYPE Debug)
set(CMAKE_CXX_FLAGS_DEBUG "-g -O0")

# 1. 添加cmake版本说明
cmake_minimum_required(VERSION 3.1.3)
# 2. 声明工程名称
project(file_server)
set(CMAKE_CXX_STANDARD 17)

set(target "file_server")
set(test_client "file_client")

# 3. 检测并生成ODB框架代码
#   1. 添加所需的proto映射代码文件名称
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files file.proto base.proto)

set(proto_hxx "")
set(proto_cxx "")
set(proto_srcs "")

foreach(proto_file ${proto_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file}) # 将 ${proto_file}（即当前遍历到的 .proto 文件）的文件名中的 .proto 扩展名替换为 .pb.cc，并将结果存储在 proto_cc 变量中。
    string(REPLACE ".proto" ".pb.h" proto_hh  ${proto_file}) # .h文件自动生成
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc
            ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成Protobuf框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)
# 5. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs})
# 7. 设置需要连接的库
target_link_libraries(${target} -lpthread -lgflags -lspdlog -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl -ljsoncpp -ldl -lgtest)


set(test_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test test_files)
add_executable(${test_client} ${test_files} ${proto_srcs})
target_link_libraries(${test_client} -lpthread -lgflags -lspdlog -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl -ljsoncpp -ldl -lgtest)

# 8. 设置头文件默认搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../Third-party/aip-cpp-sdk-4.16.7)

# 9. 设置安装路径
INSTALL(TARGETS ${target} ${test_client} RUNTIME DESTINATION bin)

--- FILE: 2.File_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/file_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./file_server.conf /im/conf

COPY ./build/data /im/data

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/file_server -flagfile=/im/conf/file_server.conf

--- FILE: 2.File_Server/file_server.conf ---
内容:
-run_mode        = false                    # "程序的运行模式，false：调试，true：发布"
-log_file        = /im/logs/file_server.log # "发布模式下，用于指定日志的输出文件名"
-log_level       = 0                        # "发布模式下，日志等级和刷新时机"
-etcd_host       = http://127.0.0.1:2379   # "服务注册中心地址"
-base_service    = /service                 # "服务监控根目录"
-instance_name   = /file_service/instance   # "当前实例名称"
-access_host     = 127.0.0.1:10002         # "当前实例的外部访问地址(对外宣告的)"
-rpc_listen_port = 10002                    # "Rpc服务器监听端口(实际开放的)"
-rpc_timeout     = -1                       # "rpc调用超时时间
-rpc_threads     = 1                        # "rpc服务IO线程数量"
-storage_path    = /im/data                 # "上传的文件存放的位置"

--- FILE: 2.File_Server/test/file_client.cc ---
内容:
//编写一个file客户端程序，对文件存储子服务进行单元测试
// 1. 封装四个接口进行rpc调用，实现对于四个业务接口的测试
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <thread>
#include "etcd.hpp"
#include "rpc_service_manager.hpp"
#include "logger.hpp"
#include "file.pb.h"
#include "base.pb.h"
#include "utility.hpp"


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(file_service, "/service/file_service", "服务监控根目录");


chen_im::ChannelManager::ChannelPtr channel;
std::string single_file_id;

TEST(put_test, single_file) {
    //1. 读取当前目录下的指定文件数据
    std::string body;
    ASSERT_TRUE(chen_im::read_file("./Makefile", body));
    
    //2. 实例化rpc调用客户端对象，发起rpc调用
    chen_im::FileService_Stub stub(channel.get());

    chen_im::PutSingleFileReq req;
    req.set_request_id("1111");
    req.mutable_file_data()->set_file_name("Makefile");
    req.mutable_file_data()->set_file_size(body.size());
    req.mutable_file_data()->set_file_content(body);

    brpc::Controller *cntl = new brpc::Controller();
    chen_im::PutSingleFileRsp *rsp = new chen_im::PutSingleFileRsp();
    stub.PutSingleFile(cntl, &req, rsp, nullptr); // 真正开始调用
    ASSERT_FALSE(cntl->Failed());

    //3. 检测返回值中上传是否成功
    ASSERT_TRUE(rsp->success());
    ASSERT_EQ(rsp->file_info().file_size(), body.size());
    ASSERT_EQ(rsp->file_info().file_name(), "Makefile");
    single_file_id = rsp->file_info().file_id();
    LOG_DEBUG("文件ID：{}", rsp->file_info().file_id());
}

TEST(get_test, single_file) {
    //先发起Rpc调用，进行文件下载
    chen_im::FileService_Stub stub(channel.get());
    chen_im::GetSingleFileReq req;
    chen_im::GetSingleFileRsp *rsp;
    req.set_request_id("2222");
    req.set_file_id(single_file_id);

    brpc::Controller *cntl = new brpc::Controller();
    rsp = new chen_im::GetSingleFileRsp();
    stub.GetSingleFile(cntl, &req, rsp, nullptr);
    ASSERT_FALSE(cntl->Failed());
    ASSERT_TRUE(rsp->success());

    //将文件数据，存储到文件中
    ASSERT_EQ(single_file_id, rsp->file_data().file_id());
    chen_im::write_file("make_file_download", rsp->file_data().file_content());
}

std::vector<std::string> multi_file_id;

TEST(put_test, multi_file) {
    //1. 读取当前目录下的指定文件数据
    std::string body1;
    ASSERT_TRUE(chen_im::read_file("./base.pb.h", body1));
    std::string body2;
    ASSERT_TRUE(chen_im::read_file("./file.pb.h", body2));
    //2. 实例化rpc调用客户端对象，发起rpc调用
    chen_im::FileService_Stub stub(channel.get());

    chen_im::PutMultiFileReq req;
    req.set_request_id("3333");

    auto file_data = req.add_file_data();
    file_data->set_file_name("base.pb.h");
    file_data->set_file_size(body1.size());
    file_data->set_file_content(body1);

    file_data = req.add_file_data();
    file_data->set_file_name("file.pb.h");
    file_data->set_file_size(body2.size());
    file_data->set_file_content(body2);

    brpc::Controller *cntl = new brpc::Controller();
    chen_im::PutMultiFileRsp *rsp = new chen_im::PutMultiFileRsp();
    stub.PutMultiFile(cntl, &req, rsp, nullptr);
    ASSERT_FALSE(cntl->Failed());

    //3. 检测返回值中上传是否成功
    ASSERT_TRUE(rsp->success());
    for (int i = 0; i < rsp->file_info_size(); i++) {
        multi_file_id.push_back(rsp->file_info(i).file_id());
        LOG_DEBUG("文件ID：{}", multi_file_id[i]);
    }
}

TEST(get_test, multi_file) {
    //先发起Rpc调用，进行文件下载
    chen_im::FileService_Stub stub(channel.get());
    chen_im::GetMultiFileReq req;
    chen_im::GetMultiFileRsp *rsp;
    req.set_request_id("4444");
    req.add_file_id_list(multi_file_id[0]);
    req.add_file_id_list(multi_file_id[1]);

    brpc::Controller *cntl = new brpc::Controller();
    rsp = new chen_im::GetMultiFileRsp();
    stub.GetMultiFile(cntl, &req, rsp, nullptr);
    ASSERT_FALSE(cntl->Failed());
    ASSERT_TRUE(rsp->success());

    //将文件数据，存储到文件中
    ASSERT_TRUE(rsp->file_data().find(multi_file_id[0]) != rsp->file_data().end());
    ASSERT_TRUE(rsp->file_data().find(multi_file_id[1]) != rsp->file_data().end());
    auto map = rsp->file_data();
    auto file_data1 = map[multi_file_id[0]];
    chen_im::write_file("base_download_file1",file_data1.file_content());
    auto file_data2 = map[multi_file_id[1]];
    chen_im::write_file("file_download_file2", file_data2.file_content());
}


int main(int argc, char *argv[])
{
    testing::InitGoogleTest(&argc, argv);
    google::ParseCommandLineFlags(&argc, &argv, true);

    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    //1. 先构造Rpc信道管理对象
    auto service_manager = std::make_shared<chen_im::ServiceManager>();
    service_manager->concern(FLAGS_file_service);
    auto put_cb = std::bind(&chen_im::ServiceManager::when_service_online, service_manager.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&chen_im::ServiceManager::when_service_offline, service_manager.get(), std::placeholders::_1, std::placeholders::_2);
    
    //2. 构造服务发现对象
    std::shared_ptr<chen_im::Discovery> dclient = std::make_shared<chen_im::Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    
    //3. 通过Rpc信道管理对象，获取提供Echo服务的信道
    channel = service_manager->get(FLAGS_file_service);
    if (!channel) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        return -1;
    }

    int ret = RUN_ALL_TESTS();

    std::this_thread::sleep_for(std::chrono::seconds(600));
    return ret;
}

--- FILE: 2.File_Server/source/file_server.hpp ---
内容:
// 实现文件存储子服务
// 1. 实现文件rpc服务类 --- 实现rpc调用的业务处理接口
// 2. 实现文件存储子服务的服务器类
// 3. 实现文件存储子服务类的构造者
#include <brpc/server.h>
#include <butil/logging.h>

#include "etcd.hpp"   // 服务注册模块封装
#include "logger.hpp" // 日志模块封装
#include "utility.hpp"
#include "base.pb.h"
#include "file.pb.h"

namespace chen_im
{
    class FileServiceImpl : public chen_im::FileService
    {  
    private:
        std::string _storage_path;
    public:
        FileServiceImpl(const std::string &storage_path)
            : _storage_path(storage_path)
        {
            umask(0);
            mkdir(storage_path.c_str(), 0775);
            if (_storage_path.back() != '/')
                _storage_path.push_back('/');
        }
        ~FileServiceImpl() {}

        void GetSingleFile(google::protobuf::RpcController *controller,
                           const ::chen_im::GetSingleFileReq *request,
                           ::chen_im::GetSingleFileRsp *response,
                           ::google::protobuf::Closure *done)
        {
            LOG_INFO("用户 {} 请求获取单个文件...", request->user_id());

            brpc::ClosureGuard closure_guard(done);
            response->set_request_id(request->request_id());
            // 1. 取出请求中的文件ID（起始就是文件名）
            std::string fid = request->file_id();
            std::string filename = _storage_path + fid;
            // 2. 将文件ID作为文件名，读取文件数据
            std::string body;
            bool ret = read_file(filename, body);
            if (ret == false)
            {
                response->set_success(false);
                response->set_errmsg("读取文件数据失败！");
                LOG_ERROR("{} 读取文件数据失败！", request->request_id());
                return;
            }
            // 3. 组织响应
            response->set_success(true);
            response->mutable_file_data()->set_file_id(fid);
            response->mutable_file_data()->set_file_content(body);

            LOG_INFO("用户 {} 请求单个文件成功", request->user_id());
        }

        void GetMultiFile(google::protobuf::RpcController *controller,
                          const ::chen_im::GetMultiFileReq *request,
                          ::chen_im::GetMultiFileRsp *response,
                          ::google::protobuf::Closure *done)
        {
            LOG_INFO("用户 {} 请求获取多个文件...", request->user_id());

            brpc::ClosureGuard closure_guard(done);
            response->set_request_id(request->request_id());

            // 循环取出请求中的文件ID，读取文件数据进行填充
            for (int i = 0; i < request->file_id_list_size(); i++)
            {
                std::string fid = request->file_id_list(i);
                std::string filename = _storage_path + fid;
                std::string body;
                bool ret = read_file(filename, body);
                if (ret == false)
                {
                    response->set_success(false);
                    response->set_errmsg("读取文件数据失败！");
                    LOG_ERROR("{} 读取文件数据失败！", request->request_id());
                    return;
                }
                FileDownloadData data;
                data.set_file_id(fid);
                data.set_file_content(body);
                response->mutable_file_data()->insert({fid, data});
            }
            response->set_success(true);

            LOG_INFO("用户 {} 请求多个文件成功", request->user_id());
        }

        void PutSingleFile(google::protobuf::RpcController *controller,
                           const ::chen_im::PutSingleFileReq *request,
                           ::chen_im::PutSingleFileRsp *response,
                           ::google::protobuf::Closure *done)
        {
            LOG_INFO("用户 {} 上传单个文件...", request->user_id());

            brpc::ClosureGuard closure_guard(done);
            response->set_request_id(request->request_id());

            // 1. 为文件生成一个唯一uudi作为文件名 以及 文件ID
            std::string fid = generate_uuid();
            std::string filename = _storage_path + fid;

            // 2. 取出请求中的文件数据，进行文件数据写入
            bool ret = write_file(filename, request->file_data().file_content());
            if (ret == false)
            {
                response->set_success(false);
                response->set_errmsg("读取文件数据失败！");
                LOG_ERROR("{} 写入文件数据失败！", request->request_id());
                return;
            }
            
            // 3. 组织响应
            response->set_success(true);
            response->mutable_file_info()->set_file_id(fid);
            response->mutable_file_info()->set_file_size(request->file_data().file_size());
            response->mutable_file_info()->set_file_name(request->file_data().file_name());

            LOG_INFO("用户 {} 上传单个文件成功", request->user_id());
        }

        void PutMultiFile(google::protobuf::RpcController *controller,
                          const ::chen_im::PutMultiFileReq *request,
                          ::chen_im::PutMultiFileRsp *response,
                          ::google::protobuf::Closure *done)
        {
            LOG_INFO("用户 {} 上传多个文件...", request->user_id());

            brpc::ClosureGuard closure_guard(done);
            response->set_request_id(request->request_id());
            for (int i = 0; i < request->file_data_size(); i++)
            {
                std::string fid = generate_uuid();
                std::string filename = _storage_path + fid;
                bool ret = write_file(filename, request->file_data(i).file_content());
                if (ret == false)
                {
                    response->set_success(false);
                    response->set_errmsg("读取文件数据失败！");
                    LOG_ERROR("{} 写入文件数据失败！", request->request_id());
                    return;
                }
                chen_im::FileMessageInfo *info = response->add_file_info();
                info->set_file_id(fid);
                info->set_file_size(request->file_data(i).file_size());
                info->set_file_name(request->file_data(i).file_name());
            }
            response->set_success(true);

            LOG_INFO("用户 {} 上传单个文件成功", request->user_id());
        }

    };

    class FileServer
    {
    private:
        std::shared_ptr<Registry> _registry_client;
        std::shared_ptr<brpc::Server> _brpc_server;
    public:
        FileServer(const std::shared_ptr<Registry>     &reg_client,
                   const std::shared_ptr<brpc::Server> &server     )
            :_registry_client(reg_client)
            , _brpc_server(server) 
        {}

        ~FileServer() {}

        // 搭建RPC服务器，并启动服务器
        void run()
        {
            _brpc_server->RunUntilAskedToQuit();
        }
    };

    class FileServerFactory
    {
    public:
        // 用于构造服务注册客户端对象
        void build_registry_client(const std::string &reg_host,
                                   const std::string &service_name,
                                   const std::string &access_host)
        {
            _registry_client = std::make_shared<Registry>(reg_host);
            _registry_client->registry(service_name, access_host);
        }
        // 构造RPC服务器对象
        void build_brpc_server(uint16_t port, int32_t timeout,
                             uint8_t num_threads, const std::string &path = "./data/")
        {
            _brpc_server = std::make_shared<brpc::Server>();
            FileServiceImpl *file_service = new FileServiceImpl(path);
            int ret = _brpc_server->AddService(file_service,
                                              brpc::ServiceOwnership::SERVER_OWNS_SERVICE);
            if (ret == -1) {
                LOG_ERROR("添加Rpc服务失败！");
                abort();
            }
            brpc::ServerOptions options;
            options.idle_timeout_sec = timeout;
            options.num_threads = num_threads;
            ret = _brpc_server->Start(port, &options);
            if (ret == -1) {
                LOG_ERROR("brpc服务器启动失败！");
                abort();
            }
        }
        std::shared_ptr<FileServer> build()
        {
            if (!_registry_client) {
                LOG_ERROR("还未初始化注册中心客户端模块！");
                abort();
            }

            if (!_brpc_server) {
                LOG_ERROR("还未初始化RPC服务器模块！");
                abort();
            }
            std::shared_ptr<FileServer> server = std::make_shared<FileServer>(_registry_client, _brpc_server);
            return server;
        }

    private:
        std::shared_ptr<Registry> _registry_client;
        std::shared_ptr<brpc::Server> _brpc_server;
    };
}

--- FILE: 2.File_Server/source/file_server.cc ---
内容:
//按照流程完成服务器的搭建
//1. 参数解析
//2. 日志初始化
//3. 构造服务器对象，启动服务器
#include "file_server.hpp"


// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");

// etcd
DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(instance_name, "/file_service/instance1", "当前实例名称");

// 宣告的和实际开放的端口理应一致
DEFINE_string(access_host, "127.0.0.1:10002", "当前实例的外部访问地址(对外宣告的)"); // TODO：试一下公网和内网IP
DEFINE_uint32(rpc_listen_port, 10002, "Rpc服务器监听端口(实际开放的)");

// brpc
DEFINE_int32(rpc_timeout, -1, "rpc调用超时时间");
DEFINE_int32(rpc_threads, 1, "rpc服务IO线程数量");

// 存储
DEFINE_string(storage_path, "./data/", "上传的文件存放的位置");

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    chen_im::FileServerFactory file_server_factory;
    file_server_factory.build_brpc_server(FLAGS_rpc_listen_port, FLAGS_rpc_timeout, FLAGS_rpc_threads, FLAGS_storage_path);
    file_server_factory.build_registry_client(FLAGS_etcd_host, FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);
    auto file_server = file_server_factory.build();
    
    file_server->run();
    return 0;
}

--- FILE: Configs/message_store_server.conf ---
内容:
-run_mode           = false                              # 程序的运行模式，false-调试； true-发布；
-log_file           = /im/logs/message_store_server.log  # 发布模式下，用于指定日志的输出文件
-log_level          = 0                                  # 发布模式下，用于指定日志输出等级
-registry_host      = http://127.0.0.1:2379           # 服务注册中心地址
-instance_name      = /message_store_service/instance1 # 当前实例名称
-access_host        = 127.0.0.1:10005                  # 当前实例的外部访问地址
-listen_port        = 10005                              # Rpc服务器监听端口
-rpc_timeout        = -1                                 # Rpc调用超时时间
-rpc_threads        = 1                                  # Rpc的IO线程数量
-base_service       = /service                         # 服务监控根目录
-file_service       = /service/file_service            # 文件管理子服务名称
-user_service       = /service/user_service            # 用户管理子服务名称
-es_host            = http://127.0.0.1:9200/           # ES搜索引擎服务器URL
-mysql_host         = 127.0.0.1                        # Mysql服务器访问地址
-mysql_user         = root                             # Mysql服务器访问用户名
-mysql_pswd         = Cydia4384!                       # Mysql服务器访问密码
-mysql_db           = root_im                          # Mysql默认库名称
-mysql_cset         = utf8                             # Mysql客户端字符集
-mysql_access_port  = 0                                  # Mysql服务器访问端口
-mysql_pool_count   = 4                                  # Mysql连接池最大连接数量
-mq_user            = root                             # 消息队列服务器访问用户名
-mq_pswd            = czhuowen                         # 消息队列服务器访问密码
-mq_host            = 127.0.0.1:5672                   # 消息队列服务器访问地址
-mq_msg_exchange    = msg_exchange                     # 持久化消息的发布交换机名称
-mq_msg_queue       = msg_queue                        # 持久化消息的发布队列名称
-mq_msg_binding_key = msg_queue                        # 持久化消息的发布队列名称

--- FILE: Configs/speech_server.conf ---
内容:
-run_mode        = false                            # 程序的运行模式，false：调试，true：发布
-log_file        = /im/logs/speech_server.log                         # 发布模式下，用于指定日志的输出文件名
-log_level       = 0                                # 发布模式下，日志等级和刷新时机
-etcd_host       = http://127.0.0.1:2379            # 服务注册中心地址
-base_service    = /service                         # 服务监控根目录
-instance_name   = /speech/recognition/instance   # 当前实例名称
-access_host     = 127.0.0.1:10001                  # 当前实例的外部访问地址(对外宣告的)
-rpc_listen_port = 10001                            # Rpc服务器监听端口(实际开放的)
-rpc_timeout     = -1                               # rpc调用超时时间
-rpc_threads     = 1                                # rpc服务IO线程数量
-app_id          = 115536313                        # 语音平台应用ID
-api_key         = uxPdTPAgRAZWoV16moQbIt1k         # 语音平台API密钥
-secret_key      = Hg2prK8pIPxMGYWwJ97ULVd6wzUTgWkb # 语音平台加密密钥

--- FILE: Configs/user_server.conf ---
内容:
-run_mode          = false                          # 程序的运行模式，false-调试； true-发布；
-log_file          = /im/logs/user_server.log       # 发布模式下，用于指定日志的输出文件
-log_level         = 0                              # 发布模式下，用于指定日志输出等级
-registry_host     = http://127.0.0.1:2379          # 服务注册中心地址
-instance_name     = /user_service/instance1        # 当前实例名称
-access_host       = 127.0.0.1:10003                # 当前实例的外部访问地址
-listen_port       = 10003                          # Rpc服务器监听端口
-rpc_timeout       = -1                             # Rpc调用超时时间
-rpc_threads       = 1                              # Rpc的IO线程数量
-base_service      = /service                       # 服务监控根目录
-file_service      = /service/file_service          # 文件管理子服务名称
-es_host           = http://127.0.0.1:9200/         # ES搜索引擎服务器URL
-mysql_host        = 127.0.0.1                      # Mysql服务器访问地址
-mysql_user        = root                           # Mysql服务器访问用户名
-mysql_pswd        = Cydia4384!                     # Mysql服务器访问密码
-mysql_db          = root_im                        # Mysql默认库名称
-mysql_cset        = utf8                           # Mysql客户端字符集
-mysql_access_port = 0                              # Mysql服务器访问端口
-mysql_pool_count  = 4                              # Mysql连接池最大连接数量
-redis_host        = 127.0.0.1                      # Redis服务器访问地址
-redis_port        = 6379                           # Redis服务器访问端口
-redis_db          = 0                              # Redis默认库号
-redis_keep_alive  = true                           # Redis长连接保活选项
-dms_key_id        = LTAI5t6g1JUbGQR8UQTRuJ2J       # 短信平台密钥ID
-dms_key_secret    = 0wNotLkLPyv581BHDTAFZoeCbZrgit # 短信平台密钥

--- FILE: Configs/message_transmit_server.conf ---
内容:
-run_mode            = false                              # 程序的运行模式，false-调试； true-发布；
-log_file            = /im/logs/message_transmit_server.log    # 发布模式下，用于指定日志的输出文件
-log_level           = 0                                  # 发布模式下，用于指定日志输出等级
-registry_host       = http://127.0.0.1:2379              # 服务注册中心地址
-instance_name       = /message_transmit_service/instance # 当前实例名称
-access_host         = 127.0.0.1:10004                    # 当前实例的外部访问地址
-listen_port         = 10004                              # Rpc服务器监听端口
-rpc_timeout         = -1                                 # Rpc调用超时时间
-rpc_threads         = 1                                  # Rpc的IO线程数量
-base_service        = /service                           # 服务监控根目录
-user_service        = /service/user_service              # 用户管理子服务名称
-mysql_host          = 127.0.0.1                          # Mysql服务器访问地址
-mysql_user          = root                               # Mysql服务器访问用户名
-mysql_pswd          = Cydia4384!                         # Mysql服务器访问密码
-mysql_db            = root_im                            # Mysql默认库名称
-mysql_cset          = utf8                               # Mysql客户端字符集
-mysql_access_port   = 0                                  # Mysql服务器访问端口
-mysql_pool_count    = 4                                  # Mysql连接池最大连接数量
-mq_user             = root                               # 消息队列服务器访问用户名
-mq_pswd             = czhuowen                           # 消息队列服务器访问密码
-mq_host             = 127.0.0.1:5672                     # 消息队列服务器访问地址
-mq_msg_exchange     = msg_exchange                       # 持久化消息的发布交换机名称
-mq_msg_queue        = msg_queue                          # 持久化消息的发布队列名称
-mq_msg_binding_key  = msg_queue                          # 持久化消息的发布队列名称

--- FILE: Configs/gateway_server.conf ---
内容:
-run_mode                 = false                                # 程序的运行模式，false-调试； true-发布；
-log_file                 = /im/logs/gateway_server.log          # 发布模式下，用于指定日志的输出文件
-log_level                = 0                                    # 发布模式下，用于指定日志输出等级
-http_listen_port         = 9000                                 # HTTP服务器监听端口
-websocket_listen_port    = 9001                                 # Websocket服务器监听端口
-registry_host            = http://127.0.0.1:2379               # 服务注册中心地址
-base_service             = /service                             # 服务监控根目录
-file_service             = /service/file_service                # 文件存储子服务名称
-friend_service           = /service/friend_service              # 好友管理子服务名称
-message_store_service    = /service/message_store_service       # 消息存储子服务名称
-user_service             = /service/user_service                # 用户管理子服务名称
-speech_service           = /service/speech/recognition          # 语音识别子服务名称
-message_transmit_service = /service/message_transmit_service    # 转发管理子服务名称
-redis_host               = 127.0.0.1                           # Redis服务器访问地址
-redis_port               = 6379                                 # Redis服务器访问端口
-redis_db                 = 0                                    # Redis默认库号
-redis_keep_alive         = true                                 # Redis长连接保活选项

--- FILE: Configs/friend_server.conf ---
内容:
-run_mode              = false                          # 程序的运行模式，false-调试； true-发布；
-log_file              = /im/logs/friend_server.log     # 发布模式下，用于指定日志的输出文件
-log_level             = 0                              # 发布模式下，用于指定日志输出等级
-registry_host         = http://127.0.0.1:2379         # 服务注册中心地址
-instance_name         = /friend_service/instance       # 当前实例名称
-access_host           = 127.0.0.1:10006               # 当前实例的外部访问地址
-listen_port           = 10006                          # Rpc服务器监听端口
-rpc_timeout           = -1                             # Rpc调用超时时间
-rpc_threads           = 1                              # Rpc的IO线程数量"
-base_service          = /service                       # 服务监控根目录
-user_service          = /service/user_service          # 用户管理子服务名称
-message_store_service = /service/message_store_service # 消息存储子服务名称
-es_host               = http://127.0.0.1:9200/        # ES搜索引擎服务器URL
-mysql_host            = 127.0.0.1                     # Mysql服务器访问地址
-mysql_user            = root                           # Mysql服务器访问用户名
-mysql_pswd            = Cydia4384!                     # Mysql服务器访问密码
-mysql_db              = root_im                        # Mysql默认库名称
-mysql_cset            = utf8                           # Mysql客户端字符集
-mysql_access_port     = 0                              # Mysql服务器访问端口
-mysql_pool_count      = 4                              # Mysql连接池最大连接数量

--- FILE: Configs/file_server.conf ---
内容:
-run_mode        = false                    # "程序的运行模式，false：调试，true：发布"
-log_file        = /im/logs/file_server.log # "发布模式下，用于指定日志的输出文件名"
-log_level       = 0                        # "发布模式下，日志等级和刷新时机"
-etcd_host       = http://127.0.0.1:2379   # "服务注册中心地址"
-base_service    = /service                 # "服务监控根目录"
-instance_name   = /file_service/instance   # "当前实例名称"
-access_host     = 127.0.0.1:10002         # "当前实例的外部访问地址(对外宣告的)"
-rpc_listen_port = 10002                    # "Rpc服务器监听端口(实际开放的)"
-rpc_timeout     = -1                       # "rpc调用超时时间
-rpc_threads     = 1                        # "rpc服务IO线程数量"
-storage_path    = /im/data                 # "上传的文件存放的位置"

--- FILE: 1.Speech_Server/speech_server.conf ---
内容:
-run_mode        = false                            # 程序的运行模式，false：调试，true：发布
-log_file        = /im/logs/speech_server.log                         # 发布模式下，用于指定日志的输出文件名
-log_level       = 0                                # 发布模式下，日志等级和刷新时机
-etcd_host       = http://127.0.0.1:2379            # 服务注册中心地址
-base_service    = /service                         # 服务监控根目录
-instance_name   = /speech/recognition/instance   # 当前实例名称
-access_host     = 127.0.0.1:10001                  # 当前实例的外部访问地址(对外宣告的)
-rpc_listen_port = 10001                            # Rpc服务器监听端口(实际开放的)
-rpc_timeout     = -1                               # rpc调用超时时间
-rpc_threads     = 1                                # rpc服务IO线程数量
-app_id          = 115536313                        # 语音平台应用ID
-api_key         = uxPdTPAgRAZWoV16moQbIt1k         # 语音平台API密钥
-secret_key      = Hg2prK8pIPxMGYWwJ97ULVd6wzUTgWkb # 语音平台加密密钥

--- FILE: 1.Speech_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 添加GDB调试支持
set(CMAKE_BUILD_TYPE Debug)
set(CMAKE_CXX_FLAGS_DEBUG "-g -O0")

# 1. 添加cmake版本说明
cmake_minimum_required(VERSION 3.1.3)
# 2. 声明工程名称
project(speech_server)
set(CMAKE_CXX_STANDARD 17)

set(target "speech_server")
set(test_client "speech_client")

# 3. 检测并生成ODB框架代码
#   1. 添加所需的proto映射代码文件名称
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files speech_recognition.proto)

set(proto_hxx "")
set(proto_cxx "")
set(proto_srcs "")

foreach(proto_file ${proto_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file}) # 将 ${proto_file}（即当前遍历到的 .proto 文件）的文件名中的 .proto 扩展名替换为 .pb.cc，并将结果存储在 proto_cc 变量中。
    string(REPLACE ".proto" ".pb.h" proto_hh  ${proto_file}) # .h文件自动生成
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc
            ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成Protobuf框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)
# 5. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs})
# 7. 设置需要连接的库
target_link_libraries(${target} -lpthread -lgflags -lspdlog -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl -ljsoncpp -ldl)


set(test_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test test_files)
add_executable(${test_client} ${test_files} ${proto_srcs})
target_link_libraries(${test_client} -lpthread -lgflags -lspdlog -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl -ljsoncpp -ldl)

# 8. 设置头文件默认搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../Third-party/aip-cpp-sdk-4.16.7)

# 9. 设置安装路径
INSTALL(TARGETS ${target} ${test_client} RUNTIME DESTINATION bin)

--- FILE: 1.Speech_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/speech_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./speech_server.conf /im/conf/

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/speech_server -flagfile=/im/conf/speech_server.conf

--- FILE: 1.Speech_Server/test/16k.pcm ---
内容:
【无法读取文件内容，可能是二进制文件或编码问题：'utf-8' codec can't decode byte 0xb2 in position 0: invalid start byte】

--- FILE: 1.Speech_Server/test/speech_client.cc ---
内容:
// 用于测试speech_server的客户端:
//   关心想关心的服务，并调用rpc服务
#include "etcd.hpp"
#include "logger.hpp"
#include "rpc_service_manager.hpp"  
#include "voice_recognizer.hpp"
#include "speech_recognition.pb.h"
#include "speech.h"
#include <gflags/gflags.h>
#include <functional>

// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");

// etcd
DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(service_to_call, "/service/speech/recognition", "服务监控根目录");


int main(int argc, char *argv[])
{
    using namespace chen_im;

    google::ParseCommandLineFlags(&argc, &argv, true); // 解析命令行参数
    init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level); // 初始化日志器

    // 1. 先构造Rpc信道管理对象，并关心语音服务
    auto service_manager = std::make_shared<ServiceManager>();
    service_manager->concern(FLAGS_service_to_call);

    // 2. 构造服务发现对象, 先定义新增和删除时的回调
    auto put_cb = std::bind(&ServiceManager::when_service_online, service_manager.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&ServiceManager::when_service_offline, service_manager.get(), std::placeholders::_1, std::placeholders::_2);
    std::shared_ptr<Discovery> discovery_client = std::make_shared<Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    
    // 3. 通过Rpc信道管理对象，获取提供语音服务的信道
    auto channel = service_manager->get(FLAGS_service_to_call);
    if (!channel) {
        LOG_ERROR("获取 {} 的brpc服务信道失败，retry...", FLAGS_service_to_call);
        abort();
    }

    // 4. 加载语音文件
    std::string file_content;
    aip::get_file_content("../test/16k.pcm", &file_content);

    // 5. 发起Echo方法的rpc调用(同步调用)
    chen_im::SpeechService_Stub stub(channel.get());

    chen_im::SpeechRecognitionReq req;
    req.set_speech_content(file_content);
    req.set_request_id("111111");
    LOG_DEBUG("发送的语音文件大小：{}", file_content.size());


    auto ctrl = new brpc::Controller;
    ctrl->set_timeout_ms(10000);
    auto resp = new chen_im::SpeechRecognitionRsp;
    stub.SpeechRecognition(ctrl, &req, resp, nullptr); // 这是真正的调用


    if (ctrl->Failed() == true) {
        LOG_ERROR("Rpc调用失败：{}", ctrl->ErrorText());
        delete ctrl;
        delete resp;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        return -1;
    }
    if (resp->success() == false) {
        LOG_ERROR("语音识别失败：{}", resp->errmsg());
        return -1;
    }
    LOG_DEBUG("响应id: {}", resp->request_id());
    LOG_DEBUG("响应内容: {}", resp->recognition_result());
    

    std::this_thread::sleep_for(std::chrono::seconds(600));
    return 0;
}


--- FILE: 1.Speech_Server/source/speach_server.cc ---
内容:
#include "voice_recognizer.hpp"  // 语音识别的封装
#include "etcd.hpp"              // 服务注册封装
#include "logger.hpp"            // 日志封装
#include "speach_server.hpp"
#include "speech_recognition.pb.h"     // protobuf框架代码

#include <brpc/server.h>
#include <gflags/gflags.h>
#include <butil/logging.h>
#include <thread>

// log
DEFINE_bool(run_mode, false, "程序的运行模式，false：调试，true：发布");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件名");
DEFINE_int32(log_level, spdlog::level::level_enum::trace, "发布模式下，日志等级和刷新时机");

// etcd
DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(instance_name, "/speech/recognition/instance_1", "当前实例名称");

// 宣告的和实际开放的端口理应一致
DEFINE_string(access_host, "127.0.0.1:10001", "当前实例的外部访问地址(对外宣告的)"); // TODO：试一下公网和内网IP
DEFINE_uint32(rpc_listen_port, 10001, "Rpc服务器监听端口(实际开放的)");

// brpc
DEFINE_int32(rpc_timeout, -1, "rpc调用超时时间");
DEFINE_int32(rpc_threads, 1, "rpc服务IO线程数量");

// 语音平台
DEFINE_string(app_id, "115536313", "语音平台应用ID");
DEFINE_string(api_key, "uxPdTPAgRAZWoV16moQbIt1k", "语音平台API密钥");
DEFINE_string(secret_key, "Hg2prK8pIPxMGYWwJ97ULVd6wzUTgWkb", "语音平台加密密钥");



int main(int argc,char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode,  FLAGS_log_file,  FLAGS_log_level);

    // 构造SpeechServer
    chen_im::SpeechServerFactory ssf_factory;
    ssf_factory.build_voice_client(FLAGS_app_id, FLAGS_api_key, FLAGS_secret_key);
    ssf_factory.build_brpc_server(FLAGS_rpc_listen_port, FLAGS_rpc_timeout, FLAGS_rpc_threads);
    ssf_factory.build_registry_client(FLAGS_etcd_host, FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);


    std::shared_ptr<chen_im::SpeechServer> speech_server = ssf_factory.build();
    
    speech_server->run();
    return 0;
}


--- FILE: 1.Speech_Server/source/speach_server.hpp ---
内容:
// 实现语音识别子服务
#pragma once
#include "voice_recognizer.hpp"        // 语音识别的封装
#include "etcd.hpp"                    // 服务注册封装
#include "logger.hpp"                  // 日志封装
#include "speech_recognition.pb.h"     // protobuf框架代码

#include <brpc/server.h>

// 1. 创建子类，继承于SpeechService创建一个子类，并实现rpc调用
namespace chen_im
{
    class SpeechServiceImpl : public chen_im::SpeechService // implement 执行 v.
    {
    private:
        std::shared_ptr<VoiceRecognizerClient> _voice_client;
    public:
        SpeechServiceImpl(std::shared_ptr<VoiceRecognizerClient> &voice_client)
            :_voice_client(voice_client)
        {}
        ~SpeechServiceImpl() {}
        virtual void SpeechRecognition(::google::protobuf::RpcController* controller,
                       const ::chen_im::SpeechRecognitionReq* request,
                       ::chen_im::SpeechRecognitionRsp* response,
                       ::google::protobuf::Closure* done) override
        {
            LOG_INFO("收到user_id {} 的语音识别请求!", request->user_id());
            // 把Closure指针管理起来
            brpc::ClosureGuard closure_guard(done);

            // 处理业务
            // 1. 取出请求中的语音数据
            std::string data = request->speech_content();

            // 2. 调用sdk，进行语音转文字，得到文字响应
            std::string res = _voice_client->recognize(data);

            // 3. 组织响应
            if (res.empty()) {
                LOG_ERROR("语音识别失败, request_id:{}", request->request_id());
                response->set_request_id(request->request_id());
                response->set_success(false);
                response->set_errmsg("语音识别失败了");
                return;
            } else {
                LOG_INFO("语音识别成功, result:{}, request_id:{}, user_id: {}", res, request->request_id(), request->user_id());
                response->set_request_id(request->request_id());
                response->set_success(true);
                response->set_recognition_result(res);
                return;
            }

        }
    };


    // 语言识别服务器
    class SpeechServer
    {
    private:
        // 三种身份
        std::shared_ptr<VoiceRecognizerClient> _voice_client;    // 作为一个百度语音识别服务的客户端
        std::shared_ptr<Registry>              _registry_client; // 作为注册中心的客户端
        std::shared_ptr<brpc::Server>          _brpc_server;     // 作为一个brpc服务器
    public:
        SpeechServer(const std::shared_ptr<VoiceRecognizerClient> &voice_client,   
                     const std::shared_ptr<Registry>              &registry_client, 
                     const std::shared_ptr<brpc::Server>          &brpc_server)
            :_voice_client(voice_client)
            , _registry_client(registry_client)
            , _brpc_server(brpc_server)
        {}

        ~SpeechServer() {}

        // 启动服务，就是在启动brpc服务器
        void run()
        {
            // 等待运行结束
            _brpc_server->RunUntilAskedToQuit();
        }
    };

    // SpeechServer的工厂类
    class SpeechServerFactory
    {
    private:
        std::shared_ptr<VoiceRecognizerClient> _voice_client;    // 作为一个语音识别客户端
        std::shared_ptr<Registry>              _registry_client; // 作为注册中心的客户端
        std::shared_ptr<brpc::Server>          _brpc_server;     // 作为一个brpc服务器
    public:
        // 构造一个SpeechServer智能指针
        std::shared_ptr<SpeechServer> build()
        {
            if (!_voice_client) {
                LOG_ERROR("未初始化语音服务器！");
                abort();
            }
            if (!_registry_client) {
                LOG_ERROR("未初始化注册中心客户端！");
                abort();
            }
            if (!_brpc_server) {
                LOG_ERROR("未初始化brpc服务器！");
                abort();
            }

            std::shared_ptr<SpeechServer> ret_ptr = std::make_shared<SpeechServer>(_voice_client, _registry_client, _brpc_server);
            return ret_ptr;
        }

        // 构造语音识别客户端
        void build_voice_client(const std::string &app_id, 
                                const std::string &api_key, 
                                const std::string &secret_key) 
        {
            _voice_client = std::make_shared<VoiceRecognizerClient>(app_id, api_key, secret_key);
        }

        
        /// @brief 构造注册中心的客户端
        /// @param etcd_host etcd服务器的地址
        /// @param access_host 键值对中的value，即本语音服务器实际提供服务的地址
        void build_registry_client(const std::string &etcd_host, 
                                   const std::string &service_name, 
                                   const std::string &access_host)
        {
            _registry_client = std::make_shared<Registry>(etcd_host);
            _registry_client->registry(service_name, access_host);
        }

        /// @brief 构造brpc服务器
        /// @param timeout_sec 连接空闲超时事件，超时后连接被关闭
        /// @param num_threads io线程数量
        /// @param port brpc服务的端口号
        void build_brpc_server(uint16_t port, int timeout_sec, int num_threads)
        {
            _brpc_server = std::make_shared<brpc::Server>();
            auto speach_service = new chen_im::SpeechServiceImpl(_voice_client);
            int ret = _brpc_server->AddService(speach_service, brpc::ServiceOwnership::SERVER_OWNS_SERVICE); // service应当被server管理起来
            if(ret == -1) {
                LOG_ERROR("向brpc中添加服务失败!");
                abort();
            }

            // 配置brpc的选项
            brpc::ServerOptions options;
            options.idle_timeout_sec = timeout_sec; 
            options.num_threads = num_threads;

            // 启动brpc服务 
            ret = _brpc_server->Start(port, &options);
            if(ret == -1) {
                LOG_ERROR("brpc服务启动失败!");
                abort();
            }
        }

        SpeechServerFactory() {}
        ~SpeechServerFactory() {}
    };

};





--- FILE: 7.Gateway_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 1. 添加cmake版本说明
cmake_minimum_required(VERSION 3.1.3)
# 2. 声明工程名称
project(gateway_server)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

set(target "gateway_server")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# 3. 检测并生成ODB框架代码
#   1. 添加所需的proto映射代码文件名称
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files base.proto user.proto file.proto friend.proto gateway.proto message_storage.proto notify.proto speech_recognition.proto message_transmit.proto )
#   2. 检测框架代码文件是否已经生成
set(proto_hxx "")
set(proto_cxx "")
set(proto_srcs "")
foreach(proto_file ${proto_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file})
    string(REPLACE ".proto" ".pb.h" proto_hh  ${proto_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc
            ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成Protobuf框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)
# 5. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs} ${odb_srcs})
# 7. 设置需要连接的库
target_link_libraries(${target} -lgflags 
    -lspdlog -lfmt -lbrpc -lssl -lcrypto 
    -lprotobuf -lleveldb -letcd-cpp-api 
    -lodb-mysql -lodb -lodb-boost
    -lhiredis -lredis++
    -lcpprest -lcurl
    -lpthread -lboost_system -lpthread -ldl)


# 6. 设置头文件默认搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Third-party)

#8. 设置安装路径
INSTALL(TARGETS ${target} RUNTIME DESTINATION bin)

--- FILE: 7.Gateway_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/gateway_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./gateway_server.conf /im/conf

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/gateway_server -flagfile=/im/conf/gateway_server.conf

--- FILE: 7.Gateway_Server/gateway_server.conf ---
内容:
-run_mode                 = false                                # 程序的运行模式，false-调试； true-发布；
-log_file                 = /im/logs/gateway_server.log          # 发布模式下，用于指定日志的输出文件
-log_level                = 0                                    # 发布模式下，用于指定日志输出等级
-http_listen_port         = 9000                                 # HTTP服务器监听端口
-websocket_listen_port    = 9001                                 # Websocket服务器监听端口
-registry_host            = http://127.0.0.1:2379               # 服务注册中心地址
-base_service             = /service                             # 服务监控根目录
-file_service             = /service/file_service                # 文件存储子服务名称
-friend_service           = /service/friend_service              # 好友管理子服务名称
-message_store_service    = /service/message_store_service       # 消息存储子服务名称
-user_service             = /service/user_service                # 用户管理子服务名称
-speech_service           = /service/speech/recognition          # 语音识别子服务名称
-message_transmit_service = /service/message_transmit_service    # 转发管理子服务名称
-redis_host               = 127.0.0.1                           # Redis服务器访问地址
-redis_port               = 6379                                 # Redis服务器访问端口
-redis_db                 = 0                                    # Redis默认库号
-redis_keep_alive         = true                                 # Redis长连接保活选项

--- FILE: 7.Gateway_Server/source/connection.hpp ---
内容:
// redis中存放了两种信息，一个是用户是否登录，直接存key（user_id）
// 第二个是<session_id, user_id>，这个是用来通过会话id找到用户id的，客户端是通过session_id来隐式地告知服务器自己的身份的
// 但是上面这种情况是在知道websocket长连接信息的情况下，通过解析报文中的session_id内容，来得知发送者的消息
// 解决了消息怎么来，还要解决消息往哪里去
// 因此需要实现：通过用户ID能够找到这个用户客户端的websocket长连接，以便推送消息

// 实现：
//   1. 管理 <用户id, 长连接> 键值对
//   2. 在断开连接的时候，将 <user_id>、<session_id, user_id> 这两组键值对清理（只是清理Connection对象中的键值对）
//   （长连接创建的时候，在用户子服务的用户登录逻辑中，已经将这两个键值对写入redis了
//     长连接销毁的时候，在websocket的连接关闭回调onClose中，实现了清理这两个键值对的缓存）

// 接口：
//   1. 新增数据
//   2. 通过用户id获取对应的websocket长连接
//   3. 通过长连接获取用户id和会话id
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/server.hpp>
#include "logger.hpp"

namespace chen_im
{
    typedef websocketpp::server<websocketpp::config::asio> websocket_server_t;
    // websocket的长连接类型： server_t::connection_ptr
    
    // 实现websocket连接管理
    class Connection
    {    
    public:        
        using ptr = std::shared_ptr<Connection>;

        struct Client
        {
            Client(const std::string &u, const std::string &s) : uid(u), ssid(s) {}
            std::string uid;  // 用户id
            std::string ssid; // 会话id
        };

        Connection() {}
        ~Connection() {}

        // 添加一个 <websocket连接、用户id、会话id> 的管理
        void insert(const websocket_server_t::connection_ptr &conn,
                    const std::string &uid, const std::string &ssid)
        {
            std::unique_lock<std::mutex> lock(_mutex);
            _uid_to_connection.insert(std::make_pair(uid, conn));
            _connection_to_client.insert(std::make_pair(conn, Client(uid, ssid)));
            LOG_DEBUG("新增长连接用户信息，长连接句柄：{}，用户id：{}，会话id：{}", (size_t)conn.get(), uid, ssid);
        }

        
        /// @brief 通过用户id获取其对应的websocket长连接对象
        /// @param uid 用户id
        /// @return websocket长连接对象
        websocket_server_t::connection_ptr get_connection(const std::string &uid)
        {
            std::unique_lock<std::mutex> lock(_mutex);
            auto it = _uid_to_connection.find(uid);
            if (it == _uid_to_connection.end()) {
                LOG_ERROR("未找到用户id为 {} 的客户端的长连接！", uid);
                return websocket_server_t::connection_ptr();
            }
            LOG_DEBUG("已找到用户id为 {} 的客户端的长连接！", uid);
            return it->second;
        }

        /// @brief 通过websocket长连接对象获取用户的user_id、session_id
        /// @param conn 长连接对象
        /// @param uid 用户id（输出型）
        /// @param ssid 会话id（输出型）
        /// @return 是否成功
        bool get_client_info(const websocket_server_t::connection_ptr &conn, std::string &uid, std::string &ssid)
        {
            std::unique_lock<std::mutex> lock(_mutex);
            auto it = _connection_to_client.find(conn);
            if (it == _connection_to_client.end())
            {
                LOG_ERROR("获取长连接对应客户端信息时，未能找到长连接 {} 对应的客户端信息！", (size_t)conn.get());
                return false;
            }
            uid = it->second.uid;
            ssid = it->second.ssid;
            LOG_DEBUG("获取长连接客户端信息成功！");
            return true;
        }

        // 删除 <websocket连接、用户id、会话id>
        void remove_connection(const websocket_server_t::connection_ptr &conn)
        {
            std::unique_lock<std::mutex> lock(_mutex);
            auto it = _connection_to_client.find(conn);
            if (it == _connection_to_client.end())
            {
                LOG_ERROR("删除-未找到长连接 {} 对应的客户端信息！", (size_t)conn.get());
                return;
            }
            _uid_to_connection.erase(it->second.uid);
            _connection_to_client.erase(it);
            LOG_DEBUG("删除长连接信息完毕！");
        }

    private:
        std::mutex _mutex;
        std::unordered_map<std::string, websocket_server_t::connection_ptr> _uid_to_connection;
        std::unordered_map<websocket_server_t::connection_ptr, Client> _connection_to_client;
    };
}

--- FILE: 7.Gateway_Server/source/gateway_server.hpp ---
内容:
// 网关服务器不本身不直接提供业务处理流程，负责接收客户端请求，然后转发给6个子服务处理业务
// 1. 有些业务是不需要响应给客户端的
// 2. 有些业务是需要网关服务器处理完请求后转发给某个或某些客户端的：
//      好友申请请求、好友申请处理流程、好友删除、会话创建、产生新消息

// 两个问题是如何解决的：
// 1. 鉴权：当客户端登录成功后，服务器为客户端创建一个登录会话id，客户端凭借这个登录会话id来和服务器展开后续沟通，
// 服务器通过这个登录会话id找到这个用户(因为存放了<session_id, user_id>)
// 2. 连接管理：


#include "redis_CRUD.hpp" // redis数据管理客户端封装
#include "etcd.hpp"       // 服务注册模块封装
#include "logger.hpp"     // 日志模块封装
#include "rpc_service_manager.hpp"    // 信道管理模块封装

#include "connection.hpp" // 连接管理模块

#include "user.pb.h"               // protobuf框架代码
#include "base.pb.h"               // protobuf框架代码
#include "file.pb.h"               // protobuf框架代码
#include "friend.pb.h"             // protobuf框架代码
#include "gateway.pb.h"            // protobuf框架代码
#include "message_storage.pb.h"    // protobuf框架代码
#include "speech_recognition.pb.h" // protobuf框架代码
#include "message_transmit.pb.h"   // protobuf框架代码
#include "notify.pb.h"

#include "httplib.h" // http服务器

namespace chen_im
{
// 网关暴露给客户端的接口一共28个，其中5个方法是不用鉴权的，因为用户还没有登陆：
#define GET_PHONE_VERIFY_CODE "/service/user/get_phone_verify_code" // "user.proto" rpc GetPhoneVerifyCode()
#define USERNAME_REGISTER "/service/user/username_register"         // "user.proto" rpc UserRegister()
#define USERNAME_LOGIN "/service/user/username_login"               // "user.proto" rpc UserLogin()
#define PHONE_REGISTER "/service/user/phone_register"               // "user.proto" rpc PhoneRegister()
#define PHONE_LOGIN "/service/user/phone_login"                     // "user.proto" rpc PhoneLogin()

// 其余23个都是需要鉴权的，也就是判断是否登录了
// 有5个HTTP接口会通过websocket给客户端推送消息，具体推送的API定义在notify.proto里面
// FriendAdd
// FriendAddProcess
// FriendRemove
// ChatSessionCreate
// NewMessage

#define GET_USERINFO "/service/user/get_user_info"                  // "user.proto" rpc GetUserInfo()
#define SET_USER_AVATAR "/service/user/set_avatar"                  // "user.proto" rpc SetUserAvatar()
#define SET_USER_NICKNAME "/service/user/set_nickname"              // "user.proto" rpc SetUserNickname()
#define SET_USER_DESC "/service/user/set_description"               // "user.proto" rpc SetUserDescription()
#define SET_USER_PHONE "/service/user/set_phone"                    // "user.proto" rpc SetUserPhoneNumber()
#define FRIEND_GET_LIST "/service/friend/get_friend_list"                  // "friend.proto" rpc GetFriendList()
#define FRIEND_APPLY "/service/friend/add_friend_apply"                    // "friend.proto" rpc FriendAdd()
#define FRIEND_APPLY_PROCESS "/service/friend/add_friend_process"          // "friend.proto" rpc FriendAddProcess()
#define FRIEND_REMOVE "/service/friend/remove_friend"                      // "friend.proto" rpc FriendRemove()
#define FRIEND_SEARCH "/service/friend/search_friend"                      // "friend.proto" rpc FriendSearch()
#define FRIEND_GET_PENDING_EV "/service/friend/get_pending_friend_events"  // "friend.proto" rpc GetPendingFriendEventList()
#define CSS_GET_LIST "/service/friend/get_chat_session_list"               // "friend.proto" rpc GetChatSessionList()
#define CSS_CREATE "/service/friend/create_chat_session"                   // "friend.proto" rpc ChatSessionCreate()
#define CSS_GET_MEMBER "/service/friend/get_chat_session_member"           // "friend.proto" rpc GetChatSessionMember()
#define MSG_GET_RANGE "/service/message_storage/get_history"     // "message_storage.proto" rpc GetHistoryMsg()
#define MSG_GET_RECENT "/service/message_storage/get_recent"     // "message_storage.proto" rpc GetRecentMsg()
#define MSG_KEY_SEARCH "/service/message_storage/search_history" // "message_storage.proto" rpc MsgSearch()
#define NEW_MESSAGE "/service/message_transmit/new_message" // "message_transmit.proto" rpc GetTransmitTarget()
#define FILE_GET_SINGLE "/service/file/get_single_file" // "file.proto" rpc GetSingleFile()
#define FILE_GET_MULTI "/service/file/get_multi_file"   // "file.proto" rpc GetMultiFile()
#define FILE_PUT_SINGLE "/service/file/put_single_file" // "file.proto" rpc PutSingleFile()
#define FILE_PUT_MULTI "/service/file/put_multi_file"   // "file.proto" rpc PutMultiFile()
#define SPEECH_RECOGNITION "/service/speech/recognition" // "speech_recognition.proto" rpc SpeechRecognition()
    

    // 网关服务器本质上是一个进程在运行，客户端也是
    // 但是他们分别充当websocket服务器/客户端、http服务器/客户端
    // 所以服务器进程中会存在两个线程，一个是websocket服务线程，一个是http的线程
    // 这两条线程都会一直阻塞等待，每当有消息或请求到来时，会将请求体推入线程池的任务队列让线程池里的线程去消费
    class GatewayServer
    { 
    public:
        using ptr = std::shared_ptr<GatewayServer>;
        GatewayServer(int websocket_port,
                      int http_port,
                      const std::shared_ptr<sw::redis::Redis> &redis_client,
                      const ServiceManager::ptr &service_managers,
                      const Discovery::ptr &service_discoverer,
                      const std::string user_service_name,
                      const std::string file_service_name,
                      const std::string speech_service_name,
                      const std::string message_store_service_name,
                      const std::string message_transmit_service_name,
                      const std::string friend_service_name)
            : _redis_session(std::make_shared<Session>(redis_client)),
              _redis_status(std::make_shared<Status>(redis_client)),
              _redis_uti(std::make_shared<RedisDatabaseUtility>(redis_client)),
              _service_manager(service_managers),
              _service_discoverer(service_discoverer),
              _user_service_name(user_service_name),
              _file_service_name(file_service_name),
              _speech_service_name(speech_service_name),
              _message_store_service_name(message_store_service_name),
              _message_transmit_service_name(message_transmit_service_name),
              _friend_service_name(friend_service_name),
              _connections(std::make_shared<Connection>())
        {
            _ws_server.set_access_channels(websocketpp::log::alevel::none);
            _ws_server.init_asio();
            _ws_server.set_open_handler(std::bind(&GatewayServer::when_websocket_connection_open, this, std::placeholders::_1));
            _ws_server.set_close_handler(std::bind(&GatewayServer::when_websocket_connection_close, this, std::placeholders::_1));
            auto websocket_new_message_callback = std::bind(&GatewayServer::when_websocket_get_message, this,
                                  std::placeholders::_1, std::placeholders::_2);
            _ws_server.set_message_handler(websocket_new_message_callback);
            _ws_server.set_reuse_addr(true);
            _ws_server.listen(websocket_port);
            _ws_server.start_accept();

            _http_server.Post(GET_PHONE_VERIFY_CODE, (httplib::Server::Handler)std::bind(&GatewayServer::GetPhoneVerifyCode, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(USERNAME_REGISTER,     (httplib::Server::Handler)std::bind(&GatewayServer::UserRegister, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(USERNAME_LOGIN,        (httplib::Server::Handler)std::bind(&GatewayServer::UserLogin, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(PHONE_REGISTER, (httplib::Server::Handler)std::bind(&GatewayServer::PhoneRegister, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(PHONE_LOGIN, (httplib::Server::Handler)std::bind(&GatewayServer::PhoneLogin, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(GET_USERINFO, (httplib::Server::Handler)std::bind(&GatewayServer::GetUserInfo, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(SET_USER_AVATAR, (httplib::Server::Handler)std::bind(&GatewayServer::SetUserAvatar, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(SET_USER_NICKNAME, (httplib::Server::Handler)std::bind(&GatewayServer::SetUserNickname, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(SET_USER_DESC, (httplib::Server::Handler)std::bind(&GatewayServer::SetUserDescription, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(SET_USER_PHONE, (httplib::Server::Handler)std::bind(&GatewayServer::SetUserPhoneNumber, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FRIEND_GET_LIST, (httplib::Server::Handler)std::bind(&GatewayServer::GetFriendList, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FRIEND_APPLY, (httplib::Server::Handler)std::bind(&GatewayServer::FriendAdd, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FRIEND_APPLY_PROCESS, (httplib::Server::Handler)std::bind(&GatewayServer::FriendAddProcess, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FRIEND_REMOVE, (httplib::Server::Handler)std::bind(&GatewayServer::FriendRemove, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FRIEND_SEARCH, (httplib::Server::Handler)std::bind(&GatewayServer::FriendSearch, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FRIEND_GET_PENDING_EV, (httplib::Server::Handler)std::bind(&GatewayServer::GetPendingFriendEventList, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(CSS_GET_LIST, (httplib::Server::Handler)std::bind(&GatewayServer::GetChatSessionList, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(CSS_CREATE, (httplib::Server::Handler)std::bind(&GatewayServer::ChatSessionCreate, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(CSS_GET_MEMBER, (httplib::Server::Handler)std::bind(&GatewayServer::GetChatSessionMember, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(MSG_GET_RANGE, (httplib::Server::Handler)std::bind(&GatewayServer::GetHistoryMsg, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(MSG_GET_RECENT, (httplib::Server::Handler)std::bind(&GatewayServer::GetRecentMsg, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(MSG_KEY_SEARCH, (httplib::Server::Handler)std::bind(&GatewayServer::MsgSearch, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(NEW_MESSAGE, (httplib::Server::Handler)std::bind(&GatewayServer::NewMessage, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FILE_GET_SINGLE, (httplib::Server::Handler)std::bind(&GatewayServer::GetSingleFile, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FILE_GET_MULTI, (httplib::Server::Handler)std::bind(&GatewayServer::GetMultiFile, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FILE_PUT_SINGLE, (httplib::Server::Handler)std::bind(&GatewayServer::PutSingleFile, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(FILE_PUT_MULTI, (httplib::Server::Handler)std::bind(&GatewayServer::PutMultiFile, this, std::placeholders::_1, std::placeholders::_2));
            _http_server.Post(SPEECH_RECOGNITION, (httplib::Server::Handler)std::bind(&GatewayServer::SpeechRecognition, this, std::placeholders::_1, std::placeholders::_2));
            _http_thread = std::thread([this, http_port]()
                                       { _http_server.listen("0.0.0.0", http_port); });
            _http_thread.detach(); // http线程与主执行流分离，退出时自动释放资源
        }

        void start()
        {
            _ws_server.run();
        }

        enum exit_mode
        {
            KILLED_BY_SIGNAL = 1, // 被信号所杀
            NORMAL_EXIT = 2       // 自己退出
        };
        // 意外退出或被信号所杀时，清理redis缓存
        void when_server_exit(exit_mode mode)
        {
            switch(mode)
            {
                case exit_mode::KILLED_BY_SIGNAL:
                {
                    _redis_uti->flush_all_db();
                }
                case exit_mode::NORMAL_EXIT:
                {
                    _redis_uti->flush_all_db();
                }
            }
        }

    private:
        void when_websocket_connection_open(websocketpp::connection_hdl hdl)
        {
            LOG_DEBUG("websocket长连接建立成功 {}", (size_t)_ws_server.get_con_from_hdl(hdl).get());
        }

        // 需要完成redis缓存的清理
        void when_websocket_connection_close(websocketpp::connection_hdl hdl)
        {
            // 长连接断开时做的清理工作
            // 0. 通过连接对象，获取对应的用户ID与登录会话ID
            auto conn = _ws_server.get_con_from_hdl(hdl);
            std::string uid, ssid;
            bool ret = _connections->get_client_info(conn, uid, ssid);
            if (ret == false) {
                LOG_WARN("长连接断开，未找到长连接对应的客户端信息！");
                return;
            }
            // 1. 移除登录会话信息
            _redis_session->remove(ssid);
            // 2. 移除登录状态信息
            _redis_status->remove(uid);
            // 3. 移除长连接管理数据
            _connections->remove_connection(conn);
            LOG_DEBUG("长连接断开，清理缓存数据! 会话id：{}，用户id：{}，长连接句柄：{}", ssid, uid, (size_t)conn.get());
        }

        // 
        void keepAlive(websocket_server_t::connection_ptr conn)
        {
            if (!conn || conn->get_state() != websocketpp::session::state::value::open)
            {
                LOG_DEBUG("非正常连接状态，结束连接保活");
                return;
            }
            conn->ping("");
            _ws_server.set_timer(60000, std::bind(&GatewayServer::keepAlive, this, conn));
        }

        // 长连接建一旦建立，客户端会向服务器发送一条消息（唯一一次客户端向服务器发消息），包含客户端自己的身份信息，
        // 简单看一下客户端ws连接建立成功时的回调函数：
        // connect(&websocketClient, &QWebSocket::connected, this, [=]() {
        //     LOG() << "websocket 连接成功!";
        //     // 不要忘记! 在 websocket 连接成功之后, 发送身份认证消息!
        //     sendAuth();
        // });
        // 
        // void NetClient::sendAuth()
        // {
        //     chen_im::ClientAuthenticationReq req;
        //     req.setRequestId(makeRequestId());
        //     req.setSessionId(dataCenter->getLoginSessionId());
        //     QByteArray body = req.serialize(&serializer);
        //     websocketClient.sendBinaryMessage(body);
        //     LOG() << "[WS身份认证] requestId=" << req.requestId() << ", loginSessionId=" << req.sessionId();
        // }
        // 
        // 收到第一条消息后，根据消息中的会话ID进行身份识别，将客户端长连接添加至Connection管理对象中
        void when_websocket_get_message(websocketpp::connection_hdl hdl, websocket_server_t::message_ptr msg)
        {
            // 1. 取出长连接对应的连接对象
            auto conn = _ws_server.get_con_from_hdl(hdl);

            // 2. 针对消息内容进行反序列化 -- ClientAuthenticationReq -- 提取登录会话ID
            ClientAuthenticationReq request;
            bool ret = request.ParseFromString(msg->get_payload());
            if (ret == false) {
                LOG_ERROR("长连接身份识别失败：正文反序列化失败！");
                _ws_server.close(hdl, websocketpp::close::status::unsupported_data, "正文反序列化失败!");
                return;
            }

            // 3. 在会话信息缓存中，查找会话信息
            std::string ssid = request.session_id();
            auto uid = _redis_session->get_uid(ssid); // 返回的是std::optional<std::string>

            // 4. 如果uid为空，则redis中会话信息不存在，关闭连接
            if (!uid) {
                LOG_ERROR("长连接身份识别失败, 未找到session_id: {}！", ssid);
                _ws_server.close(hdl, websocketpp::close::status::unsupported_data, "未找到会话信息!");
                return;
            }

            // 5. 会话信息存在，则添加长连接管理
            _connections->insert(conn, *uid, ssid);
            keepAlive(conn);
        }

        void GetPhoneVerifyCode(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            PhoneVerifyCodeReq req;
            PhoneVerifyCodeRsp rsp;

            // 错误回调函数
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };

            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取短信验证码请求正文反序列化失败！");
                return err_response("获取短信验证码请求正文反序列化失败！");
            }

            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel) {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetPhoneVerifyCode(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }

            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void UserRegister(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            UserRegisterReq req;
            UserRegisterRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户名注册请求正文反序列化失败！");
                return err_response("用户名注册请求正文反序列化失败！");
            }
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.UserRegister(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void UserLogin(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            UserLoginReq req;
            UserLoginRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户登录请求正文反序列化失败！");
                return err_response("用户登录请求正文反序列化失败！");
            }
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.UserLogin(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void PhoneRegister(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            PhoneRegisterReq req;
            PhoneRegisterRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("手机号注册请求正文反序列化失败！");
                return err_response("手机号注册请求正文反序列化失败！");
            }
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.PhoneRegister(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void PhoneLogin(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            PhoneLoginReq req;
            PhoneLoginRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("手机号登录请求正文反序列化失败！");
                return err_response("手机号登录请求正文反序列化失败！");
            }
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.PhoneLogin(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void GetUserInfo(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            GetUserInfoReq req;
            GetUserInfoRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取用户信息请求正文反序列化失败！");
                return err_response("获取用户信息请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetUserInfo(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void SetUserAvatar(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            SetUserAvatarReq req;
            SetUserAvatarRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户头像设置请求正文反序列化失败！");
                return err_response("用户头像设置请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.SetUserAvatar(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void SetUserNickname(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            SetUserNicknameReq req;
            SetUserNicknameRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户昵称设置请求正文反序列化失败！");
                return err_response("用户昵称设置请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.SetUserNickname(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void SetUserDescription(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            SetUserDescriptionReq req;
            SetUserDescriptionRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户签名设置请求正文反序列化失败！");
                return err_response("用户签名设置请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.SetUserDescription(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void SetUserPhoneNumber(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            SetUserPhoneNumberReq req;
            SetUserPhoneNumberRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户手机号设置请求正文反序列化失败！");
                return err_response("用户手机号设置请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.SetUserPhoneNumber(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return err_response("用户子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void GetFriendList(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 取出http请求正文，将正文进行反序列化
            GetFriendListReq req;
            GetFriendListRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取好友列表请求正文反序列化失败！");
                return err_response("获取好友列表请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 2. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetFriendList(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 3. 得到用户子服务的响应后，将响应内容进行序列化作为http响应正文
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        std::shared_ptr<GetUserInfoRsp> _GetUserInfo(const std::string &request_id, const std::string &uid)
        {
            GetUserInfoReq req;
            auto rsp = std::make_shared<GetUserInfoRsp>();
            req.set_request_id(request_id);
            req.set_user_id(uid);
            // 2. 将请求转发给用户子服务进行业务处理
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return std::shared_ptr<GetUserInfoRsp>();
            }
            chen_im::UserService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetUserInfo(&cntl, &req, rsp.get(), nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 用户子服务调用失败！", req.request_id());
                return std::shared_ptr<GetUserInfoRsp>();
            }
            return rsp;
        }

        void FriendAdd(const httplib::Request &request, httplib::Response &response)
        {
            // 好友申请的业务处理中，好友子服务其实只是在数据库创建了申请事件
            // 网关需要做的事情：当好友子服务将业务处理完毕后，如果处理是成功的--需要通知被申请方
            // 1. 正文的反序列化，提取关键要素：登录会话ID
            FriendAddReq req;
            FriendAddRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("申请好友请求正文反序列化失败！");
                return err_response("申请好友请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.FriendAdd(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 4. 若业务处理成功 --- 且获取被申请方长连接成功，则向被申请放进行好友申请事件通知
            //  否则就不通知，待客户端上线拉取未处理的好友申请时，会继续申请流程
            auto conn = _connections->get_connection(req.respondent_id());
            if (rsp.success() && conn)
            {
                LOG_DEBUG("找到被申请人 {} 长连接，对其进行好友申请通知", req.respondent_id());
                auto user_rsp = _GetUserInfo(req.request_id(), *uid);
                if (!user_rsp)
                {
                    LOG_ERROR("{} 获取当前客户端用户信息失败！", req.request_id());
                    return err_response("获取当前客户端用户信息失败！");
                }
                NotifyMessage notify;
                notify.set_notify_type(NotifyType::FRIEND_ADD_APPLY_NOTIFY);
                notify.mutable_friend_add_apply()->mutable_user_info()->CopyFrom(user_rsp->user_info());
                conn->send(notify.SerializeAsString(), websocketpp::frame::opcode::value::binary);
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void FriendAddProcess(const httplib::Request &request, httplib::Response &response)
        {
            // 被申请方，拉取完所有的待处理的好友申请请求，好友申请的处理流程-----
            FriendAddProcessReq req;
            FriendAddProcessRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("好友申请处理请求正文反序列化失败！");
                return err_response("好友申请处理请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            const std::optional<std::string> &uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.FriendAddProcess(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }

            if (rsp.success())
            {
                auto process_user_rsp = _GetUserInfo(req.request_id(), *uid); // 处理（接收）好友请求的一方
                if (!process_user_rsp)
                {
                    LOG_ERROR("{} 获取用户信息失败！", req.request_id());
                    return err_response("获取用户信息失败！");
                }
                auto apply_user_rsp = _GetUserInfo(req.request_id(), req.apply_user_id()); // 发起（申请）好友申请的一方
                if (!process_user_rsp)
                {
                    LOG_ERROR("{} 获取用户信息失败！", req.request_id());
                    return err_response("获取用户信息失败！");
                }
                auto process_ws_conn = _connections->get_connection(*uid);
                if (process_ws_conn)
                    LOG_DEBUG("找到处理人的长连接！");
                else
                    LOG_DEBUG("未找到处理人的长连接！");
                auto apply_ws_conn = _connections->get_connection(req.apply_user_id());
                if (apply_ws_conn)
                    LOG_DEBUG("找到申请人的长连接！");
                else
                    LOG_DEBUG("未找到申请人的长连接！");

                // 4. 将处理结果给申请人进行通知
                if (apply_ws_conn)
                {
                    NotifyMessage notify;
                    notify.set_notify_type(NotifyType::FRIEND_ADD_PROCESS_NOTIFY);
                    auto process_result = notify.mutable_friend_process_result();
                    process_result->mutable_user_info()->CopyFrom(process_user_rsp->user_info());
                    process_result->set_agree(req.agree());
                    apply_ws_conn->send(notify.SerializeAsString(),
                                     websocketpp::frame::opcode::value::binary);
                    LOG_DEBUG("对申请人进行申请处理结果通知！");
                }
                // 5. 若处理结果是同意 --- 会伴随着单聊会话的创建 -- 因此需要对双方进行会话创建的通知
                if (req.agree() && apply_ws_conn)
                { // 对申请人的通知---会话信息就是处理人信息
                    NotifyMessage notify;
                    notify.set_notify_type(NotifyType::CHAT_SESSION_CREATE_NOTIFY);
                    NotifyNewChatSession *new_chat_session = notify.mutable_new_chat_session_info();
                    new_chat_session->mutable_chat_session_info()->set_single_chat_friend_id(*uid);
                    new_chat_session->mutable_chat_session_info()->set_chat_session_id(rsp.new_session_id());
                    new_chat_session->mutable_chat_session_info()->set_chat_session_name(process_user_rsp->user_info().nickname());
                    new_chat_session->mutable_chat_session_info()->set_avatar(process_user_rsp->user_info().avatar());
                    apply_ws_conn->send(notify.SerializeAsString(), websocketpp::frame::opcode::value::binary);
                    LOG_DEBUG("对申请人客户端进行会话创建通知！");
                }
                if (req.agree() && process_ws_conn)
                { // 对处理人的通知 --- 会话信息就是申请人信息
                    NotifyMessage notify;
                    notify.set_notify_type(NotifyType::CHAT_SESSION_CREATE_NOTIFY);
                    NotifyNewChatSession *new_chat_session = notify.mutable_new_chat_session_info();
                    new_chat_session->mutable_chat_session_info()->set_single_chat_friend_id(req.apply_user_id());
                    new_chat_session->mutable_chat_session_info()->set_chat_session_id(rsp.new_session_id());
                    new_chat_session->mutable_chat_session_info()->set_chat_session_name(apply_user_rsp->user_info().nickname());
                    new_chat_session->mutable_chat_session_info()->set_avatar(apply_user_rsp->user_info().avatar());
                    process_ws_conn->send(notify.SerializeAsString(), websocketpp::frame::opcode::value::binary);
                    LOG_DEBUG("对处理人客户端进行会话创建通知！");
                }
            }
            // 6. 对客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void FriendRemove(const httplib::Request &request, httplib::Response &response)
        {
            // 1. 正文的反序列化，提取关键要素：登录会话ID
            FriendRemoveReq req;
            FriendRemoveRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("删除好友请求正文反序列化失败！");
                return err_response("删除好友请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.FriendRemove(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 4. 若业务处理成功 --- 且获取被申请方长连接成功，则向被申请放进行好友申请事件通知
            auto conn = _connections->get_connection(req.peer_id());
            if (rsp.success() && conn)
            {
                LOG_ERROR("对被删除人 {} 进行好友删除通知！", req.peer_id());
                NotifyMessage notify;
                notify.set_notify_type(NotifyType::FRIEND_REMOVE_NOTIFY);
                notify.mutable_friend_remove()->set_user_id(*uid);
                conn->send(notify.SerializeAsString(), websocketpp::frame::opcode::value::binary);
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void FriendSearch(const httplib::Request &request, httplib::Response &response)
        {
            FriendSearchReq req;
            FriendSearchRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("用户搜索请求正文反序列化失败！");
                return err_response("用户搜索请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.FriendSearch(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void GetPendingFriendEventList(const httplib::Request &request, httplib::Response &response)
        {
            GetPendingFriendEventListReq req;
            GetPendingFriendEventListRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取待处理好友申请请求正文反序列化失败！");
                return err_response("获取待处理好友申请请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetPendingFriendEventList(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void GetChatSessionList(const httplib::Request &request, httplib::Response &response)
        {
            GetChatSessionListReq req;
            GetChatSessionListRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取聊天会话列表请求正文反序列化失败！");
                return err_response("获取聊天会话列表请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetChatSessionList(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void GetChatSessionMember(const httplib::Request &request, httplib::Response &response)
        {
            GetChatSessionMemberReq req;
            GetChatSessionMemberRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取聊天会话成员请求正文反序列化失败！");
                return err_response("获取聊天会话成员请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetChatSessionMember(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void ChatSessionCreate(const httplib::Request &request, httplib::Response &response)
        {
            ChatSessionCreateReq req;
            ChatSessionCreateRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("创建聊天会话请求正文反序列化失败！");
                return err_response("创建聊天会话请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_friend_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FriendService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.ChatSessionCreate(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 好友子服务调用失败！", req.request_id());
                return err_response("好友子服务调用失败！");
            }
            // 4. 若业务处理成功 --- 且获取被申请方长连接成功，则向被申请放进行好友申请事件通知
            if (rsp.success())
            {
                for (int i = 0; i < req.member_id_list_size(); i++)
                {
                    auto conn = _connections->get_connection(req.member_id_list(i));
                    if (!conn)
                    {
                        LOG_DEBUG("未找到群聊成员 {} 长连接", req.member_id_list(i));
                        continue;
                    }
                    NotifyMessage notify;
                    notify.set_notify_type(NotifyType::CHAT_SESSION_CREATE_NOTIFY);
                    auto chat_session = notify.mutable_new_chat_session_info();
                    chat_session->mutable_chat_session_info()->CopyFrom(rsp.chat_session_info());
                    conn->send(notify.SerializeAsString(), websocketpp::frame::opcode::value::binary);
                    LOG_DEBUG("对群聊成员 {} 进行会话创建通知", req.member_id_list(i));
                }
            }
            // 5. 向客户端进行响应
            rsp.clear_chat_session_info();
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void GetHistoryMsg(const httplib::Request &request, httplib::Response &response)
        {
            GetHistoryMsgReq req;
            GetHistoryMsgRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取区间消息请求正文反序列化失败！");
                return err_response("获取区间消息请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_message_store_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::MsgStorageService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetHistoryMsg(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 消息存储子服务调用失败！", req.request_id());
                return err_response("消息存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void GetRecentMsg(const httplib::Request &request, httplib::Response &response)
        {
            GetRecentMsgReq req;
            GetRecentMsgRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("获取最近消息请求正文反序列化失败！");
                return err_response("获取最近消息请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_message_store_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::MsgStorageService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetRecentMsg(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 消息存储子服务调用失败！", req.request_id());
                return err_response("消息存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void MsgSearch(const httplib::Request &request, httplib::Response &response)
        {
            MsgSearchReq req;
            MsgSearchRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("消息搜索请求正文反序列化失败！");
                return err_response("消息搜索请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_message_store_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::MsgStorageService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.MsgSearch(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 消息存储子服务调用失败！", req.request_id());
                return err_response("消息存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void GetSingleFile(const httplib::Request &request, httplib::Response &response)
        {
            GetSingleFileReq req;
            GetSingleFileRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("单文件下载请求正文反序列化失败！");
                return err_response("单文件下载请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FileService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetSingleFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 文件存储子服务调用失败！", req.request_id());
                return err_response("文件存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void GetMultiFile(const httplib::Request &request, httplib::Response &response)
        {
            GetMultiFileReq req;
            GetMultiFileRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("单文件下载请求正文反序列化失败！");
                return err_response("单文件下载请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FileService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetMultiFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 文件存储子服务调用失败！", req.request_id());
                return err_response("文件存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void PutSingleFile(const httplib::Request &request, httplib::Response &response)
        {
            PutSingleFileReq req;
            PutSingleFileRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("单文件上传请求正文反序列化失败！");
                return err_response("单文件上传请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FileService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.PutSingleFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 文件存储子服务调用失败！", req.request_id());
                return err_response("文件存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void PutMultiFile(const httplib::Request &request, httplib::Response &response)
        {
            PutMultiFileReq req;
            PutMultiFileRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("批量文件上传请求正文反序列化失败！");
                return err_response("批量文件上传请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给好友子服务进行业务处理
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::FileService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.PutMultiFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 文件存储子服务调用失败！", req.request_id());
                return err_response("文件存储子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }
        void SpeechRecognition(const httplib::Request &request, httplib::Response &response)
        {
            LOG_DEBUG("收到语音转文字请求！");
            SpeechRecognitionReq req;
            SpeechRecognitionRsp rsp;
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("语音识别请求正文反序列化失败！");
                return err_response("语音识别请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);

            auto channel = _service_manager->get(_speech_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::SpeechService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.SpeechRecognition(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 语音识别子服务调用失败！", req.request_id());
                return err_response("语音识别子服务调用失败！");
            }
            // 5. 向客户端进行响应
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

        void NewMessage(const httplib::Request &request, httplib::Response &response)
        {
            NewMessageReq req;
            NewMessageRsp rsp;               // 这是给客户端的响应
            GetTransmitTargetRsp target_rsp; // 这是请求“消息转发子服务”的响应
            auto err_response = [&req, &rsp, &response](const std::string &errmsg) -> void
            {
                rsp.set_success(false);
                rsp.set_errmsg(errmsg);
                response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
            };
            bool ret = req.ParseFromString(request.body);
            if (ret == false)
            {
                LOG_ERROR("新消息请求正文反序列化失败！");
                return err_response("新消息请求正文反序列化失败！");
            }
            // 2. 客户端身份识别与鉴权
            std::string ssid = req.session_id();
            auto uid = _redis_session->get_uid(ssid);
            if (!uid)
            {
                LOG_ERROR("{} 获取登录会话关联用户信息失败！", ssid);
                return err_response("获取登录会话关联用户信息失败！");
            }
            req.set_user_id(*uid);
            // 3. 将请求转发给消息转发子服务进行业务处理
            auto channel = _service_manager->get(_message_transmit_service_name);
            if (!channel)
            {
                LOG_ERROR("{} 未找到可提供业务处理的用户子服务节点！", req.request_id());
                return err_response("未找到可提供业务处理的用户子服务节点！");
            }
            chen_im::MsgTransmitService_Stub stub(channel.get());
            brpc::Controller cntl;
            stub.GetTransmitTarget(&cntl, &req, &target_rsp, nullptr);
            if (cntl.Failed())
            {
                LOG_ERROR("{} 消息转发子服务调用失败！", req.request_id());
                return err_response("消息转发子服务调用失败！");
            }
            // 4. 若业务处理成功 --- 且获取被申请方长连接成功，则向被申请放进行新消息事件通知
            if (target_rsp.success())
            {
                for (int i = 0; i < target_rsp.target_id_list_size(); i++)
                {
                    std::string notify_uid = target_rsp.target_id_list(i);
                    if (notify_uid == *uid)
                        continue; // 不通知自己
                    auto conn = _connections->get_connection(notify_uid);
                    if (!conn)
                    {
                        continue;
                    }
                    NotifyMessage notify;
                    notify.set_notify_type(NotifyType::CHAT_MESSAGE_NOTIFY);
                    auto msg_info = notify.mutable_new_message_info();
                    msg_info->mutable_message_info()->CopyFrom(target_rsp.message());
                    conn->send(notify.SerializeAsString(), websocketpp::frame::opcode::value::binary);
                }
            }
            // 5. 向客户端进行响应
            rsp.set_request_id(req.request_id());
            rsp.set_success(target_rsp.success());
            rsp.set_errmsg(target_rsp.errmsg());
            response.set_content(rsp.SerializeAsString(), "application/x-protbuf");
        }

    private:
        Session::ptr _redis_session; // session库
        Status::ptr _redis_status;   // status库
        RedisDatabaseUtility::ptr _redis_uti; // 用于操作整个redis数据库

        // 子服务的完整名称
        std::string _user_service_name;
        std::string _file_service_name;
        std::string _speech_service_name;
        std::string _message_store_service_name;
        std::string _message_transmit_service_name;
        std::string _friend_service_name;

        ServiceManager::ptr _service_manager; // 要调用6个子服务
        Discovery::ptr _service_discoverer;

        Connection::ptr _connections;

        websocket_server_t _ws_server;
        httplib::Server _http_server;
        std::thread _http_thread;      // 一个执行流里不能有两个服务器，websocket和http都需要一个线程来执行
    };

    class GatewayServerFactory
    {
    public:
        // 构造redis客户端对象
        void make_redis_object(const std::string &host,
                               int port,
                               int db,
                               bool keep_alive)
        {
            _redis_client = RedisClientFactory::create(host, port, db, keep_alive);
        }
        // 用于构造服务发现客户端&信道管理对象
        void make_discovery_object(const std::string &reg_host,
                                   const std::string &base_service_name,
                                   const std::string &file_service_name,
                                   const std::string &speech_service_name,
                                   const std::string &message_store_service_name,
                                   const std::string &friend_service_name,
                                   const std::string &user_service_name,
                                   const std::string &message_transmit_service_name)
        {
            _file_service_name = file_service_name;
            _speech_service_name = speech_service_name;
            _message_store_service_name = message_store_service_name;
            _friend_service_name = friend_service_name;
            _user_service_name = user_service_name;
            _message_transmit_service_name = message_transmit_service_name;
            _service_manager = std::make_shared<ServiceManager>();
            _service_manager->concern(file_service_name);
            _service_manager->concern(speech_service_name);
            _service_manager->concern(message_store_service_name);
            _service_manager->concern(friend_service_name);
            _service_manager->concern(user_service_name);
            _service_manager->concern(message_transmit_service_name);
            auto put_cb = std::bind(&ServiceManager::when_service_online, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            auto del_cb = std::bind(&ServiceManager::when_service_offline, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            _service_discoverer = std::make_shared<Discovery>(reg_host, base_service_name, put_cb, del_cb);
        }
        void make_server_object(int websocket_port, int http_port)
        {
            _websocket_port = websocket_port;
            _http_port = http_port;
        }
        // 构造RPC服务器对象
        GatewayServer::ptr build()
        {
            if (!_redis_client)
            {
                LOG_ERROR("还未初始化Redis客户端模块！");
                abort();
            }
            if (!_service_discoverer)
            {
                LOG_ERROR("还未初始化服务发现模块！");
                abort();
            }
            if (!_service_manager)
            {
                LOG_ERROR("还未初始化信道管理模块！");
                abort();
            }
            GatewayServer::ptr server = std::make_shared<GatewayServer>(
                _websocket_port, _http_port, _redis_client, _service_manager,
                _service_discoverer, _user_service_name, _file_service_name,
                _speech_service_name, _message_store_service_name,
                _message_transmit_service_name, _friend_service_name);
            return server;
        }

    private:
        int _websocket_port;
        int _http_port;

        std::shared_ptr<sw::redis::Redis> _redis_client;

        std::string _file_service_name;
        std::string _speech_service_name;
        std::string _message_store_service_name;
        std::string _friend_service_name;
        std::string _user_service_name;
        std::string _message_transmit_service_name;
        ServiceManager::ptr _service_manager;
        Discovery::ptr _service_discoverer;
    };
}

--- FILE: 7.Gateway_Server/source/gateway_server.cc ---
内容:
//主要实现语音识别子服务的服务器的搭建
#include "gateway_server.hpp"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_int32(http_listen_port, 9000, "HTTP服务器监听端口");
DEFINE_int32(websocket_listen_port, 9001, "Websocket服务器监听端口");

DEFINE_string(registry_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(file_service, "/service/file_service", "文件存储子服务名称");
DEFINE_string(friend_service, "/service/friend_service", "好友管理子服务名称");
DEFINE_string(message_store_service, "/service/message_store_service", "消息存储子服务名称");
DEFINE_string(user_service, "/service/user_service", "用户管理子服务名称");
DEFINE_string(speech_service, "/service/speech/recognition", "语音识别子服务名称");
DEFINE_string(message_transmit_service, "/service/message_transmit_service", "转发管理子服务名称");

DEFINE_string(redis_host, "127.0.0.1", "Redis服务器访问地址");
DEFINE_int32(redis_port, 6379, "Redis服务器访问端口");
DEFINE_int32(redis_db, 0, "Redis默认库号");
DEFINE_bool(redis_keep_alive, true, "Redis长连接保活选项");

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    chen_im::GatewayServerFactory gsb;
    gsb.make_redis_object(FLAGS_redis_host, FLAGS_redis_port, FLAGS_redis_db, FLAGS_redis_keep_alive);
    gsb.make_discovery_object(FLAGS_registry_host, FLAGS_base_service, FLAGS_file_service,
        FLAGS_speech_service, FLAGS_message_store_service, FLAGS_friend_service, 
        FLAGS_user_service, FLAGS_message_transmit_service);
    gsb.make_server_object(FLAGS_websocket_listen_port, FLAGS_http_listen_port);
    auto server = gsb.build();
    server->start();
    return 0;
}

--- FILE: SQL_Code/message.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `message`;
-- 消息表：消息的完整信息（除了文件数据之外的所有数据）
CREATE TABLE `message` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -- 唯一的自增id：只是用来计数，和业务无关，不用画在ER图里
  `message_id` varchar(64) NOT NULL, -- 消息id
  `session_id` varchar(64) NOT NULL, -- 该消息所属的会话id
  `user_id` varchar(64) NOT NULL, -- 消息的发送者的用户id
  `message_type` TINYINT UNSIGNED NOT NULL, -- 消息类型：STRING = 0; IMAGE = 1; FILE = 2; SPEECH = 3;
  `create_time` TIMESTAMP NULL, -- 消息创建的时间
  `content` TEXT NULL, -- 消息内容（文件或者数据）
  `file_id` varchar(64) NULL, -- 文件id
  `file_name` varchar(128) NULL, -- 文件名称
  `file_size` INT UNSIGNED NULL) -- 文件大小
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `message_id_i`
  ON `message` (`message_id`);

CREATE INDEX `session_id_i`
  ON `message` (`session_id`);



--- FILE: SQL_Code/relation.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `relation`;
-- 好友关系表
CREATE TABLE `relation` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -- 唯一的自增id：只是用来计数，和业务无关，不用画在ER图里
  `user_id` varchar(64) NOT NULL, -- 用户id
  `peer_id` varchar(64) NOT NULL) -- 该用户的好友id
 ENGINE=InnoDB;

CREATE INDEX `user_id_i`
  ON `relation` (`user_id`);



--- FILE: SQL_Code/chat_session_member.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `chat_session_member`;
-- 聊天成员表：记录每个聊天会话里有哪些成员
-- 会话：群聊或单人聊天被统称为“会话”
CREATE TABLE `chat_session_member` ( -- 会话成员表
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -- 唯一的自增id
  `chat_session_id` varchar(64) NOT NULL, -- 聊天会话id
  `user_id` varchar(64) NOT NULL) -- 用户id：
 ENGINE=InnoDB;

CREATE INDEX `chat_session_id_i`
  ON `chat_session_member` (`chat_session_id`);



--- FILE: SQL_Code/chat_session.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `chat_session`;
-- 聊天会话表：描述一个聊天会话，但是不存放聊天消息和成员信息
CREATE TABLE `chat_session` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -- 唯一的自增id：只是用来计数，和业务无关，不用画在ER图里
  `chat_session_id` varchar(64) NOT NULL, -- 聊天会话id：用来唯一标识一个会话
  `chat_session_name` varchar(64) NOT NULL, -- 会话名称
  `chat_session_type` tinyint NOT NULL) -- 会话类型：1. 单人聊天 2. 群聊
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `chat_session_id_i`
  ON `chat_session` (`chat_session_id`);

--- FILE: SQL_Code/user.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `user`;
-- 用户表：存放用户完整信息
CREATE TABLE `user` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -- 唯一的自增id：只是用来计数，和业务无关，不用画在ER图里
  `user_id` varchar(64) NOT NULL, -- 用户id
  `nickname` varchar(64) NULL, -- 昵称
  `description` TEXT NULL, -- 描述（个性签名）
  `password` varchar(64) NULL, -- 密码
  `phone` varchar(64) NULL, -- 手机号
  `avatar_id` varchar(64) NULL) -- 头像文件的文件id
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `user_id_i`
  ON `user` (`user_id`);

CREATE UNIQUE INDEX `nickname_i`
  ON `user` (`nickname`);

CREATE UNIQUE INDEX `phone_i`
  ON `user` (`phone`);



--- FILE: SQL_Code/friend_apply.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS `friend_apply`;
-- 好友申请表
CREATE TABLE `friend_apply` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -- 唯一的自增id：只是用来计数，和业务无关，不用画在ER图里
  `event_id` varchar(64) NOT NULL, -- 事件id：用来标记这次好友申请的事件
  `user_id` varchar(64) NOT NULL, -- 申请人的用户id
  `peer_id` varchar(64) NOT NULL) -- 对方的用户id
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `event_id_i`
  ON `friend_apply` (`event_id`);

CREATE INDEX `user_id_i`
  ON `friend_apply` (`user_id`);

CREATE INDEX `peer_id_i`
  ON `friend_apply` (`peer_id`);



--- FILE: Common/rabbitmq.hpp ---
内容:
#pragma once
#include <ev.h>
#include <amqpcpp.h>
#include <amqpcpp/libev.h>
#include <openssl/ssl.h>
#include <openssl/opensslv.h>
#include <amqpcpp/message.h>

#include <functional>
#include "logger.hpp"

namespace chen_im {

class MQClient
{
public:
    using ptr = std::shared_ptr<MQClient>;
private:
    struct ev_loop*     _loop;       // 实例化底层网络通信框架的I/O事件监控句柄
    std::unique_ptr<AMQP::LibEvHandler > _handler;    // libEventHandler句柄，将AMQP框架与事件监控关联起来
    std::unique_ptr<AMQP::TcpConnection> _connection; // TCP连接对象
    std::unique_ptr<AMQP::TcpChannel   > _channel;    // TCP信道对象
    std::thread _loop_thread; // 用来执行网络IO框架的执行流

public:
    using OnGetMessage = std::function<void(const char*, size_t)>;
    
    /// @param user chen
    /// @param password czhuowen
    /// @param mq_host 127.0.0.1:5672
    MQClient(const std::string &user, const std::string &password, const std::string &mq_host) 
    {
        // 1.实例化底层网络通信框架的I/O事件监控句柄
        _loop = EV_DEFAULT;

        // 2.实例化libEventHandler句柄，将AMQP框架与事件监控关联起来
        _handler = std::make_unique<AMQP::LibEvHandler>(_loop);

        // 3.实例化连接对象
        AMQP::Address address("amqp://" + user + ":" + password + "@" + mq_host + "/"); // "amqp://guest:guest@localhost/"
        _connection = std::make_unique<AMQP::TcpConnection>(_handler.get(), address);

        // 4.实例化信道对象
        _channel = std::make_unique<AMQP::TcpChannel>(_connection.get());
    }

    // 初始化交换机和一个队列，并把队列绑定到交换机上
    void declear_all_components(const std::string &exchange_name, 
                                const std::string &queue_name, 
                                const std::string &routing_key = "routing_key", 
                                AMQP::ExchangeType exchange_type = AMQP::ExchangeType::direct)
    {
        // 这里本来有个bug，就是在lambda表达式里面想要访问exchange_name这个函数参数
        // onError、onSuccess只是设置了回调，什么时候调用，不知道的
        // 有可能调用的时候exchange_name已经销毁了
        // 再访问exchange_name就变成悬垂引用了，正确的方法是使用

        // 声明交换机
        _channel->declareExchange(exchange_name, exchange_type)
            .onError([=](const char *msg){
                LOG_ERROR("声明交换机 {} 失败: {}", exchange_name, msg);
                exit(0);
            })
            .onSuccess([=](){
                LOG_INFO("声明交换机 {} 成功！", exchange_name);
            });

        // 声明队列
        _channel->declareQueue(queue_name)
            .onError([=](const char *msg){
                LOG_ERROR("声明队列 {} 失败: {}", queue_name, msg);
                exit(0);
            })
            .onSuccess([=](){
                LOG_INFO("声明队列 {} 成功！", queue_name);
            });

        // 交换机和队列进行绑定到信道中
        _channel->bindQueue(exchange_name, queue_name, routing_key)
            .onError([=](const char *msg){
                LOG_ERROR("交换机 {} 和队列 {} 绑定失败: {}", exchange_name, queue_name, msg);
                exit(0);
            })
            .onSuccess([=](){
                LOG_INFO("交换机 {} 和队列 {} 绑定成功!", exchange_name, queue_name);
            });

        // 主执行流不阻塞，直接返回
        LOG_DEBUG("declear all components执行完毕，{}, {}, {}", exchange_name, queue_name, routing_key);
        run();
    }

    // 启动网络通信框架，开启IO
    void run()
    {
        _loop_thread = std::thread([this]{
            ev_run(_loop, 0);
        });
    }

    // 发布一个消息
    bool publish_message(const std::string &exchange_name,
                         const std::string &msg, 
                         const std::string &routing_key = "routing_key")
    {
        AMQP::Envelope env(msg.c_str(), msg.size());
        env.setContentType("application/octet-stream");

        bool ret = _channel->publish(exchange_name, routing_key, msg);
        if (ret == false) {
            LOG_ERROR("publish失败!");
            return false;
        }
        return true;
    }

    // 设置某个消息队列消费一条消息的回调函数
    bool consume_message(const std::string &queue_name, 
                         const std::string &tag, 
                         std::function<void(const char*, size_t)> callback)
    {
        LOG_DEBUG("Consuming messages from queue: {} with tag: {}", queue_name, tag);
        _channel->consume(queue_name, tag)
            .onReceived([&, callback](const AMQP::Message &message, uint64_t deliveryTag, bool redelivered) {
                if (!callback) {
                    LOG_ERROR("Callback function is empty!");
                    abort();
                }
                callback(message.body(), message.size());
                _channel->ack(deliveryTag);
            })
            .onError([&](const char* msg) {
                LOG_ERROR("订阅 {} 失败, 原因: {}", queue_name, msg);
                return false;
            });
        return true;
    }
    ~MQClient()
    {
        struct ev_async async_wather;
        ev_async_init(&async_wather, watcher_callback);
        ev_async_start(_loop, &async_wather);
        ev_async_send(_loop, &async_wather);
        _loop_thread.join();
        // ev_loop_destroy(_loop); // 二次释放错误
    }

private:
    static void watcher_callback(struct ev_loop *loop, ev_async *watcher, int32_t revents)
    {
        ev_break(loop, EVBREAK_ALL);
    }

};

}

--- FILE: Common/httplib.h ---
内容:
//
//  httplib.h
//
//  Copyright (c) 2024 Yuji Hirose. All rights reserved.
//  MIT License
//
#pragma once
#ifndef CPPHTTPLIB_HTTPLIB_H
#define CPPHTTPLIB_HTTPLIB_H

#define CPPHTTPLIB_VERSION "0.17.0"

/*
 * Configuration
 */

#ifndef CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND
#define CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_KEEPALIVE_MAX_COUNT
#define CPPHTTPLIB_KEEPALIVE_MAX_COUNT 100
#endif

#ifndef CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND
#define CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND 300
#endif

#ifndef CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND
#define CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_READ_TIMEOUT_SECOND
#define CPPHTTPLIB_READ_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_READ_TIMEOUT_USECOND
#define CPPHTTPLIB_READ_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_WRITE_TIMEOUT_SECOND
#define CPPHTTPLIB_WRITE_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_WRITE_TIMEOUT_USECOND
#define CPPHTTPLIB_WRITE_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_IDLE_INTERVAL_SECOND
#define CPPHTTPLIB_IDLE_INTERVAL_SECOND 0
#endif

#ifndef CPPHTTPLIB_IDLE_INTERVAL_USECOND
#ifdef _WIN32
#define CPPHTTPLIB_IDLE_INTERVAL_USECOND 10000
#else
#define CPPHTTPLIB_IDLE_INTERVAL_USECOND 0
#endif
#endif

#ifndef CPPHTTPLIB_REQUEST_URI_MAX_LENGTH
#define CPPHTTPLIB_REQUEST_URI_MAX_LENGTH 8192
#endif

#ifndef CPPHTTPLIB_HEADER_MAX_LENGTH
#define CPPHTTPLIB_HEADER_MAX_LENGTH 8192
#endif

#ifndef CPPHTTPLIB_REDIRECT_MAX_COUNT
#define CPPHTTPLIB_REDIRECT_MAX_COUNT 20
#endif

#ifndef CPPHTTPLIB_MULTIPART_FORM_DATA_FILE_MAX_COUNT
#define CPPHTTPLIB_MULTIPART_FORM_DATA_FILE_MAX_COUNT 1024
#endif

#ifndef CPPHTTPLIB_PAYLOAD_MAX_LENGTH
#define CPPHTTPLIB_PAYLOAD_MAX_LENGTH ((std::numeric_limits<size_t>::max)())
#endif

#ifndef CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH
#define CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH 8192
#endif

#ifndef CPPHTTPLIB_RANGE_MAX_COUNT
#define CPPHTTPLIB_RANGE_MAX_COUNT 1024
#endif

#ifndef CPPHTTPLIB_TCP_NODELAY
#define CPPHTTPLIB_TCP_NODELAY false
#endif

#ifndef CPPHTTPLIB_IPV6_V6ONLY
#define CPPHTTPLIB_IPV6_V6ONLY false
#endif

#ifndef CPPHTTPLIB_RECV_BUFSIZ
#define CPPHTTPLIB_RECV_BUFSIZ size_t(16384u)
#endif

#ifndef CPPHTTPLIB_COMPRESSION_BUFSIZ
#define CPPHTTPLIB_COMPRESSION_BUFSIZ size_t(16384u)
#endif

#ifndef CPPHTTPLIB_THREAD_POOL_COUNT
#define CPPHTTPLIB_THREAD_POOL_COUNT                                           \
  ((std::max)(8u, std::thread::hardware_concurrency() > 0                      \
                      ? std::thread::hardware_concurrency() - 1                \
                      : 0))
#endif

#ifndef CPPHTTPLIB_RECV_FLAGS
#define CPPHTTPLIB_RECV_FLAGS 0
#endif

#ifndef CPPHTTPLIB_SEND_FLAGS
#define CPPHTTPLIB_SEND_FLAGS 0
#endif

#ifndef CPPHTTPLIB_LISTEN_BACKLOG
#define CPPHTTPLIB_LISTEN_BACKLOG 5
#endif

/*
 * Headers
 */

#ifdef _WIN32
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif //_CRT_SECURE_NO_WARNINGS

#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE
#endif //_CRT_NONSTDC_NO_DEPRECATE

#if defined(_MSC_VER)
#if _MSC_VER < 1900
#error Sorry, Visual Studio versions prior to 2015 are not supported
#endif

#pragma comment(lib, "ws2_32.lib")

#ifdef _WIN64
using ssize_t = __int64;
#else
using ssize_t = long;
#endif
#endif // _MSC_VER

#ifndef S_ISREG
#define S_ISREG(m) (((m) & S_IFREG) == S_IFREG)
#endif // S_ISREG

#ifndef S_ISDIR
#define S_ISDIR(m) (((m) & S_IFDIR) == S_IFDIR)
#endif // S_ISDIR

#ifndef NOMINMAX
#define NOMINMAX
#endif // NOMINMAX

#include <io.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#ifndef WSA_FLAG_NO_HANDLE_INHERIT
#define WSA_FLAG_NO_HANDLE_INHERIT 0x80
#endif

using socket_t = SOCKET;
#ifdef CPPHTTPLIB_USE_POLL
#define poll(fds, nfds, timeout) WSAPoll(fds, nfds, timeout)
#endif

#else // not _WIN32

#include <arpa/inet.h>
#if !defined(_AIX) && !defined(__MVS__)
#include <ifaddrs.h>
#endif
#ifdef __MVS__
#include <strings.h>
#ifndef NI_MAXHOST
#define NI_MAXHOST 1025
#endif
#endif
#include <net/if.h>
#include <netdb.h>
#include <netinet/in.h>
#ifdef __linux__
#include <resolv.h>
#endif
#include <netinet/tcp.h>
#ifdef CPPHTTPLIB_USE_POLL
#include <poll.h>
#endif
#include <csignal>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

using socket_t = int;
#ifndef INVALID_SOCKET
#define INVALID_SOCKET (-1)
#endif
#endif //_WIN32

#include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <cctype>
#include <climits>
#include <condition_variable>
#include <cstring>
#include <errno.h>
#include <exception>
#include <fcntl.h>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <memory>
#include <mutex>
#include <random>
#include <regex>
#include <set>
#include <sstream>
#include <string>
#include <sys/stat.h>
#include <thread>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
#ifdef _WIN32
#include <wincrypt.h>

// these are defined in wincrypt.h and it breaks compilation if BoringSSL is
// used
#undef X509_NAME
#undef X509_CERT_PAIR
#undef X509_EXTENSIONS
#undef PKCS7_SIGNER_INFO

#ifdef _MSC_VER
#pragma comment(lib, "crypt32.lib")
#endif
#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) && defined(__APPLE__)
#include <TargetConditionals.h>
#if TARGET_OS_OSX
#include <CoreFoundation/CoreFoundation.h>
#include <Security/Security.h>
#endif // TARGET_OS_OSX
#endif // _WIN32

#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#if defined(_WIN32) && defined(OPENSSL_USE_APPLINK)
#include <openssl/applink.c>
#endif

#include <iostream>
#include <sstream>

#if defined(OPENSSL_IS_BORINGSSL)
#if OPENSSL_VERSION_NUMBER < 0x1010107f
#error Please use OpenSSL or a current version of BoringSSL
#endif
#define SSL_get1_peer_certificate SSL_get_peer_certificate
#elif OPENSSL_VERSION_NUMBER < 0x30000000L
#error Sorry, OpenSSL versions prior to 3.0.0 are not supported
#endif

#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
#include <zlib.h>
#endif

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
#include <brotli/decode.h>
#include <brotli/encode.h>
#endif

/*
 * Declaration
 */
namespace httplib {

namespace detail {

/*
 * Backport std::make_unique from C++14.
 *
 * NOTE: This code came up with the following stackoverflow post:
 * https://stackoverflow.com/questions/10149840/c-arrays-and-make-unique
 *
 */

template <class T, class... Args>
typename std::enable_if<!std::is_array<T>::value, std::unique_ptr<T>>::type
make_unique(Args &&...args) {
  return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

template <class T>
typename std::enable_if<std::is_array<T>::value, std::unique_ptr<T>>::type
make_unique(std::size_t n) {
  typedef typename std::remove_extent<T>::type RT;
  return std::unique_ptr<T>(new RT[n]);
}

struct ci {
  bool operator()(const std::string &s1, const std::string &s2) const {
    return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(),
                                        s2.end(),
                                        [](unsigned char c1, unsigned char c2) {
                                          return ::tolower(c1) < ::tolower(c2);
                                        });
  }
};

// This is based on
// "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189".

struct scope_exit {
  explicit scope_exit(std::function<void(void)> &&f)
      : exit_function(std::move(f)), execute_on_destruction{true} {}

  scope_exit(scope_exit &&rhs) noexcept
      : exit_function(std::move(rhs.exit_function)),
        execute_on_destruction{rhs.execute_on_destruction} {
    rhs.release();
  }

  ~scope_exit() {
    if (execute_on_destruction) { this->exit_function(); }
  }

  void release() { this->execute_on_destruction = false; }

private:
  scope_exit(const scope_exit &) = delete;
  void operator=(const scope_exit &) = delete;
  scope_exit &operator=(scope_exit &&) = delete;

  std::function<void(void)> exit_function;
  bool execute_on_destruction;
};

} // namespace detail

enum StatusCode {
  // Information responses
  Continue_100 = 100,
  SwitchingProtocol_101 = 101,
  Processing_102 = 102,
  EarlyHints_103 = 103,

  // Successful responses
  OK_200 = 200,
  Created_201 = 201,
  Accepted_202 = 202,
  NonAuthoritativeInformation_203 = 203,
  NoContent_204 = 204,
  ResetContent_205 = 205,
  PartialContent_206 = 206,
  MultiStatus_207 = 207,
  AlreadyReported_208 = 208,
  IMUsed_226 = 226,

  // Redirection messages
  MultipleChoices_300 = 300,
  MovedPermanently_301 = 301,
  Found_302 = 302,
  SeeOther_303 = 303,
  NotModified_304 = 304,
  UseProxy_305 = 305,
  unused_306 = 306,
  TemporaryRedirect_307 = 307,
  PermanentRedirect_308 = 308,

  // Client error responses
  BadRequest_400 = 400,
  Unauthorized_401 = 401,
  PaymentRequired_402 = 402,
  Forbidden_403 = 403,
  NotFound_404 = 404,
  MethodNotAllowed_405 = 405,
  NotAcceptable_406 = 406,
  ProxyAuthenticationRequired_407 = 407,
  RequestTimeout_408 = 408,
  Conflict_409 = 409,
  Gone_410 = 410,
  LengthRequired_411 = 411,
  PreconditionFailed_412 = 412,
  PayloadTooLarge_413 = 413,
  UriTooLong_414 = 414,
  UnsupportedMediaType_415 = 415,
  RangeNotSatisfiable_416 = 416,
  ExpectationFailed_417 = 417,
  ImATeapot_418 = 418,
  MisdirectedRequest_421 = 421,
  UnprocessableContent_422 = 422,
  Locked_423 = 423,
  FailedDependency_424 = 424,
  TooEarly_425 = 425,
  UpgradeRequired_426 = 426,
  PreconditionRequired_428 = 428,
  TooManyRequests_429 = 429,
  RequestHeaderFieldsTooLarge_431 = 431,
  UnavailableForLegalReasons_451 = 451,

  // Server error responses
  InternalServerError_500 = 500,
  NotImplemented_501 = 501,
  BadGateway_502 = 502,
  ServiceUnavailable_503 = 503,
  GatewayTimeout_504 = 504,
  HttpVersionNotSupported_505 = 505,
  VariantAlsoNegotiates_506 = 506,
  InsufficientStorage_507 = 507,
  LoopDetected_508 = 508,
  NotExtended_510 = 510,
  NetworkAuthenticationRequired_511 = 511,
};

using Headers = std::multimap<std::string, std::string, detail::ci>;

using Params = std::multimap<std::string, std::string>;
using Match = std::smatch;

using Progress = std::function<bool(uint64_t current, uint64_t total)>;

struct Response;
using ResponseHandler = std::function<bool(const Response &response)>;

struct MultipartFormData {
  std::string name;
  std::string content;
  std::string filename;
  std::string content_type;
};
using MultipartFormDataItems = std::vector<MultipartFormData>;
using MultipartFormDataMap = std::multimap<std::string, MultipartFormData>;

class DataSink {
public:
  DataSink() : os(&sb_), sb_(*this) {}

  DataSink(const DataSink &) = delete;
  DataSink &operator=(const DataSink &) = delete;
  DataSink(DataSink &&) = delete;
  DataSink &operator=(DataSink &&) = delete;

  std::function<bool(const char *data, size_t data_len)> write;
  std::function<bool()> is_writable;
  std::function<void()> done;
  std::function<void(const Headers &trailer)> done_with_trailer;
  std::ostream os;

private:
  class data_sink_streambuf final : public std::streambuf {
  public:
    explicit data_sink_streambuf(DataSink &sink) : sink_(sink) {}

  protected:
    std::streamsize xsputn(const char *s, std::streamsize n) override {
      sink_.write(s, static_cast<size_t>(n));
      return n;
    }

  private:
    DataSink &sink_;
  };

  data_sink_streambuf sb_;
};

using ContentProvider =
    std::function<bool(size_t offset, size_t length, DataSink &sink)>;

using ContentProviderWithoutLength =
    std::function<bool(size_t offset, DataSink &sink)>;

using ContentProviderResourceReleaser = std::function<void(bool success)>;

struct MultipartFormDataProvider {
  std::string name;
  ContentProviderWithoutLength provider;
  std::string filename;
  std::string content_type;
};
using MultipartFormDataProviderItems = std::vector<MultipartFormDataProvider>;

using ContentReceiverWithProgress =
    std::function<bool(const char *data, size_t data_length, uint64_t offset,
                       uint64_t total_length)>;

using ContentReceiver =
    std::function<bool(const char *data, size_t data_length)>;

using MultipartContentHeader =
    std::function<bool(const MultipartFormData &file)>;

class ContentReader {
public:
  using Reader = std::function<bool(ContentReceiver receiver)>;
  using MultipartReader = std::function<bool(MultipartContentHeader header,
                                             ContentReceiver receiver)>;

  ContentReader(Reader reader, MultipartReader multipart_reader)
      : reader_(std::move(reader)),
        multipart_reader_(std::move(multipart_reader)) {}

  bool operator()(MultipartContentHeader header,
                  ContentReceiver receiver) const {
    return multipart_reader_(std::move(header), std::move(receiver));
  }

  bool operator()(ContentReceiver receiver) const {
    return reader_(std::move(receiver));
  }

  Reader reader_;
  MultipartReader multipart_reader_;
};

using Range = std::pair<ssize_t, ssize_t>;
using Ranges = std::vector<Range>;

struct Request {
  std::string method;
  std::string path;
  Headers headers;
  std::string body;

  std::string remote_addr;
  int remote_port = -1;
  std::string local_addr;
  int local_port = -1;

  // for server
  std::string version;
  std::string target;
  Params params;
  MultipartFormDataMap files;
  Ranges ranges;
  Match matches;
  std::unordered_map<std::string, std::string> path_params;

  // for client
  ResponseHandler response_handler;
  ContentReceiverWithProgress content_receiver;
  Progress progress;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  const SSL *ssl = nullptr;
#endif

  bool has_header(const std::string &key) const;
  std::string get_header_value(const std::string &key, const char *def = "",
                               size_t id = 0) const;
  uint64_t get_header_value_u64(const std::string &key, uint64_t def = 0,
                                size_t id = 0) const;
  size_t get_header_value_count(const std::string &key) const;
  void set_header(const std::string &key, const std::string &val);

  bool has_param(const std::string &key) const;
  std::string get_param_value(const std::string &key, size_t id = 0) const;
  size_t get_param_value_count(const std::string &key) const;

  bool is_multipart_form_data() const;

  bool has_file(const std::string &key) const;
  MultipartFormData get_file_value(const std::string &key) const;
  std::vector<MultipartFormData> get_file_values(const std::string &key) const;

  // private members...
  size_t redirect_count_ = CPPHTTPLIB_REDIRECT_MAX_COUNT;
  size_t content_length_ = 0;
  ContentProvider content_provider_;
  bool is_chunked_content_provider_ = false;
  size_t authorization_count_ = 0;
};

struct Response {
  std::string version;
  int status = -1;
  std::string reason;
  Headers headers;
  std::string body;
  std::string location; // Redirect location

  bool has_header(const std::string &key) const;
  std::string get_header_value(const std::string &key, const char *def = "",
                               size_t id = 0) const;
  uint64_t get_header_value_u64(const std::string &key, uint64_t def = 0,
                                size_t id = 0) const;
  size_t get_header_value_count(const std::string &key) const;
  void set_header(const std::string &key, const std::string &val);

  void set_redirect(const std::string &url, int status = StatusCode::Found_302);
  void set_content(const char *s, size_t n, const std::string &content_type);
  void set_content(const std::string &s, const std::string &content_type);
  void set_content(std::string &&s, const std::string &content_type);

  void set_content_provider(
      size_t length, const std::string &content_type, ContentProvider provider,
      ContentProviderResourceReleaser resource_releaser = nullptr);

  void set_content_provider(
      const std::string &content_type, ContentProviderWithoutLength provider,
      ContentProviderResourceReleaser resource_releaser = nullptr);

  void set_chunked_content_provider(
      const std::string &content_type, ContentProviderWithoutLength provider,
      ContentProviderResourceReleaser resource_releaser = nullptr);

  Response() = default;
  Response(const Response &) = default;
  Response &operator=(const Response &) = default;
  Response(Response &&) = default;
  Response &operator=(Response &&) = default;
  ~Response() {
    if (content_provider_resource_releaser_) {
      content_provider_resource_releaser_(content_provider_success_);
    }
  }

  // private members...
  size_t content_length_ = 0;
  ContentProvider content_provider_;
  ContentProviderResourceReleaser content_provider_resource_releaser_;
  bool is_chunked_content_provider_ = false;
  bool content_provider_success_ = false;
};

class Stream {
public:
  virtual ~Stream() = default;

  virtual bool is_readable() const = 0;
  virtual bool is_writable() const = 0;

  virtual ssize_t read(char *ptr, size_t size) = 0;
  virtual ssize_t write(const char *ptr, size_t size) = 0;
  virtual void get_remote_ip_and_port(std::string &ip, int &port) const = 0;
  virtual void get_local_ip_and_port(std::string &ip, int &port) const = 0;
  virtual socket_t socket() const = 0;

  template <typename... Args>
  ssize_t write_format(const char *fmt, const Args &...args);
  ssize_t write(const char *ptr);
  ssize_t write(const std::string &s);
};

class TaskQueue {
public:
  TaskQueue() = default;
  virtual ~TaskQueue() = default;

  virtual bool enqueue(std::function<void()> fn) = 0;
  virtual void shutdown() = 0;

  virtual void on_idle() {}
};

class ThreadPool final : public TaskQueue {
public:
  explicit ThreadPool(size_t n, size_t mqr = 0)
      : shutdown_(false), max_queued_requests_(mqr) {
    while (n) {
      threads_.emplace_back(worker(*this));
      n--;
    }
  }

  ThreadPool(const ThreadPool &) = delete;
  ~ThreadPool() override = default;

  bool enqueue(std::function<void()> fn) override {
    {
      std::unique_lock<std::mutex> lock(mutex_);
      if (max_queued_requests_ > 0 && jobs_.size() >= max_queued_requests_) {
        return false;
      }
      jobs_.push_back(std::move(fn));
    }

    cond_.notify_one();
    return true;
  }

  void shutdown() override {
    // Stop all worker threads...
    {
      std::unique_lock<std::mutex> lock(mutex_);
      shutdown_ = true;
    }

    cond_.notify_all();

    // Join...
    for (auto &t : threads_) {
      t.join();
    }
  }

private:
  struct worker {
    explicit worker(ThreadPool &pool) : pool_(pool) {}

    void operator()() {
      for (;;) {
        std::function<void()> fn;
        {
          std::unique_lock<std::mutex> lock(pool_.mutex_);

          pool_.cond_.wait(
              lock, [&] { return !pool_.jobs_.empty() || pool_.shutdown_; });

          if (pool_.shutdown_ && pool_.jobs_.empty()) { break; }

          fn = pool_.jobs_.front();
          pool_.jobs_.pop_front();
        }

        assert(true == static_cast<bool>(fn));
        fn();
      }

#if defined(CPPHTTPLIB_OPENSSL_SUPPORT) && !defined(OPENSSL_IS_BORINGSSL)
      OPENSSL_thread_stop();
#endif
    }

    ThreadPool &pool_;
  };
  friend struct worker;

  std::vector<std::thread> threads_;
  std::list<std::function<void()>> jobs_;

  bool shutdown_;
  size_t max_queued_requests_ = 0;

  std::condition_variable cond_;
  std::mutex mutex_;
};

using Logger = std::function<void(const Request &, const Response &)>;

using SocketOptions = std::function<void(socket_t sock)>;

void default_socket_options(socket_t sock);

const char *status_message(int status);

std::string get_bearer_token_auth(const Request &req);

namespace detail {

class MatcherBase {
public:
  virtual ~MatcherBase() = default;

  // Match request path and populate its matches and
  virtual bool match(Request &request) const = 0;
};

/**
 * Captures parameters in request path and stores them in Request::path_params
 *
 * Capture name is a substring of a pattern from : to /.
 * The rest of the pattern is matched agains the request path directly
 * Parameters are captured starting from the next character after
 * the end of the last matched static pattern fragment until the next /.
 *
 * Example pattern:
 * "/path/fragments/:capture/more/fragments/:second_capture"
 * Static fragments:
 * "/path/fragments/", "more/fragments/"
 *
 * Given the following request path:
 * "/path/fragments/:1/more/fragments/:2"
 * the resulting capture will be
 * {{"capture", "1"}, {"second_capture", "2"}}
 */
class PathParamsMatcher final : public MatcherBase {
public:
  PathParamsMatcher(const std::string &pattern);

  bool match(Request &request) const override;

private:
  static constexpr char marker = ':';
  // Treat segment separators as the end of path parameter capture
  // Does not need to handle query parameters as they are parsed before path
  // matching
  static constexpr char separator = '/';

  // Contains static path fragments to match against, excluding the '/' after
  // path params
  // Fragments are separated by path params
  std::vector<std::string> static_fragments_;
  // Stores the names of the path parameters to be used as keys in the
  // Request::path_params map
  std::vector<std::string> param_names_;
};

/**
 * Performs std::regex_match on request path
 * and stores the result in Request::matches
 *
 * Note that regex match is performed directly on the whole request.
 * This means that wildcard patterns may match multiple path segments with /:
 * "/begin/(.*)/end" will match both "/begin/middle/end" and "/begin/1/2/end".
 */
class RegexMatcher final : public MatcherBase {
public:
  RegexMatcher(const std::string &pattern) : regex_(pattern) {}

  bool match(Request &request) const override;

private:
  std::regex regex_;
};

ssize_t write_headers(Stream &strm, const Headers &headers);

} // namespace detail

class Server {
public:
  using Handler = std::function<void(const Request &, Response &)>;

  using ExceptionHandler =
      std::function<void(const Request &, Response &, std::exception_ptr ep)>;

  enum class HandlerResponse {
    Handled,
    Unhandled,
  };
  using HandlerWithResponse =
      std::function<HandlerResponse(const Request &, Response &)>;

  using HandlerWithContentReader = std::function<void(
      const Request &, Response &, const ContentReader &content_reader)>;

  using Expect100ContinueHandler =
      std::function<int(const Request &, Response &)>;

  Server();

  virtual ~Server();

  virtual bool is_valid() const;

  Server &Get(const std::string &pattern, Handler handler);
  Server &Post(const std::string &pattern, Handler handler);
  Server &Post(const std::string &pattern, HandlerWithContentReader handler);
  Server &Put(const std::string &pattern, Handler handler);
  Server &Put(const std::string &pattern, HandlerWithContentReader handler);
  Server &Patch(const std::string &pattern, Handler handler);
  Server &Patch(const std::string &pattern, HandlerWithContentReader handler);
  Server &Delete(const std::string &pattern, Handler handler);
  Server &Delete(const std::string &pattern, HandlerWithContentReader handler);
  Server &Options(const std::string &pattern, Handler handler);

  bool set_base_dir(const std::string &dir,
                    const std::string &mount_point = std::string());
  bool set_mount_point(const std::string &mount_point, const std::string &dir,
                       Headers headers = Headers());
  bool remove_mount_point(const std::string &mount_point);
  Server &set_file_extension_and_mimetype_mapping(const std::string &ext,
                                                  const std::string &mime);
  Server &set_default_file_mimetype(const std::string &mime);
  Server &set_file_request_handler(Handler handler);

  template <class ErrorHandlerFunc>
  Server &set_error_handler(ErrorHandlerFunc &&handler) {
    return set_error_handler_core(
        std::forward<ErrorHandlerFunc>(handler),
        std::is_convertible<ErrorHandlerFunc, HandlerWithResponse>{});
  }

  Server &set_exception_handler(ExceptionHandler handler);
  Server &set_pre_routing_handler(HandlerWithResponse handler);
  Server &set_post_routing_handler(Handler handler);

  Server &set_expect_100_continue_handler(Expect100ContinueHandler handler);
  Server &set_logger(Logger logger);

  Server &set_address_family(int family);
  Server &set_tcp_nodelay(bool on);
  Server &set_ipv6_v6only(bool on);
  Server &set_socket_options(SocketOptions socket_options);

  Server &set_default_headers(Headers headers);
  Server &
  set_header_writer(std::function<ssize_t(Stream &, Headers &)> const &writer);

  Server &set_keep_alive_max_count(size_t count);
  Server &set_keep_alive_timeout(time_t sec);

  Server &set_read_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  Server &set_read_timeout(const std::chrono::duration<Rep, Period> &duration);

  Server &set_write_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  Server &set_write_timeout(const std::chrono::duration<Rep, Period> &duration);

  Server &set_idle_interval(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  Server &set_idle_interval(const std::chrono::duration<Rep, Period> &duration);

  Server &set_payload_max_length(size_t length);

  bool bind_to_port(const std::string &host, int port, int socket_flags = 0);
  int bind_to_any_port(const std::string &host, int socket_flags = 0);
  bool listen_after_bind();

  bool listen(const std::string &host, int port, int socket_flags = 0);

  bool is_running() const;
  void wait_until_ready() const;
  void stop();
  void decommission();

  std::function<TaskQueue *(void)> new_task_queue;

protected:
  bool process_request(Stream &strm, bool close_connection,
                       bool &connection_closed,
                       const std::function<void(Request &)> &setup_request);

  std::atomic<socket_t> svr_sock_{INVALID_SOCKET};
  size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;
  time_t keep_alive_timeout_sec_ = CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND;
  time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;
  time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;
  time_t write_timeout_sec_ = CPPHTTPLIB_WRITE_TIMEOUT_SECOND;
  time_t write_timeout_usec_ = CPPHTTPLIB_WRITE_TIMEOUT_USECOND;
  time_t idle_interval_sec_ = CPPHTTPLIB_IDLE_INTERVAL_SECOND;
  time_t idle_interval_usec_ = CPPHTTPLIB_IDLE_INTERVAL_USECOND;
  size_t payload_max_length_ = CPPHTTPLIB_PAYLOAD_MAX_LENGTH;

private:
  using Handlers =
      std::vector<std::pair<std::unique_ptr<detail::MatcherBase>, Handler>>;
  using HandlersForContentReader =
      std::vector<std::pair<std::unique_ptr<detail::MatcherBase>,
                            HandlerWithContentReader>>;

  static std::unique_ptr<detail::MatcherBase>
  make_matcher(const std::string &pattern);

  Server &set_error_handler_core(HandlerWithResponse handler, std::true_type);
  Server &set_error_handler_core(Handler handler, std::false_type);

  socket_t create_server_socket(const std::string &host, int port,
                                int socket_flags,
                                SocketOptions socket_options) const;
  int bind_internal(const std::string &host, int port, int socket_flags);
  bool listen_internal();

  bool routing(Request &req, Response &res, Stream &strm);
  bool handle_file_request(const Request &req, Response &res,
                           bool head = false);
  bool dispatch_request(Request &req, Response &res,
                        const Handlers &handlers) const;
  bool dispatch_request_for_content_reader(
      Request &req, Response &res, ContentReader content_reader,
      const HandlersForContentReader &handlers) const;

  bool parse_request_line(const char *s, Request &req) const;
  void apply_ranges(const Request &req, Response &res,
                    std::string &content_type, std::string &boundary) const;
  bool write_response(Stream &strm, bool close_connection, Request &req,
                      Response &res);
  bool write_response_with_content(Stream &strm, bool close_connection,
                                   const Request &req, Response &res);
  bool write_response_core(Stream &strm, bool close_connection,
                           const Request &req, Response &res,
                           bool need_apply_ranges);
  bool write_content_with_provider(Stream &strm, const Request &req,
                                   Response &res, const std::string &boundary,
                                   const std::string &content_type);
  bool read_content(Stream &strm, Request &req, Response &res);
  bool
  read_content_with_content_receiver(Stream &strm, Request &req, Response &res,
                                     ContentReceiver receiver,
                                     MultipartContentHeader multipart_header,
                                     ContentReceiver multipart_receiver);
  bool read_content_core(Stream &strm, Request &req, Response &res,
                         ContentReceiver receiver,
                         MultipartContentHeader multipart_header,
                         ContentReceiver multipart_receiver) const;

  virtual bool process_and_close_socket(socket_t sock);

  std::atomic<bool> is_running_{false};
  std::atomic<bool> is_decommisioned{false};

  struct MountPointEntry {
    std::string mount_point;
    std::string base_dir;
    Headers headers;
  };
  std::vector<MountPointEntry> base_dirs_;
  std::map<std::string, std::string> file_extension_and_mimetype_map_;
  std::string default_file_mimetype_ = "application/octet-stream";
  Handler file_request_handler_;

  Handlers get_handlers_;
  Handlers post_handlers_;
  HandlersForContentReader post_handlers_for_content_reader_;
  Handlers put_handlers_;
  HandlersForContentReader put_handlers_for_content_reader_;
  Handlers patch_handlers_;
  HandlersForContentReader patch_handlers_for_content_reader_;
  Handlers delete_handlers_;
  HandlersForContentReader delete_handlers_for_content_reader_;
  Handlers options_handlers_;

  HandlerWithResponse error_handler_;
  ExceptionHandler exception_handler_;
  HandlerWithResponse pre_routing_handler_;
  Handler post_routing_handler_;
  Expect100ContinueHandler expect_100_continue_handler_;

  Logger logger_;

  int address_family_ = AF_UNSPEC;
  bool tcp_nodelay_ = CPPHTTPLIB_TCP_NODELAY;
  bool ipv6_v6only_ = CPPHTTPLIB_IPV6_V6ONLY;
  SocketOptions socket_options_ = default_socket_options;

  Headers default_headers_;
  std::function<ssize_t(Stream &, Headers &)> header_writer_ =
      detail::write_headers;
};

enum class Error {
  Success = 0,
  Unknown,
  Connection,
  BindIPAddress,
  Read,
  Write,
  ExceedRedirectCount,
  Canceled,
  SSLConnection,
  SSLLoadingCerts,
  SSLServerVerification,
  UnsupportedMultipartBoundaryChars,
  Compression,
  ConnectionTimeout,
  ProxyConnection,

  // For internal use only
  SSLPeerCouldBeClosed_,
};

std::string to_string(Error error);

std::ostream &operator<<(std::ostream &os, const Error &obj);

class Result {
public:
  Result() = default;
  Result(std::unique_ptr<Response> &&res, Error err,
         Headers &&request_headers = Headers{})
      : res_(std::move(res)), err_(err),
        request_headers_(std::move(request_headers)) {}
  // Response
  operator bool() const { return res_ != nullptr; }
  bool operator==(std::nullptr_t) const { return res_ == nullptr; }
  bool operator!=(std::nullptr_t) const { return res_ != nullptr; }
  const Response &value() const { return *res_; }
  Response &value() { return *res_; }
  const Response &operator*() const { return *res_; }
  Response &operator*() { return *res_; }
  const Response *operator->() const { return res_.get(); }
  Response *operator->() { return res_.get(); }

  // Error
  Error error() const { return err_; }

  // Request Headers
  bool has_request_header(const std::string &key) const;
  std::string get_request_header_value(const std::string &key,
                                       const char *def = "",
                                       size_t id = 0) const;
  uint64_t get_request_header_value_u64(const std::string &key,
                                        uint64_t def = 0, size_t id = 0) const;
  size_t get_request_header_value_count(const std::string &key) const;

private:
  std::unique_ptr<Response> res_;
  Error err_ = Error::Unknown;
  Headers request_headers_;
};

class ClientImpl {
public:
  explicit ClientImpl(const std::string &host);

  explicit ClientImpl(const std::string &host, int port);

  explicit ClientImpl(const std::string &host, int port,
                      const std::string &client_cert_path,
                      const std::string &client_key_path);

  virtual ~ClientImpl();

  virtual bool is_valid() const;

  Result Get(const std::string &path);
  Result Get(const std::string &path, const Headers &headers);
  Result Get(const std::string &path, Progress progress);
  Result Get(const std::string &path, const Headers &headers,
             Progress progress);
  Result Get(const std::string &path, ContentReceiver content_receiver);
  Result Get(const std::string &path, const Headers &headers,
             ContentReceiver content_receiver);
  Result Get(const std::string &path, ContentReceiver content_receiver,
             Progress progress);
  Result Get(const std::string &path, const Headers &headers,
             ContentReceiver content_receiver, Progress progress);
  Result Get(const std::string &path, ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &path, const Headers &headers,
             ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &path, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress);
  Result Get(const std::string &path, const Headers &headers,
             ResponseHandler response_handler, ContentReceiver content_receiver,
             Progress progress);

  Result Get(const std::string &path, const Params &params,
             const Headers &headers, Progress progress = nullptr);
  Result Get(const std::string &path, const Params &params,
             const Headers &headers, ContentReceiver content_receiver,
             Progress progress = nullptr);
  Result Get(const std::string &path, const Params &params,
             const Headers &headers, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress = nullptr);

  Result Head(const std::string &path);
  Result Head(const std::string &path, const Headers &headers);

  Result Post(const std::string &path);
  Result Post(const std::string &path, const Headers &headers);
  Result Post(const std::string &path, const char *body, size_t content_length,
              const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers, const char *body,
              size_t content_length, const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers, const char *body,
              size_t content_length, const std::string &content_type,
              Progress progress);
  Result Post(const std::string &path, const std::string &body,
              const std::string &content_type);
  Result Post(const std::string &path, const std::string &body,
              const std::string &content_type, Progress progress);
  Result Post(const std::string &path, const Headers &headers,
              const std::string &body, const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers,
              const std::string &body, const std::string &content_type,
              Progress progress);
  Result Post(const std::string &path, size_t content_length,
              ContentProvider content_provider,
              const std::string &content_type);
  Result Post(const std::string &path,
              ContentProviderWithoutLength content_provider,
              const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers,
              size_t content_length, ContentProvider content_provider,
              const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers,
              ContentProviderWithoutLength content_provider,
              const std::string &content_type);
  Result Post(const std::string &path, const Params &params);
  Result Post(const std::string &path, const Headers &headers,
              const Params &params);
  Result Post(const std::string &path, const Headers &headers,
              const Params &params, Progress progress);
  Result Post(const std::string &path, const MultipartFormDataItems &items);
  Result Post(const std::string &path, const Headers &headers,
              const MultipartFormDataItems &items);
  Result Post(const std::string &path, const Headers &headers,
              const MultipartFormDataItems &items, const std::string &boundary);
  Result Post(const std::string &path, const Headers &headers,
              const MultipartFormDataItems &items,
              const MultipartFormDataProviderItems &provider_items);

  Result Put(const std::string &path);
  Result Put(const std::string &path, const char *body, size_t content_length,
             const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers, const char *body,
             size_t content_length, const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers, const char *body,
             size_t content_length, const std::string &content_type,
             Progress progress);
  Result Put(const std::string &path, const std::string &body,
             const std::string &content_type);
  Result Put(const std::string &path, const std::string &body,
             const std::string &content_type, Progress progress);
  Result Put(const std::string &path, const Headers &headers,
             const std::string &body, const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers,
             const std::string &body, const std::string &content_type,
             Progress progress);
  Result Put(const std::string &path, size_t content_length,
             ContentProvider content_provider, const std::string &content_type);
  Result Put(const std::string &path,
             ContentProviderWithoutLength content_provider,
             const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers,
             size_t content_length, ContentProvider content_provider,
             const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers,
             ContentProviderWithoutLength content_provider,
             const std::string &content_type);
  Result Put(const std::string &path, const Params &params);
  Result Put(const std::string &path, const Headers &headers,
             const Params &params);
  Result Put(const std::string &path, const Headers &headers,
             const Params &params, Progress progress);
  Result Put(const std::string &path, const MultipartFormDataItems &items);
  Result Put(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items);
  Result Put(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items, const std::string &boundary);
  Result Put(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items,
             const MultipartFormDataProviderItems &provider_items);

  Result Patch(const std::string &path);
  Result Patch(const std::string &path, const char *body, size_t content_length,
               const std::string &content_type);
  Result Patch(const std::string &path, const char *body, size_t content_length,
               const std::string &content_type, Progress progress);
  Result Patch(const std::string &path, const Headers &headers,
               const char *body, size_t content_length,
               const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               const char *body, size_t content_length,
               const std::string &content_type, Progress progress);
  Result Patch(const std::string &path, const std::string &body,
               const std::string &content_type);
  Result Patch(const std::string &path, const std::string &body,
               const std::string &content_type, Progress progress);
  Result Patch(const std::string &path, const Headers &headers,
               const std::string &body, const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               const std::string &body, const std::string &content_type,
               Progress progress);
  Result Patch(const std::string &path, size_t content_length,
               ContentProvider content_provider,
               const std::string &content_type);
  Result Patch(const std::string &path,
               ContentProviderWithoutLength content_provider,
               const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               size_t content_length, ContentProvider content_provider,
               const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               ContentProviderWithoutLength content_provider,
               const std::string &content_type);

  Result Delete(const std::string &path);
  Result Delete(const std::string &path, const Headers &headers);
  Result Delete(const std::string &path, const char *body,
                size_t content_length, const std::string &content_type);
  Result Delete(const std::string &path, const char *body,
                size_t content_length, const std::string &content_type,
                Progress progress);
  Result Delete(const std::string &path, const Headers &headers,
                const char *body, size_t content_length,
                const std::string &content_type);
  Result Delete(const std::string &path, const Headers &headers,
                const char *body, size_t content_length,
                const std::string &content_type, Progress progress);
  Result Delete(const std::string &path, const std::string &body,
                const std::string &content_type);
  Result Delete(const std::string &path, const std::string &body,
                const std::string &content_type, Progress progress);
  Result Delete(const std::string &path, const Headers &headers,
                const std::string &body, const std::string &content_type);
  Result Delete(const std::string &path, const Headers &headers,
                const std::string &body, const std::string &content_type,
                Progress progress);

  Result Options(const std::string &path);
  Result Options(const std::string &path, const Headers &headers);

  bool send(Request &req, Response &res, Error &error);
  Result send(const Request &req);

  void stop();

  std::string host() const;
  int port() const;

  size_t is_socket_open() const;
  socket_t socket() const;

  void set_hostname_addr_map(std::map<std::string, std::string> addr_map);

  void set_default_headers(Headers headers);

  void
  set_header_writer(std::function<ssize_t(Stream &, Headers &)> const &writer);

  void set_address_family(int family);
  void set_tcp_nodelay(bool on);
  void set_ipv6_v6only(bool on);
  void set_socket_options(SocketOptions socket_options);

  void set_connection_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  void
  set_connection_timeout(const std::chrono::duration<Rep, Period> &duration);

  void set_read_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  void set_read_timeout(const std::chrono::duration<Rep, Period> &duration);

  void set_write_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  void set_write_timeout(const std::chrono::duration<Rep, Period> &duration);

  void set_basic_auth(const std::string &username, const std::string &password);
  void set_bearer_token_auth(const std::string &token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_digest_auth(const std::string &username,
                       const std::string &password);
#endif

  void set_keep_alive(bool on);
  void set_follow_location(bool on);

  void set_url_encode(bool on);

  void set_compress(bool on);

  void set_decompress(bool on);

  void set_interface(const std::string &intf);

  void set_proxy(const std::string &host, int port);
  void set_proxy_basic_auth(const std::string &username,
                            const std::string &password);
  void set_proxy_bearer_token_auth(const std::string &token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_proxy_digest_auth(const std::string &username,
                             const std::string &password);
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_ca_cert_path(const std::string &ca_cert_file_path,
                        const std::string &ca_cert_dir_path = std::string());
  void set_ca_cert_store(X509_STORE *ca_cert_store);
  X509_STORE *create_ca_cert_store(const char *ca_cert, std::size_t size) const;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void enable_server_certificate_verification(bool enabled);
#endif

  void set_logger(Logger logger);

protected:
  struct Socket {
    socket_t sock = INVALID_SOCKET;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    SSL *ssl = nullptr;
#endif

    bool is_open() const { return sock != INVALID_SOCKET; }
  };

  virtual bool create_and_connect_socket(Socket &socket, Error &error);

  // All of:
  //   shutdown_ssl
  //   shutdown_socket
  //   close_socket
  // should ONLY be called when socket_mutex_ is locked.
  // Also, shutdown_ssl and close_socket should also NOT be called concurrently
  // with a DIFFERENT thread sending requests using that socket.
  virtual void shutdown_ssl(Socket &socket, bool shutdown_gracefully);
  void shutdown_socket(Socket &socket) const;
  void close_socket(Socket &socket);

  bool process_request(Stream &strm, Request &req, Response &res,
                       bool close_connection, Error &error);

  bool write_content_with_provider(Stream &strm, const Request &req,
                                   Error &error) const;

  void copy_settings(const ClientImpl &rhs);

  // Socket endpoint information
  const std::string host_;
  const int port_;
  const std::string host_and_port_;

  // Current open socket
  Socket socket_;
  mutable std::mutex socket_mutex_;
  std::recursive_mutex request_mutex_;

  // These are all protected under socket_mutex
  size_t socket_requests_in_flight_ = 0;
  std::thread::id socket_requests_are_from_thread_ = std::thread::id();
  bool socket_should_be_closed_when_request_is_done_ = false;

  // Hostname-IP map
  std::map<std::string, std::string> addr_map_;

  // Default headers
  Headers default_headers_;

  // Header writer
  std::function<ssize_t(Stream &, Headers &)> header_writer_ =
      detail::write_headers;

  // Settings
  std::string client_cert_path_;
  std::string client_key_path_;

  time_t connection_timeout_sec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND;
  time_t connection_timeout_usec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND;
  time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;
  time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;
  time_t write_timeout_sec_ = CPPHTTPLIB_WRITE_TIMEOUT_SECOND;
  time_t write_timeout_usec_ = CPPHTTPLIB_WRITE_TIMEOUT_USECOND;

  std::string basic_auth_username_;
  std::string basic_auth_password_;
  std::string bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  std::string digest_auth_username_;
  std::string digest_auth_password_;
#endif

  bool keep_alive_ = false;
  bool follow_location_ = false;

  bool url_encode_ = true;

  int address_family_ = AF_UNSPEC;
  bool tcp_nodelay_ = CPPHTTPLIB_TCP_NODELAY;
  bool ipv6_v6only_ = CPPHTTPLIB_IPV6_V6ONLY;
  SocketOptions socket_options_ = nullptr;

  bool compress_ = false;
  bool decompress_ = true;

  std::string interface_;

  std::string proxy_host_;
  int proxy_port_ = -1;

  std::string proxy_basic_auth_username_;
  std::string proxy_basic_auth_password_;
  std::string proxy_bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  std::string proxy_digest_auth_username_;
  std::string proxy_digest_auth_password_;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  std::string ca_cert_file_path_;
  std::string ca_cert_dir_path_;

  X509_STORE *ca_cert_store_ = nullptr;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  bool server_certificate_verification_ = true;
#endif

  Logger logger_;

private:
  bool send_(Request &req, Response &res, Error &error);
  Result send_(Request &&req);

  socket_t create_client_socket(Error &error) const;
  bool read_response_line(Stream &strm, const Request &req,
                          Response &res) const;
  bool write_request(Stream &strm, Request &req, bool close_connection,
                     Error &error);
  bool redirect(Request &req, Response &res, Error &error);
  bool handle_request(Stream &strm, Request &req, Response &res,
                      bool close_connection, Error &error);
  std::unique_ptr<Response> send_with_content_provider(
      Request &req, const char *body, size_t content_length,
      ContentProvider content_provider,
      ContentProviderWithoutLength content_provider_without_length,
      const std::string &content_type, Error &error);
  Result send_with_content_provider(
      const std::string &method, const std::string &path,
      const Headers &headers, const char *body, size_t content_length,
      ContentProvider content_provider,
      ContentProviderWithoutLength content_provider_without_length,
      const std::string &content_type, Progress progress);
  ContentProviderWithoutLength get_multipart_content_provider(
      const std::string &boundary, const MultipartFormDataItems &items,
      const MultipartFormDataProviderItems &provider_items) const;

  std::string adjust_host_string(const std::string &host) const;

  virtual bool process_socket(const Socket &socket,
                              std::function<bool(Stream &strm)> callback);
  virtual bool is_ssl() const;
};

class Client {
public:
  // Universal interface
  explicit Client(const std::string &scheme_host_port);

  explicit Client(const std::string &scheme_host_port,
                  const std::string &client_cert_path,
                  const std::string &client_key_path);

  // HTTP only interface
  explicit Client(const std::string &host, int port);

  explicit Client(const std::string &host, int port,
                  const std::string &client_cert_path,
                  const std::string &client_key_path);

  Client(Client &&) = default;
  Client &operator=(Client &&) = default;

  ~Client();

  bool is_valid() const;

  Result Get(const std::string &path);
  Result Get(const std::string &path, const Headers &headers);
  Result Get(const std::string &path, Progress progress);
  Result Get(const std::string &path, const Headers &headers,
             Progress progress);
  Result Get(const std::string &path, ContentReceiver content_receiver);
  Result Get(const std::string &path, const Headers &headers,
             ContentReceiver content_receiver);
  Result Get(const std::string &path, ContentReceiver content_receiver,
             Progress progress);
  Result Get(const std::string &path, const Headers &headers,
             ContentReceiver content_receiver, Progress progress);
  Result Get(const std::string &path, ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &path, const Headers &headers,
             ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &path, const Headers &headers,
             ResponseHandler response_handler, ContentReceiver content_receiver,
             Progress progress);
  Result Get(const std::string &path, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress);

  Result Get(const std::string &path, const Params &params,
             const Headers &headers, Progress progress = nullptr);
  Result Get(const std::string &path, const Params &params,
             const Headers &headers, ContentReceiver content_receiver,
             Progress progress = nullptr);
  Result Get(const std::string &path, const Params &params,
             const Headers &headers, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress = nullptr);

  Result Head(const std::string &path);
  Result Head(const std::string &path, const Headers &headers);

  Result Post(const std::string &path);
  Result Post(const std::string &path, const Headers &headers);
  Result Post(const std::string &path, const char *body, size_t content_length,
              const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers, const char *body,
              size_t content_length, const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers, const char *body,
              size_t content_length, const std::string &content_type,
              Progress progress);
  Result Post(const std::string &path, const std::string &body,
              const std::string &content_type);
  Result Post(const std::string &path, const std::string &body,
              const std::string &content_type, Progress progress);
  Result Post(const std::string &path, const Headers &headers,
              const std::string &body, const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers,
              const std::string &body, const std::string &content_type,
              Progress progress);
  Result Post(const std::string &path, size_t content_length,
              ContentProvider content_provider,
              const std::string &content_type);
  Result Post(const std::string &path,
              ContentProviderWithoutLength content_provider,
              const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers,
              size_t content_length, ContentProvider content_provider,
              const std::string &content_type);
  Result Post(const std::string &path, const Headers &headers,
              ContentProviderWithoutLength content_provider,
              const std::string &content_type);
  Result Post(const std::string &path, const Params &params);
  Result Post(const std::string &path, const Headers &headers,
              const Params &params);
  Result Post(const std::string &path, const Headers &headers,
              const Params &params, Progress progress);
  Result Post(const std::string &path, const MultipartFormDataItems &items);
  Result Post(const std::string &path, const Headers &headers,
              const MultipartFormDataItems &items);
  Result Post(const std::string &path, const Headers &headers,
              const MultipartFormDataItems &items, const std::string &boundary);
  Result Post(const std::string &path, const Headers &headers,
              const MultipartFormDataItems &items,
              const MultipartFormDataProviderItems &provider_items);

  Result Put(const std::string &path);
  Result Put(const std::string &path, const char *body, size_t content_length,
             const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers, const char *body,
             size_t content_length, const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers, const char *body,
             size_t content_length, const std::string &content_type,
             Progress progress);
  Result Put(const std::string &path, const std::string &body,
             const std::string &content_type);
  Result Put(const std::string &path, const std::string &body,
             const std::string &content_type, Progress progress);
  Result Put(const std::string &path, const Headers &headers,
             const std::string &body, const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers,
             const std::string &body, const std::string &content_type,
             Progress progress);
  Result Put(const std::string &path, size_t content_length,
             ContentProvider content_provider, const std::string &content_type);
  Result Put(const std::string &path,
             ContentProviderWithoutLength content_provider,
             const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers,
             size_t content_length, ContentProvider content_provider,
             const std::string &content_type);
  Result Put(const std::string &path, const Headers &headers,
             ContentProviderWithoutLength content_provider,
             const std::string &content_type);
  Result Put(const std::string &path, const Params &params);
  Result Put(const std::string &path, const Headers &headers,
             const Params &params);
  Result Put(const std::string &path, const Headers &headers,
             const Params &params, Progress progress);
  Result Put(const std::string &path, const MultipartFormDataItems &items);
  Result Put(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items);
  Result Put(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items, const std::string &boundary);
  Result Put(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items,
             const MultipartFormDataProviderItems &provider_items);

  Result Patch(const std::string &path);
  Result Patch(const std::string &path, const char *body, size_t content_length,
               const std::string &content_type);
  Result Patch(const std::string &path, const char *body, size_t content_length,
               const std::string &content_type, Progress progress);
  Result Patch(const std::string &path, const Headers &headers,
               const char *body, size_t content_length,
               const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               const char *body, size_t content_length,
               const std::string &content_type, Progress progress);
  Result Patch(const std::string &path, const std::string &body,
               const std::string &content_type);
  Result Patch(const std::string &path, const std::string &body,
               const std::string &content_type, Progress progress);
  Result Patch(const std::string &path, const Headers &headers,
               const std::string &body, const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               const std::string &body, const std::string &content_type,
               Progress progress);
  Result Patch(const std::string &path, size_t content_length,
               ContentProvider content_provider,
               const std::string &content_type);
  Result Patch(const std::string &path,
               ContentProviderWithoutLength content_provider,
               const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               size_t content_length, ContentProvider content_provider,
               const std::string &content_type);
  Result Patch(const std::string &path, const Headers &headers,
               ContentProviderWithoutLength content_provider,
               const std::string &content_type);

  Result Delete(const std::string &path);
  Result Delete(const std::string &path, const Headers &headers);
  Result Delete(const std::string &path, const char *body,
                size_t content_length, const std::string &content_type);
  Result Delete(const std::string &path, const char *body,
                size_t content_length, const std::string &content_type,
                Progress progress);
  Result Delete(const std::string &path, const Headers &headers,
                const char *body, size_t content_length,
                const std::string &content_type);
  Result Delete(const std::string &path, const Headers &headers,
                const char *body, size_t content_length,
                const std::string &content_type, Progress progress);
  Result Delete(const std::string &path, const std::string &body,
                const std::string &content_type);
  Result Delete(const std::string &path, const std::string &body,
                const std::string &content_type, Progress progress);
  Result Delete(const std::string &path, const Headers &headers,
                const std::string &body, const std::string &content_type);
  Result Delete(const std::string &path, const Headers &headers,
                const std::string &body, const std::string &content_type,
                Progress progress);

  Result Options(const std::string &path);
  Result Options(const std::string &path, const Headers &headers);

  bool send(Request &req, Response &res, Error &error);
  Result send(const Request &req);

  void stop();

  std::string host() const;
  int port() const;

  size_t is_socket_open() const;
  socket_t socket() const;

  void set_hostname_addr_map(std::map<std::string, std::string> addr_map);

  void set_default_headers(Headers headers);

  void
  set_header_writer(std::function<ssize_t(Stream &, Headers &)> const &writer);

  void set_address_family(int family);
  void set_tcp_nodelay(bool on);
  void set_socket_options(SocketOptions socket_options);

  void set_connection_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  void
  set_connection_timeout(const std::chrono::duration<Rep, Period> &duration);

  void set_read_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  void set_read_timeout(const std::chrono::duration<Rep, Period> &duration);

  void set_write_timeout(time_t sec, time_t usec = 0);
  template <class Rep, class Period>
  void set_write_timeout(const std::chrono::duration<Rep, Period> &duration);

  void set_basic_auth(const std::string &username, const std::string &password);
  void set_bearer_token_auth(const std::string &token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_digest_auth(const std::string &username,
                       const std::string &password);
#endif

  void set_keep_alive(bool on);
  void set_follow_location(bool on);

  void set_url_encode(bool on);

  void set_compress(bool on);

  void set_decompress(bool on);

  void set_interface(const std::string &intf);

  void set_proxy(const std::string &host, int port);
  void set_proxy_basic_auth(const std::string &username,
                            const std::string &password);
  void set_proxy_bearer_token_auth(const std::string &token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_proxy_digest_auth(const std::string &username,
                             const std::string &password);
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void enable_server_certificate_verification(bool enabled);
#endif

  void set_logger(Logger logger);

  // SSL
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_ca_cert_path(const std::string &ca_cert_file_path,
                        const std::string &ca_cert_dir_path = std::string());

  void set_ca_cert_store(X509_STORE *ca_cert_store);
  void load_ca_cert_store(const char *ca_cert, std::size_t size);

  long get_openssl_verify_result() const;

  SSL_CTX *ssl_context() const;
#endif

private:
  std::unique_ptr<ClientImpl> cli_;

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  bool is_ssl_ = false;
#endif
};

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
class SSLServer : public Server {
public:
  SSLServer(const char *cert_path, const char *private_key_path,
            const char *client_ca_cert_file_path = nullptr,
            const char *client_ca_cert_dir_path = nullptr,
            const char *private_key_password = nullptr);

  SSLServer(X509 *cert, EVP_PKEY *private_key,
            X509_STORE *client_ca_cert_store = nullptr);

  SSLServer(
      const std::function<bool(SSL_CTX &ssl_ctx)> &setup_ssl_ctx_callback);

  ~SSLServer() override;

  bool is_valid() const override;

  SSL_CTX *ssl_context() const;

  void update_certs(X509 *cert, EVP_PKEY *private_key,
                    X509_STORE *client_ca_cert_store = nullptr);

private:
  bool process_and_close_socket(socket_t sock) override;

  SSL_CTX *ctx_;
  std::mutex ctx_mutex_;
};

class SSLClient final : public ClientImpl {
public:
  explicit SSLClient(const std::string &host);

  explicit SSLClient(const std::string &host, int port);

  explicit SSLClient(const std::string &host, int port,
                     const std::string &client_cert_path,
                     const std::string &client_key_path,
                     const std::string &private_key_password = std::string());

  explicit SSLClient(const std::string &host, int port, X509 *client_cert,
                     EVP_PKEY *client_key,
                     const std::string &private_key_password = std::string());

  ~SSLClient() override;

  bool is_valid() const override;

  void set_ca_cert_store(X509_STORE *ca_cert_store);
  void load_ca_cert_store(const char *ca_cert, std::size_t size);

  long get_openssl_verify_result() const;

  SSL_CTX *ssl_context() const;

private:
  bool create_and_connect_socket(Socket &socket, Error &error) override;
  void shutdown_ssl(Socket &socket, bool shutdown_gracefully) override;
  void shutdown_ssl_impl(Socket &socket, bool shutdown_gracefully);

  bool process_socket(const Socket &socket,
                      std::function<bool(Stream &strm)> callback) override;
  bool is_ssl() const override;

  bool connect_with_proxy(Socket &sock, Response &res, bool &success,
                          Error &error);
  bool initialize_ssl(Socket &socket, Error &error);

  bool load_certs();

  bool verify_host(X509 *server_cert) const;
  bool verify_host_with_subject_alt_name(X509 *server_cert) const;
  bool verify_host_with_common_name(X509 *server_cert) const;
  bool check_host_name(const char *pattern, size_t pattern_len) const;

  SSL_CTX *ctx_;
  std::mutex ctx_mutex_;
  std::once_flag initialize_cert_;

  std::vector<std::string> host_components_;

  long verify_result_ = 0;

  friend class ClientImpl;
};
#endif

/*
 * Implementation of template methods.
 */

namespace detail {

template <typename T, typename U>
inline void duration_to_sec_and_usec(const T &duration, U callback) {
  auto sec = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
  auto usec = std::chrono::duration_cast<std::chrono::microseconds>(
                  duration - std::chrono::seconds(sec))
                  .count();
  callback(static_cast<time_t>(sec), static_cast<time_t>(usec));
}

inline uint64_t get_header_value_u64(const Headers &headers,
                                     const std::string &key, uint64_t def,
                                     size_t id) {
  auto rng = headers.equal_range(key);
  auto it = rng.first;
  std::advance(it, static_cast<ssize_t>(id));
  if (it != rng.second) {
    return std::strtoull(it->second.data(), nullptr, 10);
  }
  return def;
}

} // namespace detail

inline uint64_t Request::get_header_value_u64(const std::string &key,
                                              uint64_t def, size_t id) const {
  return detail::get_header_value_u64(headers, key, def, id);
}

inline uint64_t Response::get_header_value_u64(const std::string &key,
                                               uint64_t def, size_t id) const {
  return detail::get_header_value_u64(headers, key, def, id);
}

template <typename... Args>
inline ssize_t Stream::write_format(const char *fmt, const Args &...args) {
  const auto bufsiz = 2048;
  std::array<char, bufsiz> buf{};

  auto sn = snprintf(buf.data(), buf.size() - 1, fmt, args...);
  if (sn <= 0) { return sn; }

  auto n = static_cast<size_t>(sn);

  if (n >= buf.size() - 1) {
    std::vector<char> glowable_buf(buf.size());

    while (n >= glowable_buf.size() - 1) {
      glowable_buf.resize(glowable_buf.size() * 2);
      n = static_cast<size_t>(
          snprintf(&glowable_buf[0], glowable_buf.size() - 1, fmt, args...));
    }
    return write(&glowable_buf[0], n);
  } else {
    return write(buf.data(), n);
  }
}

inline void default_socket_options(socket_t sock) {
  int opt = 1;
#ifdef _WIN32
  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
             reinterpret_cast<const char *>(&opt), sizeof(opt));
  setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,
             reinterpret_cast<const char *>(&opt), sizeof(opt));
#else
#ifdef SO_REUSEPORT
  setsockopt(sock, SOL_SOCKET, SO_REUSEPORT,
             reinterpret_cast<const void *>(&opt), sizeof(opt));
#else
  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
             reinterpret_cast<const void *>(&opt), sizeof(opt));
#endif
#endif
}

inline const char *status_message(int status) {
  switch (status) {
  case StatusCode::Continue_100: return "Continue";
  case StatusCode::SwitchingProtocol_101: return "Switching Protocol";
  case StatusCode::Processing_102: return "Processing";
  case StatusCode::EarlyHints_103: return "Early Hints";
  case StatusCode::OK_200: return "OK";
  case StatusCode::Created_201: return "Created";
  case StatusCode::Accepted_202: return "Accepted";
  case StatusCode::NonAuthoritativeInformation_203:
    return "Non-Authoritative Information";
  case StatusCode::NoContent_204: return "No Content";
  case StatusCode::ResetContent_205: return "Reset Content";
  case StatusCode::PartialContent_206: return "Partial Content";
  case StatusCode::MultiStatus_207: return "Multi-Status";
  case StatusCode::AlreadyReported_208: return "Already Reported";
  case StatusCode::IMUsed_226: return "IM Used";
  case StatusCode::MultipleChoices_300: return "Multiple Choices";
  case StatusCode::MovedPermanently_301: return "Moved Permanently";
  case StatusCode::Found_302: return "Found";
  case StatusCode::SeeOther_303: return "See Other";
  case StatusCode::NotModified_304: return "Not Modified";
  case StatusCode::UseProxy_305: return "Use Proxy";
  case StatusCode::unused_306: return "unused";
  case StatusCode::TemporaryRedirect_307: return "Temporary Redirect";
  case StatusCode::PermanentRedirect_308: return "Permanent Redirect";
  case StatusCode::BadRequest_400: return "Bad Request";
  case StatusCode::Unauthorized_401: return "Unauthorized";
  case StatusCode::PaymentRequired_402: return "Payment Required";
  case StatusCode::Forbidden_403: return "Forbidden";
  case StatusCode::NotFound_404: return "Not Found";
  case StatusCode::MethodNotAllowed_405: return "Method Not Allowed";
  case StatusCode::NotAcceptable_406: return "Not Acceptable";
  case StatusCode::ProxyAuthenticationRequired_407:
    return "Proxy Authentication Required";
  case StatusCode::RequestTimeout_408: return "Request Timeout";
  case StatusCode::Conflict_409: return "Conflict";
  case StatusCode::Gone_410: return "Gone";
  case StatusCode::LengthRequired_411: return "Length Required";
  case StatusCode::PreconditionFailed_412: return "Precondition Failed";
  case StatusCode::PayloadTooLarge_413: return "Payload Too Large";
  case StatusCode::UriTooLong_414: return "URI Too Long";
  case StatusCode::UnsupportedMediaType_415: return "Unsupported Media Type";
  case StatusCode::RangeNotSatisfiable_416: return "Range Not Satisfiable";
  case StatusCode::ExpectationFailed_417: return "Expectation Failed";
  case StatusCode::ImATeapot_418: return "I'm a teapot";
  case StatusCode::MisdirectedRequest_421: return "Misdirected Request";
  case StatusCode::UnprocessableContent_422: return "Unprocessable Content";
  case StatusCode::Locked_423: return "Locked";
  case StatusCode::FailedDependency_424: return "Failed Dependency";
  case StatusCode::TooEarly_425: return "Too Early";
  case StatusCode::UpgradeRequired_426: return "Upgrade Required";
  case StatusCode::PreconditionRequired_428: return "Precondition Required";
  case StatusCode::TooManyRequests_429: return "Too Many Requests";
  case StatusCode::RequestHeaderFieldsTooLarge_431:
    return "Request Header Fields Too Large";
  case StatusCode::UnavailableForLegalReasons_451:
    return "Unavailable For Legal Reasons";
  case StatusCode::NotImplemented_501: return "Not Implemented";
  case StatusCode::BadGateway_502: return "Bad Gateway";
  case StatusCode::ServiceUnavailable_503: return "Service Unavailable";
  case StatusCode::GatewayTimeout_504: return "Gateway Timeout";
  case StatusCode::HttpVersionNotSupported_505:
    return "HTTP Version Not Supported";
  case StatusCode::VariantAlsoNegotiates_506: return "Variant Also Negotiates";
  case StatusCode::InsufficientStorage_507: return "Insufficient Storage";
  case StatusCode::LoopDetected_508: return "Loop Detected";
  case StatusCode::NotExtended_510: return "Not Extended";
  case StatusCode::NetworkAuthenticationRequired_511:
    return "Network Authentication Required";

  default:
  case StatusCode::InternalServerError_500: return "Internal Server Error";
  }
}

inline std::string get_bearer_token_auth(const Request &req) {
  if (req.has_header("Authorization")) {
    static std::string BearerHeaderPrefix = "Bearer ";
    return req.get_header_value("Authorization")
        .substr(BearerHeaderPrefix.length());
  }
  return "";
}

template <class Rep, class Period>
inline Server &
Server::set_read_timeout(const std::chrono::duration<Rep, Period> &duration) {
  detail::duration_to_sec_and_usec(
      duration, [&](time_t sec, time_t usec) { set_read_timeout(sec, usec); });
  return *this;
}

template <class Rep, class Period>
inline Server &
Server::set_write_timeout(const std::chrono::duration<Rep, Period> &duration) {
  detail::duration_to_sec_and_usec(
      duration, [&](time_t sec, time_t usec) { set_write_timeout(sec, usec); });
  return *this;
}

template <class Rep, class Period>
inline Server &
Server::set_idle_interval(const std::chrono::duration<Rep, Period> &duration) {
  detail::duration_to_sec_and_usec(
      duration, [&](time_t sec, time_t usec) { set_idle_interval(sec, usec); });
  return *this;
}

inline std::string to_string(const Error error) {
  switch (error) {
  case Error::Success: return "Success (no error)";
  case Error::Connection: return "Could not establish connection";
  case Error::BindIPAddress: return "Failed to bind IP address";
  case Error::Read: return "Failed to read connection";
  case Error::Write: return "Failed to write connection";
  case Error::ExceedRedirectCount: return "Maximum redirect count exceeded";
  case Error::Canceled: return "Connection handling canceled";
  case Error::SSLConnection: return "SSL connection failed";
  case Error::SSLLoadingCerts: return "SSL certificate loading failed";
  case Error::SSLServerVerification: return "SSL server verification failed";
  case Error::UnsupportedMultipartBoundaryChars:
    return "Unsupported HTTP multipart boundary characters";
  case Error::Compression: return "Compression failed";
  case Error::ConnectionTimeout: return "Connection timed out";
  case Error::ProxyConnection: return "Proxy connection failed";
  case Error::Unknown: return "Unknown";
  default: break;
  }

  return "Invalid";
}

inline std::ostream &operator<<(std::ostream &os, const Error &obj) {
  os << to_string(obj);
  os << " (" << static_cast<std::underlying_type<Error>::type>(obj) << ')';
  return os;
}

inline uint64_t Result::get_request_header_value_u64(const std::string &key,
                                                     uint64_t def,
                                                     size_t id) const {
  return detail::get_header_value_u64(request_headers_, key, def, id);
}

template <class Rep, class Period>
inline void ClientImpl::set_connection_timeout(
    const std::chrono::duration<Rep, Period> &duration) {
  detail::duration_to_sec_and_usec(duration, [&](time_t sec, time_t usec) {
    set_connection_timeout(sec, usec);
  });
}

template <class Rep, class Period>
inline void ClientImpl::set_read_timeout(
    const std::chrono::duration<Rep, Period> &duration) {
  detail::duration_to_sec_and_usec(
      duration, [&](time_t sec, time_t usec) { set_read_timeout(sec, usec); });
}

template <class Rep, class Period>
inline void ClientImpl::set_write_timeout(
    const std::chrono::duration<Rep, Period> &duration) {
  detail::duration_to_sec_and_usec(
      duration, [&](time_t sec, time_t usec) { set_write_timeout(sec, usec); });
}

template <class Rep, class Period>
inline void Client::set_connection_timeout(
    const std::chrono::duration<Rep, Period> &duration) {
  cli_->set_connection_timeout(duration);
}

template <class Rep, class Period>
inline void
Client::set_read_timeout(const std::chrono::duration<Rep, Period> &duration) {
  cli_->set_read_timeout(duration);
}

template <class Rep, class Period>
inline void
Client::set_write_timeout(const std::chrono::duration<Rep, Period> &duration) {
  cli_->set_write_timeout(duration);
}

/*
 * Forward declarations and types that will be part of the .h file if split into
 * .h + .cc.
 */

std::string hosted_at(const std::string &hostname);

void hosted_at(const std::string &hostname, std::vector<std::string> &addrs);

std::string append_query_params(const std::string &path, const Params &params);

std::pair<std::string, std::string> make_range_header(const Ranges &ranges);

std::pair<std::string, std::string>
make_basic_authentication_header(const std::string &username,
                                 const std::string &password,
                                 bool is_proxy = false);

namespace detail {

bool is_file(const std::string &path);

bool is_dir(const std::string &path);

std::string encode_query_param(const std::string &value);

std::string decode_url(const std::string &s, bool convert_plus_to_space);

void read_file(const std::string &path, std::string &out);

std::string trim_copy(const std::string &s);

void divide(
    const char *data, std::size_t size, char d,
    std::function<void(const char *, std::size_t, const char *, std::size_t)>
        fn);

void divide(
    const std::string &str, char d,
    std::function<void(const char *, std::size_t, const char *, std::size_t)>
        fn);

void split(const char *b, const char *e, char d,
           std::function<void(const char *, const char *)> fn);

void split(const char *b, const char *e, char d, size_t m,
           std::function<void(const char *, const char *)> fn);

bool process_client_socket(socket_t sock, time_t read_timeout_sec,
                           time_t read_timeout_usec, time_t write_timeout_sec,
                           time_t write_timeout_usec,
                           std::function<bool(Stream &)> callback);

socket_t create_client_socket(const std::string &host, const std::string &ip,
                              int port, int address_family, bool tcp_nodelay,
                              bool ipv6_v6only, SocketOptions socket_options,
                              time_t connection_timeout_sec,
                              time_t connection_timeout_usec,
                              time_t read_timeout_sec, time_t read_timeout_usec,
                              time_t write_timeout_sec,
                              time_t write_timeout_usec,
                              const std::string &intf, Error &error);

const char *get_header_value(const Headers &headers, const std::string &key,
                             const char *def, size_t id);

std::string params_to_query_str(const Params &params);

void parse_query_text(const char *data, std::size_t size, Params &params);

void parse_query_text(const std::string &s, Params &params);

bool parse_multipart_boundary(const std::string &content_type,
                              std::string &boundary);

bool parse_range_header(const std::string &s, Ranges &ranges);

int close_socket(socket_t sock);

ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags);

ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags);

enum class EncodingType { None = 0, Gzip, Brotli };

EncodingType encoding_type(const Request &req, const Response &res);

class BufferStream final : public Stream {
public:
  BufferStream() = default;
  ~BufferStream() override = default;

  bool is_readable() const override;
  bool is_writable() const override;
  ssize_t read(char *ptr, size_t size) override;
  ssize_t write(const char *ptr, size_t size) override;
  void get_remote_ip_and_port(std::string &ip, int &port) const override;
  void get_local_ip_and_port(std::string &ip, int &port) const override;
  socket_t socket() const override;

  const std::string &get_buffer() const;

private:
  std::string buffer;
  size_t position = 0;
};

class compressor {
public:
  virtual ~compressor() = default;

  typedef std::function<bool(const char *data, size_t data_len)> Callback;
  virtual bool compress(const char *data, size_t data_length, bool last,
                        Callback callback) = 0;
};

class decompressor {
public:
  virtual ~decompressor() = default;

  virtual bool is_valid() const = 0;

  typedef std::function<bool(const char *data, size_t data_len)> Callback;
  virtual bool decompress(const char *data, size_t data_length,
                          Callback callback) = 0;
};

class nocompressor final : public compressor {
public:
  ~nocompressor() override = default;

  bool compress(const char *data, size_t data_length, bool /*last*/,
                Callback callback) override;
};

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
class gzip_compressor final : public compressor {
public:
  gzip_compressor();
  ~gzip_compressor() override;

  bool compress(const char *data, size_t data_length, bool last,
                Callback callback) override;

private:
  bool is_valid_ = false;
  z_stream strm_;
};

class gzip_decompressor final : public decompressor {
public:
  gzip_decompressor();
  ~gzip_decompressor() override;

  bool is_valid() const override;

  bool decompress(const char *data, size_t data_length,
                  Callback callback) override;

private:
  bool is_valid_ = false;
  z_stream strm_;
};
#endif

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
class brotli_compressor final : public compressor {
public:
  brotli_compressor();
  ~brotli_compressor();

  bool compress(const char *data, size_t data_length, bool last,
                Callback callback) override;

private:
  BrotliEncoderState *state_ = nullptr;
};

class brotli_decompressor final : public decompressor {
public:
  brotli_decompressor();
  ~brotli_decompressor();

  bool is_valid() const override;

  bool decompress(const char *data, size_t data_length,
                  Callback callback) override;

private:
  BrotliDecoderResult decoder_r;
  BrotliDecoderState *decoder_s = nullptr;
};
#endif

// NOTE: until the read size reaches `fixed_buffer_size`, use `fixed_buffer`
// to store data. The call can set memory on stack for performance.
class stream_line_reader {
public:
  stream_line_reader(Stream &strm, char *fixed_buffer,
                     size_t fixed_buffer_size);
  const char *ptr() const;
  size_t size() const;
  bool end_with_crlf() const;
  bool getline();

private:
  void append(char c);

  Stream &strm_;
  char *fixed_buffer_;
  const size_t fixed_buffer_size_;
  size_t fixed_buffer_used_size_ = 0;
  std::string glowable_buffer_;
};

class mmap {
public:
  mmap(const char *path);
  ~mmap();

  bool open(const char *path);
  void close();

  bool is_open() const;
  size_t size() const;
  const char *data() const;

private:
#if defined(_WIN32)
  HANDLE hFile_;
  HANDLE hMapping_;
#else
  int fd_;
#endif
  size_t size_;
  void *addr_;
};

} // namespace detail

// ----------------------------------------------------------------------------

/*
 * Implementation that will be part of the .cc file if split into .h + .cc.
 */

namespace detail {

inline bool is_hex(char c, int &v) {
  if (0x20 <= c && isdigit(c)) {
    v = c - '0';
    return true;
  } else if ('A' <= c && c <= 'F') {
    v = c - 'A' + 10;
    return true;
  } else if ('a' <= c && c <= 'f') {
    v = c - 'a' + 10;
    return true;
  }
  return false;
}

inline bool from_hex_to_i(const std::string &s, size_t i, size_t cnt,
                          int &val) {
  if (i >= s.size()) { return false; }

  val = 0;
  for (; cnt; i++, cnt--) {
    if (!s[i]) { return false; }
    auto v = 0;
    if (is_hex(s[i], v)) {
      val = val * 16 + v;
    } else {
      return false;
    }
  }
  return true;
}

inline std::string from_i_to_hex(size_t n) {
  static const auto charset = "0123456789abcdef";
  std::string ret;
  do {
    ret = charset[n & 15] + ret;
    n >>= 4;
  } while (n > 0);
  return ret;
}

inline size_t to_utf8(int code, char *buff) {
  if (code < 0x0080) {
    buff[0] = static_cast<char>(code & 0x7F);
    return 1;
  } else if (code < 0x0800) {
    buff[0] = static_cast<char>(0xC0 | ((code >> 6) & 0x1F));
    buff[1] = static_cast<char>(0x80 | (code & 0x3F));
    return 2;
  } else if (code < 0xD800) {
    buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));
    buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
    buff[2] = static_cast<char>(0x80 | (code & 0x3F));
    return 3;
  } else if (code < 0xE000) { // D800 - DFFF is invalid...
    return 0;
  } else if (code < 0x10000) {
    buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));
    buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
    buff[2] = static_cast<char>(0x80 | (code & 0x3F));
    return 3;
  } else if (code < 0x110000) {
    buff[0] = static_cast<char>(0xF0 | ((code >> 18) & 0x7));
    buff[1] = static_cast<char>(0x80 | ((code >> 12) & 0x3F));
    buff[2] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));
    buff[3] = static_cast<char>(0x80 | (code & 0x3F));
    return 4;
  }

  // NOTREACHED
  return 0;
}

// NOTE: This code came up with the following stackoverflow post:
// https://stackoverflow.com/questions/180947/base64-decode-snippet-in-c
inline std::string base64_encode(const std::string &in) {
  static const auto lookup =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  std::string out;
  out.reserve(in.size());

  auto val = 0;
  auto valb = -6;

  for (auto c : in) {
    val = (val << 8) + static_cast<uint8_t>(c);
    valb += 8;
    while (valb >= 0) {
      out.push_back(lookup[(val >> valb) & 0x3F]);
      valb -= 6;
    }
  }

  if (valb > -6) { out.push_back(lookup[((val << 8) >> (valb + 8)) & 0x3F]); }

  while (out.size() % 4) {
    out.push_back('=');
  }

  return out;
}

inline bool is_valid_path(const std::string &path) {
  size_t level = 0;
  size_t i = 0;

  // Skip slash
  while (i < path.size() && path[i] == '/') {
    i++;
  }

  while (i < path.size()) {
    // Read component
    auto beg = i;
    while (i < path.size() && path[i] != '/') {
      if (path[i] == '\0') {
        return false;
      } else if (path[i] == '\\') {
        return false;
      }
      i++;
    }

    auto len = i - beg;
    assert(len > 0);

    if (!path.compare(beg, len, ".")) {
      ;
    } else if (!path.compare(beg, len, "..")) {
      if (level == 0) { return false; }
      level--;
    } else {
      level++;
    }

    // Skip slash
    while (i < path.size() && path[i] == '/') {
      i++;
    }
  }

  return true;
}

inline bool is_file(const std::string &path) {
  struct stat st;
  return stat(path.c_str(), &st) >= 0 && S_ISREG(st.st_mode);
}

inline bool is_dir(const std::string &path) {
  struct stat st;
  return stat(path.c_str(), &st) >= 0 && S_ISDIR(st.st_mode);
}

inline std::string encode_query_param(const std::string &value) {
  std::ostringstream escaped;
  escaped.fill('0');
  escaped << std::hex;

  for (auto c : value) {
    if (std::isalnum(static_cast<uint8_t>(c)) || c == '-' || c == '_' ||
        c == '.' || c == '!' || c == '~' || c == '*' || c == '\'' || c == '(' ||
        c == ')') {
      escaped << c;
    } else {
      escaped << std::uppercase;
      escaped << '%' << std::setw(2)
              << static_cast<int>(static_cast<unsigned char>(c));
      escaped << std::nouppercase;
    }
  }

  return escaped.str();
}

inline std::string encode_url(const std::string &s) {
  std::string result;
  result.reserve(s.size());

  for (size_t i = 0; s[i]; i++) {
    switch (s[i]) {
    case ' ': result += "%20"; break;
    case '+': result += "%2B"; break;
    case '\r': result += "%0D"; break;
    case '\n': result += "%0A"; break;
    case '\'': result += "%27"; break;
    case ',': result += "%2C"; break;
    // case ':': result += "%3A"; break; // ok? probably...
    case ';': result += "%3B"; break;
    default:
      auto c = static_cast<uint8_t>(s[i]);
      if (c >= 0x80) {
        result += '%';
        char hex[4];
        auto len = snprintf(hex, sizeof(hex) - 1, "%02X", c);
        assert(len == 2);
        result.append(hex, static_cast<size_t>(len));
      } else {
        result += s[i];
      }
      break;
    }
  }

  return result;
}

inline std::string decode_url(const std::string &s,
                              bool convert_plus_to_space) {
  std::string result;

  for (size_t i = 0; i < s.size(); i++) {
    if (s[i] == '%' && i + 1 < s.size()) {
      if (s[i + 1] == 'u') {
        auto val = 0;
        if (from_hex_to_i(s, i + 2, 4, val)) {
          // 4 digits Unicode codes
          char buff[4];
          size_t len = to_utf8(val, buff);
          if (len > 0) { result.append(buff, len); }
          i += 5; // 'u0000'
        } else {
          result += s[i];
        }
      } else {
        auto val = 0;
        if (from_hex_to_i(s, i + 1, 2, val)) {
          // 2 digits hex codes
          result += static_cast<char>(val);
          i += 2; // '00'
        } else {
          result += s[i];
        }
      }
    } else if (convert_plus_to_space && s[i] == '+') {
      result += ' ';
    } else {
      result += s[i];
    }
  }

  return result;
}

inline void read_file(const std::string &path, std::string &out) {
  std::ifstream fs(path, std::ios_base::binary);
  fs.seekg(0, std::ios_base::end);
  auto size = fs.tellg();
  fs.seekg(0);
  out.resize(static_cast<size_t>(size));
  fs.read(&out[0], static_cast<std::streamsize>(size));
}

inline std::string file_extension(const std::string &path) {
  std::smatch m;
  static auto re = std::regex("\\.([a-zA-Z0-9]+)$");
  if (std::regex_search(path, m, re)) { return m[1].str(); }
  return std::string();
}

inline bool is_space_or_tab(char c) { return c == ' ' || c == '\t'; }

inline std::pair<size_t, size_t> trim(const char *b, const char *e, size_t left,
                                      size_t right) {
  while (b + left < e && is_space_or_tab(b[left])) {
    left++;
  }
  while (right > 0 && is_space_or_tab(b[right - 1])) {
    right--;
  }
  return std::make_pair(left, right);
}

inline std::string trim_copy(const std::string &s) {
  auto r = trim(s.data(), s.data() + s.size(), 0, s.size());
  return s.substr(r.first, r.second - r.first);
}

inline std::string trim_double_quotes_copy(const std::string &s) {
  if (s.length() >= 2 && s.front() == '"' && s.back() == '"') {
    return s.substr(1, s.size() - 2);
  }
  return s;
}

inline void
divide(const char *data, std::size_t size, char d,
       std::function<void(const char *, std::size_t, const char *, std::size_t)>
           fn) {
  const auto it = std::find(data, data + size, d);
  const auto found = static_cast<std::size_t>(it != data + size);
  const auto lhs_data = data;
  const auto lhs_size = static_cast<std::size_t>(it - data);
  const auto rhs_data = it + found;
  const auto rhs_size = size - lhs_size - found;

  fn(lhs_data, lhs_size, rhs_data, rhs_size);
}

inline void
divide(const std::string &str, char d,
       std::function<void(const char *, std::size_t, const char *, std::size_t)>
           fn) {
  divide(str.data(), str.size(), d, std::move(fn));
}

inline void split(const char *b, const char *e, char d,
                  std::function<void(const char *, const char *)> fn) {
  return split(b, e, d, (std::numeric_limits<size_t>::max)(), std::move(fn));
}

inline void split(const char *b, const char *e, char d, size_t m,
                  std::function<void(const char *, const char *)> fn) {
  size_t i = 0;
  size_t beg = 0;
  size_t count = 1;

  while (e ? (b + i < e) : (b[i] != '\0')) {
    if (b[i] == d && count < m) {
      auto r = trim(b, e, beg, i);
      if (r.first < r.second) { fn(&b[r.first], &b[r.second]); }
      beg = i + 1;
      count++;
    }
    i++;
  }

  if (i) {
    auto r = trim(b, e, beg, i);
    if (r.first < r.second) { fn(&b[r.first], &b[r.second]); }
  }
}

inline stream_line_reader::stream_line_reader(Stream &strm, char *fixed_buffer,
                                              size_t fixed_buffer_size)
    : strm_(strm), fixed_buffer_(fixed_buffer),
      fixed_buffer_size_(fixed_buffer_size) {}

inline const char *stream_line_reader::ptr() const {
  if (glowable_buffer_.empty()) {
    return fixed_buffer_;
  } else {
    return glowable_buffer_.data();
  }
}

inline size_t stream_line_reader::size() const {
  if (glowable_buffer_.empty()) {
    return fixed_buffer_used_size_;
  } else {
    return glowable_buffer_.size();
  }
}

inline bool stream_line_reader::end_with_crlf() const {
  auto end = ptr() + size();
  return size() >= 2 && end[-2] == '\r' && end[-1] == '\n';
}

inline bool stream_line_reader::getline() {
  fixed_buffer_used_size_ = 0;
  glowable_buffer_.clear();

#ifndef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
  char prev_byte = 0;
#endif

  for (size_t i = 0;; i++) {
    char byte;
    auto n = strm_.read(&byte, 1);

    if (n < 0) {
      return false;
    } else if (n == 0) {
      if (i == 0) {
        return false;
      } else {
        break;
      }
    }

    append(byte);

#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
    if (byte == '\n') { break; }
#else
    if (prev_byte == '\r' && byte == '\n') { break; }
    prev_byte = byte;
#endif
  }

  return true;
}

inline void stream_line_reader::append(char c) {
  if (fixed_buffer_used_size_ < fixed_buffer_size_ - 1) {
    fixed_buffer_[fixed_buffer_used_size_++] = c;
    fixed_buffer_[fixed_buffer_used_size_] = '\0';
  } else {
    if (glowable_buffer_.empty()) {
      assert(fixed_buffer_[fixed_buffer_used_size_] == '\0');
      glowable_buffer_.assign(fixed_buffer_, fixed_buffer_used_size_);
    }
    glowable_buffer_ += c;
  }
}

inline mmap::mmap(const char *path)
#if defined(_WIN32)
    : hFile_(NULL), hMapping_(NULL)
#else
    : fd_(-1)
#endif
      ,
      size_(0), addr_(nullptr) {
  open(path);
}

inline mmap::~mmap() { close(); }

inline bool mmap::open(const char *path) {
  close();

#if defined(_WIN32)
  std::wstring wpath;
  for (size_t i = 0; i < strlen(path); i++) {
    wpath += path[i];
  }

#if _WIN32_WINNT >= _WIN32_WINNT_WIN8
  hFile_ = ::CreateFile2(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ,
                         OPEN_EXISTING, NULL);
#else
  hFile_ = ::CreateFileW(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL,
                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif

  if (hFile_ == INVALID_HANDLE_VALUE) { return false; }

  LARGE_INTEGER size{};
  if (!::GetFileSizeEx(hFile_, &size)) { return false; }
  // If the following line doesn't compile due to QuadPart, update Windows SDK.
  // See:
  // https://github.com/yhirose/cpp-httplib/issues/1903#issuecomment-2316520721
  if (static_cast<ULONGLONG>(size.QuadPart) >
      std::numeric_limits<decltype(size_)>::max()) {
    // `size_t` might be 32-bits, on 32-bits Windows.
    return false;
  }
  size_ = static_cast<size_t>(size.QuadPart);

#if _WIN32_WINNT >= _WIN32_WINNT_WIN8
  hMapping_ =
      ::CreateFileMappingFromApp(hFile_, NULL, PAGE_READONLY, size_, NULL);
#else
  hMapping_ = ::CreateFileMappingW(hFile_, NULL, PAGE_READONLY, 0, 0, NULL);
#endif

  if (hMapping_ == NULL) {
    close();
    return false;
  }

#if _WIN32_WINNT >= _WIN32_WINNT_WIN8
  addr_ = ::MapViewOfFileFromApp(hMapping_, FILE_MAP_READ, 0, 0);
#else
  addr_ = ::MapViewOfFile(hMapping_, FILE_MAP_READ, 0, 0, 0);
#endif
#else
  fd_ = ::open(path, O_RDONLY);
  if (fd_ == -1) { return false; }

  struct stat sb;
  if (fstat(fd_, &sb) == -1) {
    close();
    return false;
  }
  size_ = static_cast<size_t>(sb.st_size);

  addr_ = ::mmap(NULL, size_, PROT_READ, MAP_PRIVATE, fd_, 0);
#endif

  if (addr_ == nullptr) {
    close();
    return false;
  }

  return true;
}

inline bool mmap::is_open() const { return addr_ != nullptr; }

inline size_t mmap::size() const { return size_; }

inline const char *mmap::data() const {
  return static_cast<const char *>(addr_);
}

inline void mmap::close() {
#if defined(_WIN32)
  if (addr_) {
    ::UnmapViewOfFile(addr_);
    addr_ = nullptr;
  }

  if (hMapping_) {
    ::CloseHandle(hMapping_);
    hMapping_ = NULL;
  }

  if (hFile_ != INVALID_HANDLE_VALUE) {
    ::CloseHandle(hFile_);
    hFile_ = INVALID_HANDLE_VALUE;
  }
#else
  if (addr_ != nullptr) {
    munmap(addr_, size_);
    addr_ = nullptr;
  }

  if (fd_ != -1) {
    ::close(fd_);
    fd_ = -1;
  }
#endif
  size_ = 0;
}
inline int close_socket(socket_t sock) {
#ifdef _WIN32
  return closesocket(sock);
#else
  return close(sock);
#endif
}

template <typename T> inline ssize_t handle_EINTR(T fn) {
  ssize_t res = 0;
  while (true) {
    res = fn();
    if (res < 0 && errno == EINTR) {
      std::this_thread::sleep_for(std::chrono::milliseconds{1});
      continue;
    }
    break;
  }
  return res;
}

inline ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags) {
  return handle_EINTR([&]() {
    return recv(sock,
#ifdef _WIN32
                static_cast<char *>(ptr), static_cast<int>(size),
#else
                ptr, size,
#endif
                flags);
  });
}

inline ssize_t send_socket(socket_t sock, const void *ptr, size_t size,
                           int flags) {
  return handle_EINTR([&]() {
    return send(sock,
#ifdef _WIN32
                static_cast<const char *>(ptr), static_cast<int>(size),
#else
                ptr, size,
#endif
                flags);
  });
}

inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {
#ifdef CPPHTTPLIB_USE_POLL
  struct pollfd pfd_read;
  pfd_read.fd = sock;
  pfd_read.events = POLLIN;

  auto timeout = static_cast<int>(sec * 1000 + usec / 1000);

  return handle_EINTR([&]() { return poll(&pfd_read, 1, timeout); });
#else
#ifndef _WIN32
  if (sock >= FD_SETSIZE) { return -1; }
#endif

  fd_set fds;
  FD_ZERO(&fds);
  FD_SET(sock, &fds);

  timeval tv;
  tv.tv_sec = static_cast<long>(sec);
  tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);

  return handle_EINTR([&]() {
    return select(static_cast<int>(sock + 1), &fds, nullptr, nullptr, &tv);
  });
#endif
}

inline ssize_t select_write(socket_t sock, time_t sec, time_t usec) {
#ifdef CPPHTTPLIB_USE_POLL
  struct pollfd pfd_read;
  pfd_read.fd = sock;
  pfd_read.events = POLLOUT;

  auto timeout = static_cast<int>(sec * 1000 + usec / 1000);

  return handle_EINTR([&]() { return poll(&pfd_read, 1, timeout); });
#else
#ifndef _WIN32
  if (sock >= FD_SETSIZE) { return -1; }
#endif

  fd_set fds;
  FD_ZERO(&fds);
  FD_SET(sock, &fds);

  timeval tv;
  tv.tv_sec = static_cast<long>(sec);
  tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);

  return handle_EINTR([&]() {
    return select(static_cast<int>(sock + 1), nullptr, &fds, nullptr, &tv);
  });
#endif
}

inline Error wait_until_socket_is_ready(socket_t sock, time_t sec,
                                        time_t usec) {
#ifdef CPPHTTPLIB_USE_POLL
  struct pollfd pfd_read;
  pfd_read.fd = sock;
  pfd_read.events = POLLIN | POLLOUT;

  auto timeout = static_cast<int>(sec * 1000 + usec / 1000);

  auto poll_res = handle_EINTR([&]() { return poll(&pfd_read, 1, timeout); });

  if (poll_res == 0) { return Error::ConnectionTimeout; }

  if (poll_res > 0 && pfd_read.revents & (POLLIN | POLLOUT)) {
    auto error = 0;
    socklen_t len = sizeof(error);
    auto res = getsockopt(sock, SOL_SOCKET, SO_ERROR,
                          reinterpret_cast<char *>(&error), &len);
    auto successful = res >= 0 && !error;
    return successful ? Error::Success : Error::Connection;
  }

  return Error::Connection;
#else
#ifndef _WIN32
  if (sock >= FD_SETSIZE) { return Error::Connection; }
#endif

  fd_set fdsr;
  FD_ZERO(&fdsr);
  FD_SET(sock, &fdsr);

  auto fdsw = fdsr;
  auto fdse = fdsr;

  timeval tv;
  tv.tv_sec = static_cast<long>(sec);
  tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);

  auto ret = handle_EINTR([&]() {
    return select(static_cast<int>(sock + 1), &fdsr, &fdsw, &fdse, &tv);
  });

  if (ret == 0) { return Error::ConnectionTimeout; }

  if (ret > 0 && (FD_ISSET(sock, &fdsr) || FD_ISSET(sock, &fdsw))) {
    auto error = 0;
    socklen_t len = sizeof(error);
    auto res = getsockopt(sock, SOL_SOCKET, SO_ERROR,
                          reinterpret_cast<char *>(&error), &len);
    auto successful = res >= 0 && !error;
    return successful ? Error::Success : Error::Connection;
  }
  return Error::Connection;
#endif
}

inline bool is_socket_alive(socket_t sock) {
  const auto val = detail::select_read(sock, 0, 0);
  if (val == 0) {
    return true;
  } else if (val < 0 && errno == EBADF) {
    return false;
  }
  char buf[1];
  return detail::read_socket(sock, &buf[0], sizeof(buf), MSG_PEEK) > 0;
}

class SocketStream final : public Stream {
public:
  SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
               time_t write_timeout_sec, time_t write_timeout_usec);
  ~SocketStream() override;

  bool is_readable() const override;
  bool is_writable() const override;
  ssize_t read(char *ptr, size_t size) override;
  ssize_t write(const char *ptr, size_t size) override;
  void get_remote_ip_and_port(std::string &ip, int &port) const override;
  void get_local_ip_and_port(std::string &ip, int &port) const override;
  socket_t socket() const override;

private:
  socket_t sock_;
  time_t read_timeout_sec_;
  time_t read_timeout_usec_;
  time_t write_timeout_sec_;
  time_t write_timeout_usec_;

  std::vector<char> read_buff_;
  size_t read_buff_off_ = 0;
  size_t read_buff_content_size_ = 0;

  static const size_t read_buff_size_ = 1024l * 4;
};

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
class SSLSocketStream final : public Stream {
public:
  SSLSocketStream(socket_t sock, SSL *ssl, time_t read_timeout_sec,
                  time_t read_timeout_usec, time_t write_timeout_sec,
                  time_t write_timeout_usec);
  ~SSLSocketStream() override;

  bool is_readable() const override;
  bool is_writable() const override;
  ssize_t read(char *ptr, size_t size) override;
  ssize_t write(const char *ptr, size_t size) override;
  void get_remote_ip_and_port(std::string &ip, int &port) const override;
  void get_local_ip_and_port(std::string &ip, int &port) const override;
  socket_t socket() const override;

private:
  socket_t sock_;
  SSL *ssl_;
  time_t read_timeout_sec_;
  time_t read_timeout_usec_;
  time_t write_timeout_sec_;
  time_t write_timeout_usec_;
};
#endif

inline bool keep_alive(socket_t sock, time_t keep_alive_timeout_sec) {
  using namespace std::chrono;
  auto start = steady_clock::now();
  while (true) {
    auto val = select_read(sock, 0, 10000);
    if (val < 0) {
      return false;
    } else if (val == 0) {
      auto current = steady_clock::now();
      auto duration = duration_cast<milliseconds>(current - start);
      auto timeout = keep_alive_timeout_sec * 1000;
      if (duration.count() > timeout) { return false; }
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
    } else {
      return true;
    }
  }
}

template <typename T>
inline bool
process_server_socket_core(const std::atomic<socket_t> &svr_sock, socket_t sock,
                           size_t keep_alive_max_count,
                           time_t keep_alive_timeout_sec, T callback) {
  assert(keep_alive_max_count > 0);
  auto ret = false;
  auto count = keep_alive_max_count;
  while (svr_sock != INVALID_SOCKET && count > 0 &&
         keep_alive(sock, keep_alive_timeout_sec)) {
    auto close_connection = count == 1;
    auto connection_closed = false;
    ret = callback(close_connection, connection_closed);
    if (!ret || connection_closed) { break; }
    count--;
  }
  return ret;
}

template <typename T>
inline bool
process_server_socket(const std::atomic<socket_t> &svr_sock, socket_t sock,
                      size_t keep_alive_max_count,
                      time_t keep_alive_timeout_sec, time_t read_timeout_sec,
                      time_t read_timeout_usec, time_t write_timeout_sec,
                      time_t write_timeout_usec, T callback) {
  return process_server_socket_core(
      svr_sock, sock, keep_alive_max_count, keep_alive_timeout_sec,
      [&](bool close_connection, bool &connection_closed) {
        SocketStream strm(sock, read_timeout_sec, read_timeout_usec,
                          write_timeout_sec, write_timeout_usec);
        return callback(strm, close_connection, connection_closed);
      });
}

inline bool process_client_socket(socket_t sock, time_t read_timeout_sec,
                                  time_t read_timeout_usec,
                                  time_t write_timeout_sec,
                                  time_t write_timeout_usec,
                                  std::function<bool(Stream &)> callback) {
  SocketStream strm(sock, read_timeout_sec, read_timeout_usec,
                    write_timeout_sec, write_timeout_usec);
  return callback(strm);
}

inline int shutdown_socket(socket_t sock) {
#ifdef _WIN32
  return shutdown(sock, SD_BOTH);
#else
  return shutdown(sock, SHUT_RDWR);
#endif
}

template <typename BindOrConnect>
socket_t create_socket(const std::string &host, const std::string &ip, int port,
                       int address_family, int socket_flags, bool tcp_nodelay,
                       bool ipv6_v6only, SocketOptions socket_options,
                       BindOrConnect bind_or_connect) {
  // Get address info
  const char *node = nullptr;
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = 0;

  if (!ip.empty()) {
    node = ip.c_str();
    // Ask getaddrinfo to convert IP in c-string to address
    hints.ai_family = AF_UNSPEC;
    hints.ai_flags = AI_NUMERICHOST;
  } else {
    if (!host.empty()) { node = host.c_str(); }
    hints.ai_family = address_family;
    hints.ai_flags = socket_flags;
  }

#ifndef _WIN32
  if (hints.ai_family == AF_UNIX) {
    const auto addrlen = host.length();
    if (addrlen > sizeof(sockaddr_un::sun_path)) { return INVALID_SOCKET; }

#ifdef SOCK_CLOEXEC
    auto sock = socket(hints.ai_family, hints.ai_socktype | SOCK_CLOEXEC,
                       hints.ai_protocol);
#else
    auto sock = socket(hints.ai_family, hints.ai_socktype, hints.ai_protocol);
#endif

    if (sock != INVALID_SOCKET) {
      sockaddr_un addr{};
      addr.sun_family = AF_UNIX;
      std::copy(host.begin(), host.end(), addr.sun_path);

      hints.ai_addr = reinterpret_cast<sockaddr *>(&addr);
      hints.ai_addrlen = static_cast<socklen_t>(
          sizeof(addr) - sizeof(addr.sun_path) + addrlen);

#ifndef SOCK_CLOEXEC
      fcntl(sock, F_SETFD, FD_CLOEXEC);
#endif

      if (socket_options) { socket_options(sock); }

      bool dummy;
      if (!bind_or_connect(sock, hints, dummy)) {
        close_socket(sock);
        sock = INVALID_SOCKET;
      }
    }
    return sock;
  }
#endif

  auto service = std::to_string(port);

  if (getaddrinfo(node, service.c_str(), &hints, &result)) {
#if defined __linux__ && !defined __ANDROID__
    res_init();
#endif
    return INVALID_SOCKET;
  }

  for (auto rp = result; rp; rp = rp->ai_next) {
    // Create a socket
#ifdef _WIN32
    auto sock =
        WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol, nullptr, 0,
                   WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);
    /**
     * Since the WSA_FLAG_NO_HANDLE_INHERIT is only supported on Windows 7 SP1
     * and above the socket creation fails on older Windows Systems.
     *
     * Let's try to create a socket the old way in this case.
     *
     * Reference:
     * https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa
     *
     * WSA_FLAG_NO_HANDLE_INHERIT:
     * This flag is supported on Windows 7 with SP1, Windows Server 2008 R2 with
     * SP1, and later
     *
     */
    if (sock == INVALID_SOCKET) {
      sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    }
#else

#ifdef SOCK_CLOEXEC
    auto sock =
        socket(rp->ai_family, rp->ai_socktype | SOCK_CLOEXEC, rp->ai_protocol);
#else
    auto sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
#endif

#endif
    if (sock == INVALID_SOCKET) { continue; }

#if !defined _WIN32 && !defined SOCK_CLOEXEC
    if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {
      close_socket(sock);
      continue;
    }
#endif

    if (tcp_nodelay) {
      auto opt = 1;
#ifdef _WIN32
      setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
                 reinterpret_cast<const char *>(&opt), sizeof(opt));
#else
      setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
                 reinterpret_cast<const void *>(&opt), sizeof(opt));
#endif
    }

    if (rp->ai_family == AF_INET6) {
      auto opt = ipv6_v6only ? 1 : 0;
#ifdef _WIN32
      setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,
                 reinterpret_cast<const char *>(&opt), sizeof(opt));
#else
      setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,
                 reinterpret_cast<const void *>(&opt), sizeof(opt));
#endif
    }

    if (socket_options) { socket_options(sock); }

    // bind or connect
    auto quit = false;
    if (bind_or_connect(sock, *rp, quit)) {
      freeaddrinfo(result);
      return sock;
    }

    close_socket(sock);

    if (quit) { break; }
  }

  freeaddrinfo(result);
  return INVALID_SOCKET;
}

inline void set_nonblocking(socket_t sock, bool nonblocking) {
#ifdef _WIN32
  auto flags = nonblocking ? 1UL : 0UL;
  ioctlsocket(sock, FIONBIO, &flags);
#else
  auto flags = fcntl(sock, F_GETFL, 0);
  fcntl(sock, F_SETFL,
        nonblocking ? (flags | O_NONBLOCK) : (flags & (~O_NONBLOCK)));
#endif
}

inline bool is_connection_error() {
#ifdef _WIN32
  return WSAGetLastError() != WSAEWOULDBLOCK;
#else
  return errno != EINPROGRESS;
#endif
}

inline bool bind_ip_address(socket_t sock, const std::string &host) {
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = 0;

  if (getaddrinfo(host.c_str(), "0", &hints, &result)) { return false; }

  auto ret = false;
  for (auto rp = result; rp; rp = rp->ai_next) {
    const auto &ai = *rp;
    if (!::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {
      ret = true;
      break;
    }
  }

  freeaddrinfo(result);
  return ret;
}

#if !defined _WIN32 && !defined ANDROID && !defined _AIX && !defined __MVS__
#define USE_IF2IP
#endif

#ifdef USE_IF2IP
inline std::string if2ip(int address_family, const std::string &ifn) {
  struct ifaddrs *ifap;
  getifaddrs(&ifap);
  std::string addr_candidate;
  for (auto ifa = ifap; ifa; ifa = ifa->ifa_next) {
    if (ifa->ifa_addr && ifn == ifa->ifa_name &&
        (AF_UNSPEC == address_family ||
         ifa->ifa_addr->sa_family == address_family)) {
      if (ifa->ifa_addr->sa_family == AF_INET) {
        auto sa = reinterpret_cast<struct sockaddr_in *>(ifa->ifa_addr);
        char buf[INET_ADDRSTRLEN];
        if (inet_ntop(AF_INET, &sa->sin_addr, buf, INET_ADDRSTRLEN)) {
          freeifaddrs(ifap);
          return std::string(buf, INET_ADDRSTRLEN);
        }
      } else if (ifa->ifa_addr->sa_family == AF_INET6) {
        auto sa = reinterpret_cast<struct sockaddr_in6 *>(ifa->ifa_addr);
        if (!IN6_IS_ADDR_LINKLOCAL(&sa->sin6_addr)) {
          char buf[INET6_ADDRSTRLEN] = {};
          if (inet_ntop(AF_INET6, &sa->sin6_addr, buf, INET6_ADDRSTRLEN)) {
            // equivalent to mac's IN6_IS_ADDR_UNIQUE_LOCAL
            auto s6_addr_head = sa->sin6_addr.s6_addr[0];
            if (s6_addr_head == 0xfc || s6_addr_head == 0xfd) {
              addr_candidate = std::string(buf, INET6_ADDRSTRLEN);
            } else {
              freeifaddrs(ifap);
              return std::string(buf, INET6_ADDRSTRLEN);
            }
          }
        }
      }
    }
  }
  freeifaddrs(ifap);
  return addr_candidate;
}
#endif

inline socket_t create_client_socket(
    const std::string &host, const std::string &ip, int port,
    int address_family, bool tcp_nodelay, bool ipv6_v6only,
    SocketOptions socket_options, time_t connection_timeout_sec,
    time_t connection_timeout_usec, time_t read_timeout_sec,
    time_t read_timeout_usec, time_t write_timeout_sec,
    time_t write_timeout_usec, const std::string &intf, Error &error) {
  auto sock = create_socket(
      host, ip, port, address_family, 0, tcp_nodelay, ipv6_v6only,
      std::move(socket_options),
      [&](socket_t sock2, struct addrinfo &ai, bool &quit) -> bool {
        if (!intf.empty()) {
#ifdef USE_IF2IP
          auto ip_from_if = if2ip(address_family, intf);
          if (ip_from_if.empty()) { ip_from_if = intf; }
          if (!bind_ip_address(sock2, ip_from_if)) {
            error = Error::BindIPAddress;
            return false;
          }
#endif
        }

        set_nonblocking(sock2, true);

        auto ret =
            ::connect(sock2, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen));

        if (ret < 0) {
          if (is_connection_error()) {
            error = Error::Connection;
            return false;
          }
          error = wait_until_socket_is_ready(sock2, connection_timeout_sec,
                                             connection_timeout_usec);
          if (error != Error::Success) {
            if (error == Error::ConnectionTimeout) { quit = true; }
            return false;
          }
        }

        set_nonblocking(sock2, false);

        {
#ifdef _WIN32
          auto timeout = static_cast<uint32_t>(read_timeout_sec * 1000 +
                                               read_timeout_usec / 1000);
          setsockopt(sock2, SOL_SOCKET, SO_RCVTIMEO,
                     reinterpret_cast<const char *>(&timeout), sizeof(timeout));
#else
          timeval tv;
          tv.tv_sec = static_cast<long>(read_timeout_sec);
          tv.tv_usec = static_cast<decltype(tv.tv_usec)>(read_timeout_usec);
          setsockopt(sock2, SOL_SOCKET, SO_RCVTIMEO,
                     reinterpret_cast<const void *>(&tv), sizeof(tv));
#endif
        }
        {

#ifdef _WIN32
          auto timeout = static_cast<uint32_t>(write_timeout_sec * 1000 +
                                               write_timeout_usec / 1000);
          setsockopt(sock2, SOL_SOCKET, SO_SNDTIMEO,
                     reinterpret_cast<const char *>(&timeout), sizeof(timeout));
#else
          timeval tv;
          tv.tv_sec = static_cast<long>(write_timeout_sec);
          tv.tv_usec = static_cast<decltype(tv.tv_usec)>(write_timeout_usec);
          setsockopt(sock2, SOL_SOCKET, SO_SNDTIMEO,
                     reinterpret_cast<const void *>(&tv), sizeof(tv));
#endif
        }

        error = Error::Success;
        return true;
      });

  if (sock != INVALID_SOCKET) {
    error = Error::Success;
  } else {
    if (error == Error::Success) { error = Error::Connection; }
  }

  return sock;
}

inline bool get_ip_and_port(const struct sockaddr_storage &addr,
                            socklen_t addr_len, std::string &ip, int &port) {
  if (addr.ss_family == AF_INET) {
    port = ntohs(reinterpret_cast<const struct sockaddr_in *>(&addr)->sin_port);
  } else if (addr.ss_family == AF_INET6) {
    port =
        ntohs(reinterpret_cast<const struct sockaddr_in6 *>(&addr)->sin6_port);
  } else {
    return false;
  }

  std::array<char, NI_MAXHOST> ipstr{};
  if (getnameinfo(reinterpret_cast<const struct sockaddr *>(&addr), addr_len,
                  ipstr.data(), static_cast<socklen_t>(ipstr.size()), nullptr,
                  0, NI_NUMERICHOST)) {
    return false;
  }

  ip = ipstr.data();
  return true;
}

inline void get_local_ip_and_port(socket_t sock, std::string &ip, int &port) {
  struct sockaddr_storage addr;
  socklen_t addr_len = sizeof(addr);
  if (!getsockname(sock, reinterpret_cast<struct sockaddr *>(&addr),
                   &addr_len)) {
    get_ip_and_port(addr, addr_len, ip, port);
  }
}

inline void get_remote_ip_and_port(socket_t sock, std::string &ip, int &port) {
  struct sockaddr_storage addr;
  socklen_t addr_len = sizeof(addr);

  if (!getpeername(sock, reinterpret_cast<struct sockaddr *>(&addr),
                   &addr_len)) {
#ifndef _WIN32
    if (addr.ss_family == AF_UNIX) {
#if defined(__linux__)
      struct ucred ucred;
      socklen_t len = sizeof(ucred);
      if (getsockopt(sock, SOL_SOCKET, SO_PEERCRED, &ucred, &len) == 0) {
        port = ucred.pid;
      }
#elif defined(SOL_LOCAL) && defined(SO_PEERPID) // __APPLE__
      pid_t pid;
      socklen_t len = sizeof(pid);
      if (getsockopt(sock, SOL_LOCAL, SO_PEERPID, &pid, &len) == 0) {
        port = pid;
      }
#endif
      return;
    }
#endif
    get_ip_and_port(addr, addr_len, ip, port);
  }
}

inline constexpr unsigned int str2tag_core(const char *s, size_t l,
                                           unsigned int h) {
  return (l == 0)
             ? h
             : str2tag_core(
                   s + 1, l - 1,
                   // Unsets the 6 high bits of h, therefore no overflow happens
                   (((std::numeric_limits<unsigned int>::max)() >> 6) &
                    h * 33) ^
                       static_cast<unsigned char>(*s));
}

inline unsigned int str2tag(const std::string &s) {
  return str2tag_core(s.data(), s.size(), 0);
}

namespace udl {

inline constexpr unsigned int operator"" _t(const char *s, size_t l) {
  return str2tag_core(s, l, 0);
}

} // namespace udl

inline std::string
find_content_type(const std::string &path,
                  const std::map<std::string, std::string> &user_data,
                  const std::string &default_content_type) {
  auto ext = file_extension(path);

  auto it = user_data.find(ext);
  if (it != user_data.end()) { return it->second; }

  using udl::operator""_t;

  switch (str2tag(ext)) {
  default: return default_content_type;

  case "css"_t: return "text/css";
  case "csv"_t: return "text/csv";
  case "htm"_t:
  case "html"_t: return "text/html";
  case "js"_t:
  case "mjs"_t: return "text/javascript";
  case "txt"_t: return "text/plain";
  case "vtt"_t: return "text/vtt";

  case "apng"_t: return "image/apng";
  case "avif"_t: return "image/avif";
  case "bmp"_t: return "image/bmp";
  case "gif"_t: return "image/gif";
  case "png"_t: return "image/png";
  case "svg"_t: return "image/svg+xml";
  case "webp"_t: return "image/webp";
  case "ico"_t: return "image/x-icon";
  case "tif"_t: return "image/tiff";
  case "tiff"_t: return "image/tiff";
  case "jpg"_t:
  case "jpeg"_t: return "image/jpeg";

  case "mp4"_t: return "video/mp4";
  case "mpeg"_t: return "video/mpeg";
  case "webm"_t: return "video/webm";

  case "mp3"_t: return "audio/mp3";
  case "mpga"_t: return "audio/mpeg";
  case "weba"_t: return "audio/webm";
  case "wav"_t: return "audio/wave";

  case "otf"_t: return "font/otf";
  case "ttf"_t: return "font/ttf";
  case "woff"_t: return "font/woff";
  case "woff2"_t: return "font/woff2";

  case "7z"_t: return "application/x-7z-compressed";
  case "atom"_t: return "application/atom+xml";
  case "pdf"_t: return "application/pdf";
  case "json"_t: return "application/json";
  case "rss"_t: return "application/rss+xml";
  case "tar"_t: return "application/x-tar";
  case "xht"_t:
  case "xhtml"_t: return "application/xhtml+xml";
  case "xslt"_t: return "application/xslt+xml";
  case "xml"_t: return "application/xml";
  case "gz"_t: return "application/gzip";
  case "zip"_t: return "application/zip";
  case "wasm"_t: return "application/wasm";
  }
}

inline bool can_compress_content_type(const std::string &content_type) {
  using udl::operator""_t;

  auto tag = str2tag(content_type);

  switch (tag) {
  case "image/svg+xml"_t:
  case "application/javascript"_t:
  case "application/json"_t:
  case "application/xml"_t:
  case "application/protobuf"_t:
  case "application/xhtml+xml"_t: return true;

  default:
    return !content_type.rfind("text/", 0) && tag != "text/event-stream"_t;
  }
}

inline EncodingType encoding_type(const Request &req, const Response &res) {
  auto ret =
      detail::can_compress_content_type(res.get_header_value("Content-Type"));
  if (!ret) { return EncodingType::None; }

  const auto &s = req.get_header_value("Accept-Encoding");
  (void)(s);

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
  // TODO: 'Accept-Encoding' has br, not br;q=0
  ret = s.find("br") != std::string::npos;
  if (ret) { return EncodingType::Brotli; }
#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
  // TODO: 'Accept-Encoding' has gzip, not gzip;q=0
  ret = s.find("gzip") != std::string::npos;
  if (ret) { return EncodingType::Gzip; }
#endif

  return EncodingType::None;
}

inline bool nocompressor::compress(const char *data, size_t data_length,
                                   bool /*last*/, Callback callback) {
  if (!data_length) { return true; }
  return callback(data, data_length);
}

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
inline gzip_compressor::gzip_compressor() {
  std::memset(&strm_, 0, sizeof(strm_));
  strm_.zalloc = Z_NULL;
  strm_.zfree = Z_NULL;
  strm_.opaque = Z_NULL;

  is_valid_ = deflateInit2(&strm_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 31, 8,
                           Z_DEFAULT_STRATEGY) == Z_OK;
}

inline gzip_compressor::~gzip_compressor() { deflateEnd(&strm_); }

inline bool gzip_compressor::compress(const char *data, size_t data_length,
                                      bool last, Callback callback) {
  assert(is_valid_);

  do {
    constexpr size_t max_avail_in =
        (std::numeric_limits<decltype(strm_.avail_in)>::max)();

    strm_.avail_in = static_cast<decltype(strm_.avail_in)>(
        (std::min)(data_length, max_avail_in));
    strm_.next_in = const_cast<Bytef *>(reinterpret_cast<const Bytef *>(data));

    data_length -= strm_.avail_in;
    data += strm_.avail_in;

    auto flush = (last && data_length == 0) ? Z_FINISH : Z_NO_FLUSH;
    auto ret = Z_OK;

    std::array<char, CPPHTTPLIB_COMPRESSION_BUFSIZ> buff{};
    do {
      strm_.avail_out = static_cast<uInt>(buff.size());
      strm_.next_out = reinterpret_cast<Bytef *>(buff.data());

      ret = deflate(&strm_, flush);
      if (ret == Z_STREAM_ERROR) { return false; }

      if (!callback(buff.data(), buff.size() - strm_.avail_out)) {
        return false;
      }
    } while (strm_.avail_out == 0);

    assert((flush == Z_FINISH && ret == Z_STREAM_END) ||
           (flush == Z_NO_FLUSH && ret == Z_OK));
    assert(strm_.avail_in == 0);
  } while (data_length > 0);

  return true;
}

inline gzip_decompressor::gzip_decompressor() {
  std::memset(&strm_, 0, sizeof(strm_));
  strm_.zalloc = Z_NULL;
  strm_.zfree = Z_NULL;
  strm_.opaque = Z_NULL;

  // 15 is the value of wbits, which should be at the maximum possible value
  // to ensure that any gzip stream can be decoded. The offset of 32 specifies
  // that the stream type should be automatically detected either gzip or
  // deflate.
  is_valid_ = inflateInit2(&strm_, 32 + 15) == Z_OK;
}

inline gzip_decompressor::~gzip_decompressor() { inflateEnd(&strm_); }

inline bool gzip_decompressor::is_valid() const { return is_valid_; }

inline bool gzip_decompressor::decompress(const char *data, size_t data_length,
                                          Callback callback) {
  assert(is_valid_);

  auto ret = Z_OK;

  do {
    constexpr size_t max_avail_in =
        (std::numeric_limits<decltype(strm_.avail_in)>::max)();

    strm_.avail_in = static_cast<decltype(strm_.avail_in)>(
        (std::min)(data_length, max_avail_in));
    strm_.next_in = const_cast<Bytef *>(reinterpret_cast<const Bytef *>(data));

    data_length -= strm_.avail_in;
    data += strm_.avail_in;

    std::array<char, CPPHTTPLIB_COMPRESSION_BUFSIZ> buff{};
    while (strm_.avail_in > 0 && ret == Z_OK) {
      strm_.avail_out = static_cast<uInt>(buff.size());
      strm_.next_out = reinterpret_cast<Bytef *>(buff.data());

      ret = inflate(&strm_, Z_NO_FLUSH);

      assert(ret != Z_STREAM_ERROR);
      switch (ret) {
      case Z_NEED_DICT:
      case Z_DATA_ERROR:
      case Z_MEM_ERROR: inflateEnd(&strm_); return false;
      }

      if (!callback(buff.data(), buff.size() - strm_.avail_out)) {
        return false;
      }
    }

    if (ret != Z_OK && ret != Z_STREAM_END) { return false; }

  } while (data_length > 0);

  return true;
}
#endif

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
inline brotli_compressor::brotli_compressor() {
  state_ = BrotliEncoderCreateInstance(nullptr, nullptr, nullptr);
}

inline brotli_compressor::~brotli_compressor() {
  BrotliEncoderDestroyInstance(state_);
}

inline bool brotli_compressor::compress(const char *data, size_t data_length,
                                        bool last, Callback callback) {
  std::array<uint8_t, CPPHTTPLIB_COMPRESSION_BUFSIZ> buff{};

  auto operation = last ? BROTLI_OPERATION_FINISH : BROTLI_OPERATION_PROCESS;
  auto available_in = data_length;
  auto next_in = reinterpret_cast<const uint8_t *>(data);

  for (;;) {
    if (last) {
      if (BrotliEncoderIsFinished(state_)) { break; }
    } else {
      if (!available_in) { break; }
    }

    auto available_out = buff.size();
    auto next_out = buff.data();

    if (!BrotliEncoderCompressStream(state_, operation, &available_in, &next_in,
                                     &available_out, &next_out, nullptr)) {
      return false;
    }

    auto output_bytes = buff.size() - available_out;
    if (output_bytes) {
      callback(reinterpret_cast<const char *>(buff.data()), output_bytes);
    }
  }

  return true;
}

inline brotli_decompressor::brotli_decompressor() {
  decoder_s = BrotliDecoderCreateInstance(0, 0, 0);
  decoder_r = decoder_s ? BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT
                        : BROTLI_DECODER_RESULT_ERROR;
}

inline brotli_decompressor::~brotli_decompressor() {
  if (decoder_s) { BrotliDecoderDestroyInstance(decoder_s); }
}

inline bool brotli_decompressor::is_valid() const { return decoder_s; }

inline bool brotli_decompressor::decompress(const char *data,
                                            size_t data_length,
                                            Callback callback) {
  if (decoder_r == BROTLI_DECODER_RESULT_SUCCESS ||
      decoder_r == BROTLI_DECODER_RESULT_ERROR) {
    return 0;
  }

  auto next_in = reinterpret_cast<const uint8_t *>(data);
  size_t avail_in = data_length;
  size_t total_out;

  decoder_r = BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT;

  std::array<char, CPPHTTPLIB_COMPRESSION_BUFSIZ> buff{};
  while (decoder_r == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT) {
    char *next_out = buff.data();
    size_t avail_out = buff.size();

    decoder_r = BrotliDecoderDecompressStream(
        decoder_s, &avail_in, &next_in, &avail_out,
        reinterpret_cast<uint8_t **>(&next_out), &total_out);

    if (decoder_r == BROTLI_DECODER_RESULT_ERROR) { return false; }

    if (!callback(buff.data(), buff.size() - avail_out)) { return false; }
  }

  return decoder_r == BROTLI_DECODER_RESULT_SUCCESS ||
         decoder_r == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT;
}
#endif

inline bool has_header(const Headers &headers, const std::string &key) {
  return headers.find(key) != headers.end();
}

inline const char *get_header_value(const Headers &headers,
                                    const std::string &key, const char *def,
                                    size_t id) {
  auto rng = headers.equal_range(key);
  auto it = rng.first;
  std::advance(it, static_cast<ssize_t>(id));
  if (it != rng.second) { return it->second.c_str(); }
  return def;
}

inline bool compare_case_ignore(const std::string &a, const std::string &b) {
  if (a.size() != b.size()) { return false; }
  for (size_t i = 0; i < b.size(); i++) {
    if (::tolower(a[i]) != ::tolower(b[i])) { return false; }
  }
  return true;
}

template <typename T>
inline bool parse_header(const char *beg, const char *end, T fn) {
  // Skip trailing spaces and tabs.
  while (beg < end && is_space_or_tab(end[-1])) {
    end--;
  }

  auto p = beg;
  while (p < end && *p != ':') {
    p++;
  }

  if (p == end) { return false; }

  auto key_end = p;

  if (*p++ != ':') { return false; }

  while (p < end && is_space_or_tab(*p)) {
    p++;
  }

  if (p < end) {
    auto key_len = key_end - beg;
    if (!key_len) { return false; }

    auto key = std::string(beg, key_end);
    auto val = compare_case_ignore(key, "Location")
                   ? std::string(p, end)
                   : decode_url(std::string(p, end), false);
    fn(key, val);
    return true;
  }

  return false;
}

inline bool read_headers(Stream &strm, Headers &headers) {
  const auto bufsiz = 2048;
  char buf[bufsiz];
  stream_line_reader line_reader(strm, buf, bufsiz);

  for (;;) {
    if (!line_reader.getline()) { return false; }

    // Check if the line ends with CRLF.
    auto line_terminator_len = 2;
    if (line_reader.end_with_crlf()) {
      // Blank line indicates end of headers.
      if (line_reader.size() == 2) { break; }
#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
    } else {
      // Blank line indicates end of headers.
      if (line_reader.size() == 1) { break; }
      line_terminator_len = 1;
    }
#else
    } else {
      continue; // Skip invalid line.
    }
#endif

    if (line_reader.size() > CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }

    // Exclude line terminator
    auto end = line_reader.ptr() + line_reader.size() - line_terminator_len;

    parse_header(line_reader.ptr(), end,
                 [&](const std::string &key, std::string &val) {
                   // NOTE: From RFC 9110:
                   // Field values containing CR, LF, or NUL characters are
                   // invalid and dangerous, due to the varying ways that
                   // implementations might parse and interpret those
                   // characters; a recipient of CR, LF, or NUL within a field
                   // value MUST either reject the message or replace each of
                   // those characters with SP before further processing or
                   // forwarding of that message.
                   for (auto &c : val) {
                     switch (c) {
                     case '\0':
                     case '\n':
                     case '\r': c = ' '; break;
                     }
                   }
                   headers.emplace(key, val);
                 });
  }

  return true;
}

inline bool read_content_with_length(Stream &strm, uint64_t len,
                                     Progress progress,
                                     ContentReceiverWithProgress out) {
  char buf[CPPHTTPLIB_RECV_BUFSIZ];

  uint64_t r = 0;
  while (r < len) {
    auto read_len = static_cast<size_t>(len - r);
    auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
    if (n <= 0) { return false; }

    if (!out(buf, static_cast<size_t>(n), r, len)) { return false; }
    r += static_cast<uint64_t>(n);

    if (progress) {
      if (!progress(r, len)) { return false; }
    }
  }

  return true;
}

inline void skip_content_with_length(Stream &strm, uint64_t len) {
  char buf[CPPHTTPLIB_RECV_BUFSIZ];
  uint64_t r = 0;
  while (r < len) {
    auto read_len = static_cast<size_t>(len - r);
    auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
    if (n <= 0) { return; }
    r += static_cast<uint64_t>(n);
  }
}

inline bool read_content_without_length(Stream &strm,
                                        ContentReceiverWithProgress out) {
  char buf[CPPHTTPLIB_RECV_BUFSIZ];
  uint64_t r = 0;
  for (;;) {
    auto n = strm.read(buf, CPPHTTPLIB_RECV_BUFSIZ);
    if (n <= 0) { return true; }

    if (!out(buf, static_cast<size_t>(n), r, 0)) { return false; }
    r += static_cast<uint64_t>(n);
  }

  return true;
}

template <typename T>
inline bool read_content_chunked(Stream &strm, T &x,
                                 ContentReceiverWithProgress out) {
  const auto bufsiz = 16;
  char buf[bufsiz];

  stream_line_reader line_reader(strm, buf, bufsiz);

  if (!line_reader.getline()) { return false; }

  unsigned long chunk_len;
  while (true) {
    char *end_ptr;

    chunk_len = std::strtoul(line_reader.ptr(), &end_ptr, 16);

    if (end_ptr == line_reader.ptr()) { return false; }
    if (chunk_len == ULONG_MAX) { return false; }

    if (chunk_len == 0) { break; }

    if (!read_content_with_length(strm, chunk_len, nullptr, out)) {
      return false;
    }

    if (!line_reader.getline()) { return false; }

    if (strcmp(line_reader.ptr(), "\r\n") != 0) { return false; }

    if (!line_reader.getline()) { return false; }
  }

  assert(chunk_len == 0);

  // Trailer
  if (!line_reader.getline()) { return false; }

  while (strcmp(line_reader.ptr(), "\r\n") != 0) {
    if (line_reader.size() > CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }

    // Exclude line terminator
    constexpr auto line_terminator_len = 2;
    auto end = line_reader.ptr() + line_reader.size() - line_terminator_len;

    parse_header(line_reader.ptr(), end,
                 [&](const std::string &key, const std::string &val) {
                   x.headers.emplace(key, val);
                 });

    if (!line_reader.getline()) { return false; }
  }

  return true;
}

inline bool is_chunked_transfer_encoding(const Headers &headers) {
  return compare_case_ignore(
      get_header_value(headers, "Transfer-Encoding", "", 0), "chunked");
}

template <typename T, typename U>
bool prepare_content_receiver(T &x, int &status,
                              ContentReceiverWithProgress receiver,
                              bool decompress, U callback) {
  if (decompress) {
    std::string encoding = x.get_header_value("Content-Encoding");
    std::unique_ptr<decompressor> decompressor;

    if (encoding == "gzip" || encoding == "deflate") {
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
      decompressor = detail::make_unique<gzip_decompressor>();
#else
      status = StatusCode::UnsupportedMediaType_415;
      return false;
#endif
    } else if (encoding.find("br") != std::string::npos) {
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
      decompressor = detail::make_unique<brotli_decompressor>();
#else
      status = StatusCode::UnsupportedMediaType_415;
      return false;
#endif
    }

    if (decompressor) {
      if (decompressor->is_valid()) {
        ContentReceiverWithProgress out = [&](const char *buf, size_t n,
                                              uint64_t off, uint64_t len) {
          return decompressor->decompress(buf, n,
                                          [&](const char *buf2, size_t n2) {
                                            return receiver(buf2, n2, off, len);
                                          });
        };
        return callback(std::move(out));
      } else {
        status = StatusCode::InternalServerError_500;
        return false;
      }
    }
  }

  ContentReceiverWithProgress out = [&](const char *buf, size_t n, uint64_t off,
                                        uint64_t len) {
    return receiver(buf, n, off, len);
  };
  return callback(std::move(out));
}

template <typename T>
bool read_content(Stream &strm, T &x, size_t payload_max_length, int &status,
                  Progress progress, ContentReceiverWithProgress receiver,
                  bool decompress) {
  return prepare_content_receiver(
      x, status, std::move(receiver), decompress,
      [&](const ContentReceiverWithProgress &out) {
        auto ret = true;
        auto exceed_payload_max_length = false;

        if (is_chunked_transfer_encoding(x.headers)) {
          ret = read_content_chunked(strm, x, out);
        } else if (!has_header(x.headers, "Content-Length")) {
          ret = read_content_without_length(strm, out);
        } else {
          auto len = get_header_value_u64(x.headers, "Content-Length", 0, 0);
          if (len > payload_max_length) {
            exceed_payload_max_length = true;
            skip_content_with_length(strm, len);
            ret = false;
          } else if (len > 0) {
            ret = read_content_with_length(strm, len, std::move(progress), out);
          }
        }

        if (!ret) {
          status = exceed_payload_max_length ? StatusCode::PayloadTooLarge_413
                                             : StatusCode::BadRequest_400;
        }
        return ret;
      });
} // namespace detail

inline ssize_t write_headers(Stream &strm, const Headers &headers) {
  ssize_t write_len = 0;
  for (const auto &x : headers) {
    auto len =
        strm.write_format("%s: %s\r\n", x.first.c_str(), x.second.c_str());
    if (len < 0) { return len; }
    write_len += len;
  }
  auto len = strm.write("\r\n");
  if (len < 0) { return len; }
  write_len += len;
  return write_len;
}

inline bool write_data(Stream &strm, const char *d, size_t l) {
  size_t offset = 0;
  while (offset < l) {
    auto length = strm.write(d + offset, l - offset);
    if (length < 0) { return false; }
    offset += static_cast<size_t>(length);
  }
  return true;
}

template <typename T>
inline bool write_content(Stream &strm, const ContentProvider &content_provider,
                          size_t offset, size_t length, T is_shutting_down,
                          Error &error) {
  size_t end_offset = offset + length;
  auto ok = true;
  DataSink data_sink;

  data_sink.write = [&](const char *d, size_t l) -> bool {
    if (ok) {
      if (strm.is_writable() && write_data(strm, d, l)) {
        offset += l;
      } else {
        ok = false;
      }
    }
    return ok;
  };

  data_sink.is_writable = [&]() -> bool { return strm.is_writable(); };

  while (offset < end_offset && !is_shutting_down()) {
    if (!strm.is_writable()) {
      error = Error::Write;
      return false;
    } else if (!content_provider(offset, end_offset - offset, data_sink)) {
      error = Error::Canceled;
      return false;
    } else if (!ok) {
      error = Error::Write;
      return false;
    }
  }

  error = Error::Success;
  return true;
}

template <typename T>
inline bool write_content(Stream &strm, const ContentProvider &content_provider,
                          size_t offset, size_t length,
                          const T &is_shutting_down) {
  auto error = Error::Success;
  return write_content(strm, content_provider, offset, length, is_shutting_down,
                       error);
}

template <typename T>
inline bool
write_content_without_length(Stream &strm,
                             const ContentProvider &content_provider,
                             const T &is_shutting_down) {
  size_t offset = 0;
  auto data_available = true;
  auto ok = true;
  DataSink data_sink;

  data_sink.write = [&](const char *d, size_t l) -> bool {
    if (ok) {
      offset += l;
      if (!strm.is_writable() || !write_data(strm, d, l)) { ok = false; }
    }
    return ok;
  };

  data_sink.is_writable = [&]() -> bool { return strm.is_writable(); };

  data_sink.done = [&](void) { data_available = false; };

  while (data_available && !is_shutting_down()) {
    if (!strm.is_writable()) {
      return false;
    } else if (!content_provider(offset, 0, data_sink)) {
      return false;
    } else if (!ok) {
      return false;
    }
  }
  return true;
}

template <typename T, typename U>
inline bool
write_content_chunked(Stream &strm, const ContentProvider &content_provider,
                      const T &is_shutting_down, U &compressor, Error &error) {
  size_t offset = 0;
  auto data_available = true;
  auto ok = true;
  DataSink data_sink;

  data_sink.write = [&](const char *d, size_t l) -> bool {
    if (ok) {
      data_available = l > 0;
      offset += l;

      std::string payload;
      if (compressor.compress(d, l, false,
                              [&](const char *data, size_t data_len) {
                                payload.append(data, data_len);
                                return true;
                              })) {
        if (!payload.empty()) {
          // Emit chunked response header and footer for each chunk
          auto chunk =
              from_i_to_hex(payload.size()) + "\r\n" + payload + "\r\n";
          if (!strm.is_writable() ||
              !write_data(strm, chunk.data(), chunk.size())) {
            ok = false;
          }
        }
      } else {
        ok = false;
      }
    }
    return ok;
  };

  data_sink.is_writable = [&]() -> bool { return strm.is_writable(); };

  auto done_with_trailer = [&](const Headers *trailer) {
    if (!ok) { return; }

    data_available = false;

    std::string payload;
    if (!compressor.compress(nullptr, 0, true,
                             [&](const char *data, size_t data_len) {
                               payload.append(data, data_len);
                               return true;
                             })) {
      ok = false;
      return;
    }

    if (!payload.empty()) {
      // Emit chunked response header and footer for each chunk
      auto chunk = from_i_to_hex(payload.size()) + "\r\n" + payload + "\r\n";
      if (!strm.is_writable() ||
          !write_data(strm, chunk.data(), chunk.size())) {
        ok = false;
        return;
      }
    }

    static const std::string done_marker("0\r\n");
    if (!write_data(strm, done_marker.data(), done_marker.size())) {
      ok = false;
    }

    // Trailer
    if (trailer) {
      for (const auto &kv : *trailer) {
        std::string field_line = kv.first + ": " + kv.second + "\r\n";
        if (!write_data(strm, field_line.data(), field_line.size())) {
          ok = false;
        }
      }
    }

    static const std::string crlf("\r\n");
    if (!write_data(strm, crlf.data(), crlf.size())) { ok = false; }
  };

  data_sink.done = [&](void) { done_with_trailer(nullptr); };

  data_sink.done_with_trailer = [&](const Headers &trailer) {
    done_with_trailer(&trailer);
  };

  while (data_available && !is_shutting_down()) {
    if (!strm.is_writable()) {
      error = Error::Write;
      return false;
    } else if (!content_provider(offset, 0, data_sink)) {
      error = Error::Canceled;
      return false;
    } else if (!ok) {
      error = Error::Write;
      return false;
    }
  }

  error = Error::Success;
  return true;
}

template <typename T, typename U>
inline bool write_content_chunked(Stream &strm,
                                  const ContentProvider &content_provider,
                                  const T &is_shutting_down, U &compressor) {
  auto error = Error::Success;
  return write_content_chunked(strm, content_provider, is_shutting_down,
                               compressor, error);
}

template <typename T>
inline bool redirect(T &cli, Request &req, Response &res,
                     const std::string &path, const std::string &location,
                     Error &error) {
  Request new_req = req;
  new_req.path = path;
  new_req.redirect_count_ -= 1;

  if (res.status == StatusCode::SeeOther_303 &&
      (req.method != "GET" && req.method != "HEAD")) {
    new_req.method = "GET";
    new_req.body.clear();
    new_req.headers.clear();
  }

  Response new_res;

  auto ret = cli.send(new_req, new_res, error);
  if (ret) {
    req = new_req;
    res = new_res;

    if (res.location.empty()) { res.location = location; }
  }
  return ret;
}

inline std::string params_to_query_str(const Params &params) {
  std::string query;

  for (auto it = params.begin(); it != params.end(); ++it) {
    if (it != params.begin()) { query += "&"; }
    query += it->first;
    query += "=";
    query += encode_query_param(it->second);
  }
  return query;
}

inline void parse_query_text(const char *data, std::size_t size,
                             Params &params) {
  std::set<std::string> cache;
  split(data, data + size, '&', [&](const char *b, const char *e) {
    std::string kv(b, e);
    if (cache.find(kv) != cache.end()) { return; }
    cache.insert(std::move(kv));

    std::string key;
    std::string val;
    divide(b, static_cast<std::size_t>(e - b), '=',
           [&](const char *lhs_data, std::size_t lhs_size, const char *rhs_data,
               std::size_t rhs_size) {
             key.assign(lhs_data, lhs_size);
             val.assign(rhs_data, rhs_size);
           });

    if (!key.empty()) {
      params.emplace(decode_url(key, true), decode_url(val, true));
    }
  });
}

inline void parse_query_text(const std::string &s, Params &params) {
  parse_query_text(s.data(), s.size(), params);
}

inline bool parse_multipart_boundary(const std::string &content_type,
                                     std::string &boundary) {
  auto boundary_keyword = "boundary=";
  auto pos = content_type.find(boundary_keyword);
  if (pos == std::string::npos) { return false; }
  auto end = content_type.find(';', pos);
  auto beg = pos + strlen(boundary_keyword);
  boundary = trim_double_quotes_copy(content_type.substr(beg, end - beg));
  return !boundary.empty();
}

inline void parse_disposition_params(const std::string &s, Params &params) {
  std::set<std::string> cache;
  split(s.data(), s.data() + s.size(), ';', [&](const char *b, const char *e) {
    std::string kv(b, e);
    if (cache.find(kv) != cache.end()) { return; }
    cache.insert(kv);

    std::string key;
    std::string val;
    split(b, e, '=', [&](const char *b2, const char *e2) {
      if (key.empty()) {
        key.assign(b2, e2);
      } else {
        val.assign(b2, e2);
      }
    });

    if (!key.empty()) {
      params.emplace(trim_double_quotes_copy((key)),
                     trim_double_quotes_copy((val)));
    }
  });
}

#ifdef CPPHTTPLIB_NO_EXCEPTIONS
inline bool parse_range_header(const std::string &s, Ranges &ranges) {
#else
inline bool parse_range_header(const std::string &s, Ranges &ranges) try {
#endif
  auto is_valid = [](const std::string &str) {
    return std::all_of(str.cbegin(), str.cend(),
                       [](unsigned char c) { return std::isdigit(c); });
  };

  if (s.size() > 7 && s.compare(0, 6, "bytes=") == 0) {
    const auto pos = static_cast<size_t>(6);
    const auto len = static_cast<size_t>(s.size() - 6);
    auto all_valid_ranges = true;
    split(&s[pos], &s[pos + len], ',', [&](const char *b, const char *e) {
      if (!all_valid_ranges) { return; }

      const auto it = std::find(b, e, '-');
      if (it == e) {
        all_valid_ranges = false;
        return;
      }

      const auto lhs = std::string(b, it);
      const auto rhs = std::string(it + 1, e);
      if (!is_valid(lhs) || !is_valid(rhs)) {
        all_valid_ranges = false;
        return;
      }

      const auto first =
          static_cast<ssize_t>(lhs.empty() ? -1 : std::stoll(lhs));
      const auto last =
          static_cast<ssize_t>(rhs.empty() ? -1 : std::stoll(rhs));
      if ((first == -1 && last == -1) ||
          (first != -1 && last != -1 && first > last)) {
        all_valid_ranges = false;
        return;
      }

      ranges.emplace_back(first, last);
    });
    return all_valid_ranges && !ranges.empty();
  }
  return false;
#ifdef CPPHTTPLIB_NO_EXCEPTIONS
}
#else
} catch (...) { return false; }
#endif

class MultipartFormDataParser {
public:
  MultipartFormDataParser() = default;

  void set_boundary(std::string &&boundary) {
    boundary_ = boundary;
    dash_boundary_crlf_ = dash_ + boundary_ + crlf_;
    crlf_dash_boundary_ = crlf_ + dash_ + boundary_;
  }

  bool is_valid() const { return is_valid_; }

  bool parse(const char *buf, size_t n, const ContentReceiver &content_callback,
             const MultipartContentHeader &header_callback) {

    buf_append(buf, n);

    while (buf_size() > 0) {
      switch (state_) {
      case 0: { // Initial boundary
        buf_erase(buf_find(dash_boundary_crlf_));
        if (dash_boundary_crlf_.size() > buf_size()) { return true; }
        if (!buf_start_with(dash_boundary_crlf_)) { return false; }
        buf_erase(dash_boundary_crlf_.size());
        state_ = 1;
        break;
      }
      case 1: { // New entry
        clear_file_info();
        state_ = 2;
        break;
      }
      case 2: { // Headers
        auto pos = buf_find(crlf_);
        if (pos > CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }
        while (pos < buf_size()) {
          // Empty line
          if (pos == 0) {
            if (!header_callback(file_)) {
              is_valid_ = false;
              return false;
            }
            buf_erase(crlf_.size());
            state_ = 3;
            break;
          }

          const auto header = buf_head(pos);

          if (!parse_header(header.data(), header.data() + header.size(),
                            [&](const std::string &, const std::string &) {})) {
            is_valid_ = false;
            return false;
          }

          static const std::string header_content_type = "Content-Type:";

          if (start_with_case_ignore(header, header_content_type)) {
            file_.content_type =
                trim_copy(header.substr(header_content_type.size()));
          } else {
            static const std::regex re_content_disposition(
                R"~(^Content-Disposition:\s*form-data;\s*(.*)$)~",
                std::regex_constants::icase);

            std::smatch m;
            if (std::regex_match(header, m, re_content_disposition)) {
              Params params;
              parse_disposition_params(m[1], params);

              auto it = params.find("name");
              if (it != params.end()) {
                file_.name = it->second;
              } else {
                is_valid_ = false;
                return false;
              }

              it = params.find("filename");
              if (it != params.end()) { file_.filename = it->second; }

              it = params.find("filename*");
              if (it != params.end()) {
                // Only allow UTF-8 enconnding...
                static const std::regex re_rfc5987_encoding(
                    R"~(^UTF-8''(.+?)$)~", std::regex_constants::icase);

                std::smatch m2;
                if (std::regex_match(it->second, m2, re_rfc5987_encoding)) {
                  file_.filename = decode_url(m2[1], false); // override...
                } else {
                  is_valid_ = false;
                  return false;
                }
              }
            }
          }
          buf_erase(pos + crlf_.size());
          pos = buf_find(crlf_);
        }
        if (state_ != 3) { return true; }
        break;
      }
      case 3: { // Body
        if (crlf_dash_boundary_.size() > buf_size()) { return true; }
        auto pos = buf_find(crlf_dash_boundary_);
        if (pos < buf_size()) {
          if (!content_callback(buf_data(), pos)) {
            is_valid_ = false;
            return false;
          }
          buf_erase(pos + crlf_dash_boundary_.size());
          state_ = 4;
        } else {
          auto len = buf_size() - crlf_dash_boundary_.size();
          if (len > 0) {
            if (!content_callback(buf_data(), len)) {
              is_valid_ = false;
              return false;
            }
            buf_erase(len);
          }
          return true;
        }
        break;
      }
      case 4: { // Boundary
        if (crlf_.size() > buf_size()) { return true; }
        if (buf_start_with(crlf_)) {
          buf_erase(crlf_.size());
          state_ = 1;
        } else {
          if (dash_.size() > buf_size()) { return true; }
          if (buf_start_with(dash_)) {
            buf_erase(dash_.size());
            is_valid_ = true;
            buf_erase(buf_size()); // Remove epilogue
          } else {
            return true;
          }
        }
        break;
      }
      }
    }

    return true;
  }

private:
  void clear_file_info() {
    file_.name.clear();
    file_.filename.clear();
    file_.content_type.clear();
  }

  bool start_with_case_ignore(const std::string &a,
                              const std::string &b) const {
    if (a.size() < b.size()) { return false; }
    for (size_t i = 0; i < b.size(); i++) {
      if (::tolower(a[i]) != ::tolower(b[i])) { return false; }
    }
    return true;
  }

  const std::string dash_ = "--";
  const std::string crlf_ = "\r\n";
  std::string boundary_;
  std::string dash_boundary_crlf_;
  std::string crlf_dash_boundary_;

  size_t state_ = 0;
  bool is_valid_ = false;
  MultipartFormData file_;

  // Buffer
  bool start_with(const std::string &a, size_t spos, size_t epos,
                  const std::string &b) const {
    if (epos - spos < b.size()) { return false; }
    for (size_t i = 0; i < b.size(); i++) {
      if (a[i + spos] != b[i]) { return false; }
    }
    return true;
  }

  size_t buf_size() const { return buf_epos_ - buf_spos_; }

  const char *buf_data() const { return &buf_[buf_spos_]; }

  std::string buf_head(size_t l) const { return buf_.substr(buf_spos_, l); }

  bool buf_start_with(const std::string &s) const {
    return start_with(buf_, buf_spos_, buf_epos_, s);
  }

  size_t buf_find(const std::string &s) const {
    auto c = s.front();

    size_t off = buf_spos_;
    while (off < buf_epos_) {
      auto pos = off;
      while (true) {
        if (pos == buf_epos_) { return buf_size(); }
        if (buf_[pos] == c) { break; }
        pos++;
      }

      auto remaining_size = buf_epos_ - pos;
      if (s.size() > remaining_size) { return buf_size(); }

      if (start_with(buf_, pos, buf_epos_, s)) { return pos - buf_spos_; }

      off = pos + 1;
    }

    return buf_size();
  }

  void buf_append(const char *data, size_t n) {
    auto remaining_size = buf_size();
    if (remaining_size > 0 && buf_spos_ > 0) {
      for (size_t i = 0; i < remaining_size; i++) {
        buf_[i] = buf_[buf_spos_ + i];
      }
    }
    buf_spos_ = 0;
    buf_epos_ = remaining_size;

    if (remaining_size + n > buf_.size()) { buf_.resize(remaining_size + n); }

    for (size_t i = 0; i < n; i++) {
      buf_[buf_epos_ + i] = data[i];
    }
    buf_epos_ += n;
  }

  void buf_erase(size_t size) { buf_spos_ += size; }

  std::string buf_;
  size_t buf_spos_ = 0;
  size_t buf_epos_ = 0;
};

inline std::string to_lower(const char *beg, const char *end) {
  std::string out;
  auto it = beg;
  while (it != end) {
    out += static_cast<char>(::tolower(*it));
    it++;
  }
  return out;
}

inline std::string random_string(size_t length) {
  static const char data[] =
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

  // std::random_device might actually be deterministic on some
  // platforms, but due to lack of support in the c++ standard library,
  // doing better requires either some ugly hacks or breaking portability.
  static std::random_device seed_gen;

  // Request 128 bits of entropy for initialization
  static std::seed_seq seed_sequence{seed_gen(), seed_gen(), seed_gen(),
                                     seed_gen()};

  static std::mt19937 engine(seed_sequence);

  std::string result;
  for (size_t i = 0; i < length; i++) {
    result += data[engine() % (sizeof(data) - 1)];
  }
  return result;
}

inline std::string make_multipart_data_boundary() {
  return "--cpp-httplib-multipart-data-" + detail::random_string(16);
}

inline bool is_multipart_boundary_chars_valid(const std::string &boundary) {
  auto valid = true;
  for (size_t i = 0; i < boundary.size(); i++) {
    auto c = boundary[i];
    if (!std::isalnum(c) && c != '-' && c != '_') {
      valid = false;
      break;
    }
  }
  return valid;
}

template <typename T>
inline std::string
serialize_multipart_formdata_item_begin(const T &item,
                                        const std::string &boundary) {
  std::string body = "--" + boundary + "\r\n";
  body += "Content-Disposition: form-data; name=\"" + item.name + "\"";
  if (!item.filename.empty()) {
    body += "; filename=\"" + item.filename + "\"";
  }
  body += "\r\n";
  if (!item.content_type.empty()) {
    body += "Content-Type: " + item.content_type + "\r\n";
  }
  body += "\r\n";

  return body;
}

inline std::string serialize_multipart_formdata_item_end() { return "\r\n"; }

inline std::string
serialize_multipart_formdata_finish(const std::string &boundary) {
  return "--" + boundary + "--\r\n";
}

inline std::string
serialize_multipart_formdata_get_content_type(const std::string &boundary) {
  return "multipart/form-data; boundary=" + boundary;
}

inline std::string
serialize_multipart_formdata(const MultipartFormDataItems &items,
                             const std::string &boundary, bool finish = true) {
  std::string body;

  for (const auto &item : items) {
    body += serialize_multipart_formdata_item_begin(item, boundary);
    body += item.content + serialize_multipart_formdata_item_end();
  }

  if (finish) { body += serialize_multipart_formdata_finish(boundary); }

  return body;
}

inline bool range_error(Request &req, Response &res) {
  if (!req.ranges.empty() && 200 <= res.status && res.status < 300) {
    ssize_t contant_len = static_cast<ssize_t>(
        res.content_length_ ? res.content_length_ : res.body.size());

    ssize_t prev_first_pos = -1;
    ssize_t prev_last_pos = -1;
    size_t overwrapping_count = 0;

    // NOTE: The following Range check is based on '14.2. Range' in RFC 9110
    // 'HTTP Semantics' to avoid potential denial-of-service attacks.
    // https://www.rfc-editor.org/rfc/rfc9110#section-14.2

    // Too many ranges
    if (req.ranges.size() > CPPHTTPLIB_RANGE_MAX_COUNT) { return true; }

    for (auto &r : req.ranges) {
      auto &first_pos = r.first;
      auto &last_pos = r.second;

      if (first_pos == -1 && last_pos == -1) {
        first_pos = 0;
        last_pos = contant_len;
      }

      if (first_pos == -1) {
        first_pos = contant_len - last_pos;
        last_pos = contant_len - 1;
      }

      if (last_pos == -1) { last_pos = contant_len - 1; }

      // Range must be within content length
      if (!(0 <= first_pos && first_pos <= last_pos &&
            last_pos <= contant_len - 1)) {
        return true;
      }

      // Ranges must be in ascending order
      if (first_pos <= prev_first_pos) { return true; }

      // Request must not have more than two overlapping ranges
      if (first_pos <= prev_last_pos) {
        overwrapping_count++;
        if (overwrapping_count > 2) { return true; }
      }

      prev_first_pos = (std::max)(prev_first_pos, first_pos);
      prev_last_pos = (std::max)(prev_last_pos, last_pos);
    }
  }

  return false;
}

inline std::pair<size_t, size_t>
get_range_offset_and_length(Range r, size_t content_length) {
  assert(r.first != -1 && r.second != -1);
  assert(0 <= r.first && r.first < static_cast<ssize_t>(content_length));
  assert(r.first <= r.second &&
         r.second < static_cast<ssize_t>(content_length));
  (void)(content_length);
  return std::make_pair(r.first, static_cast<size_t>(r.second - r.first) + 1);
}

inline std::string make_content_range_header_field(
    const std::pair<size_t, size_t> &offset_and_length, size_t content_length) {
  auto st = offset_and_length.first;
  auto ed = st + offset_and_length.second - 1;

  std::string field = "bytes ";
  field += std::to_string(st);
  field += "-";
  field += std::to_string(ed);
  field += "/";
  field += std::to_string(content_length);
  return field;
}

template <typename SToken, typename CToken, typename Content>
bool process_multipart_ranges_data(const Request &req,
                                   const std::string &boundary,
                                   const std::string &content_type,
                                   size_t content_length, SToken stoken,
                                   CToken ctoken, Content content) {
  for (size_t i = 0; i < req.ranges.size(); i++) {
    ctoken("--");
    stoken(boundary);
    ctoken("\r\n");
    if (!content_type.empty()) {
      ctoken("Content-Type: ");
      stoken(content_type);
      ctoken("\r\n");
    }

    auto offset_and_length =
        get_range_offset_and_length(req.ranges[i], content_length);

    ctoken("Content-Range: ");
    stoken(make_content_range_header_field(offset_and_length, content_length));
    ctoken("\r\n");
    ctoken("\r\n");

    if (!content(offset_and_length.first, offset_and_length.second)) {
      return false;
    }
    ctoken("\r\n");
  }

  ctoken("--");
  stoken(boundary);
  ctoken("--");

  return true;
}

inline void make_multipart_ranges_data(const Request &req, Response &res,
                                       const std::string &boundary,
                                       const std::string &content_type,
                                       size_t content_length,
                                       std::string &data) {
  process_multipart_ranges_data(
      req, boundary, content_type, content_length,
      [&](const std::string &token) { data += token; },
      [&](const std::string &token) { data += token; },
      [&](size_t offset, size_t length) {
        assert(offset + length <= content_length);
        data += res.body.substr(offset, length);
        return true;
      });
}

inline size_t get_multipart_ranges_data_length(const Request &req,
                                               const std::string &boundary,
                                               const std::string &content_type,
                                               size_t content_length) {
  size_t data_length = 0;

  process_multipart_ranges_data(
      req, boundary, content_type, content_length,
      [&](const std::string &token) { data_length += token.size(); },
      [&](const std::string &token) { data_length += token.size(); },
      [&](size_t /*offset*/, size_t length) {
        data_length += length;
        return true;
      });

  return data_length;
}

template <typename T>
inline bool
write_multipart_ranges_data(Stream &strm, const Request &req, Response &res,
                            const std::string &boundary,
                            const std::string &content_type,
                            size_t content_length, const T &is_shutting_down) {
  return process_multipart_ranges_data(
      req, boundary, content_type, content_length,
      [&](const std::string &token) { strm.write(token); },
      [&](const std::string &token) { strm.write(token); },
      [&](size_t offset, size_t length) {
        return write_content(strm, res.content_provider_, offset, length,
                             is_shutting_down);
      });
}

inline bool expect_content(const Request &req) {
  if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH" ||
      req.method == "PRI" || req.method == "DELETE") {
    return true;
  }
  // TODO: check if Content-Length is set
  return false;
}

inline bool has_crlf(const std::string &s) {
  auto p = s.c_str();
  while (*p) {
    if (*p == '\r' || *p == '\n') { return true; }
    p++;
  }
  return false;
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline std::string message_digest(const std::string &s, const EVP_MD *algo) {
  auto context = std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)>(
      EVP_MD_CTX_new(), EVP_MD_CTX_free);

  unsigned int hash_length = 0;
  unsigned char hash[EVP_MAX_MD_SIZE];

  EVP_DigestInit_ex(context.get(), algo, nullptr);
  EVP_DigestUpdate(context.get(), s.c_str(), s.size());
  EVP_DigestFinal_ex(context.get(), hash, &hash_length);

  std::stringstream ss;
  for (auto i = 0u; i < hash_length; ++i) {
    ss << std::hex << std::setw(2) << std::setfill('0')
       << static_cast<unsigned int>(hash[i]);
  }

  return ss.str();
}

inline std::string MD5(const std::string &s) {
  return message_digest(s, EVP_md5());
}

inline std::string SHA_256(const std::string &s) {
  return message_digest(s, EVP_sha256());
}

inline std::string SHA_512(const std::string &s) {
  return message_digest(s, EVP_sha512());
}
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
#ifdef _WIN32
// NOTE: This code came up with the following stackoverflow post:
// https://stackoverflow.com/questions/9507184/can-openssl-on-windows-use-the-system-certificate-store
inline bool load_system_certs_on_windows(X509_STORE *store) {
  auto hStore = CertOpenSystemStoreW((HCRYPTPROV_LEGACY)NULL, L"ROOT");
  if (!hStore) { return false; }

  auto result = false;
  PCCERT_CONTEXT pContext = NULL;
  while ((pContext = CertEnumCertificatesInStore(hStore, pContext)) !=
         nullptr) {
    auto encoded_cert =
        static_cast<const unsigned char *>(pContext->pbCertEncoded);

    auto x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);
    if (x509) {
      X509_STORE_add_cert(store, x509);
      X509_free(x509);
      result = true;
    }
  }

  CertFreeCertificateContext(pContext);
  CertCloseStore(hStore, 0);

  return result;
}
#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) && defined(__APPLE__)
#if TARGET_OS_OSX
template <typename T>
using CFObjectPtr =
    std::unique_ptr<typename std::remove_pointer<T>::type, void (*)(CFTypeRef)>;

inline void cf_object_ptr_deleter(CFTypeRef obj) {
  if (obj) { CFRelease(obj); }
}

inline bool retrieve_certs_from_keychain(CFObjectPtr<CFArrayRef> &certs) {
  CFStringRef keys[] = {kSecClass, kSecMatchLimit, kSecReturnRef};
  CFTypeRef values[] = {kSecClassCertificate, kSecMatchLimitAll,
                        kCFBooleanTrue};

  CFObjectPtr<CFDictionaryRef> query(
      CFDictionaryCreate(nullptr, reinterpret_cast<const void **>(keys), values,
                         sizeof(keys) / sizeof(keys[0]),
                         &kCFTypeDictionaryKeyCallBacks,
                         &kCFTypeDictionaryValueCallBacks),
      cf_object_ptr_deleter);

  if (!query) { return false; }

  CFTypeRef security_items = nullptr;
  if (SecItemCopyMatching(query.get(), &security_items) != errSecSuccess ||
      CFArrayGetTypeID() != CFGetTypeID(security_items)) {
    return false;
  }

  certs.reset(reinterpret_cast<CFArrayRef>(security_items));
  return true;
}

inline bool retrieve_root_certs_from_keychain(CFObjectPtr<CFArrayRef> &certs) {
  CFArrayRef root_security_items = nullptr;
  if (SecTrustCopyAnchorCertificates(&root_security_items) != errSecSuccess) {
    return false;
  }

  certs.reset(root_security_items);
  return true;
}

inline bool add_certs_to_x509_store(CFArrayRef certs, X509_STORE *store) {
  auto result = false;
  for (auto i = 0; i < CFArrayGetCount(certs); ++i) {
    const auto cert = reinterpret_cast<const __SecCertificate *>(
        CFArrayGetValueAtIndex(certs, i));

    if (SecCertificateGetTypeID() != CFGetTypeID(cert)) { continue; }

    CFDataRef cert_data = nullptr;
    if (SecItemExport(cert, kSecFormatX509Cert, 0, nullptr, &cert_data) !=
        errSecSuccess) {
      continue;
    }

    CFObjectPtr<CFDataRef> cert_data_ptr(cert_data, cf_object_ptr_deleter);

    auto encoded_cert = static_cast<const unsigned char *>(
        CFDataGetBytePtr(cert_data_ptr.get()));

    auto x509 =
        d2i_X509(NULL, &encoded_cert, CFDataGetLength(cert_data_ptr.get()));

    if (x509) {
      X509_STORE_add_cert(store, x509);
      X509_free(x509);
      result = true;
    }
  }

  return result;
}

inline bool load_system_certs_on_macos(X509_STORE *store) {
  auto result = false;
  CFObjectPtr<CFArrayRef> certs(nullptr, cf_object_ptr_deleter);
  if (retrieve_certs_from_keychain(certs) && certs) {
    result = add_certs_to_x509_store(certs.get(), store);
  }

  if (retrieve_root_certs_from_keychain(certs) && certs) {
    result = add_certs_to_x509_store(certs.get(), store) || result;
  }

  return result;
}
#endif // TARGET_OS_OSX
#endif // _WIN32
#endif // CPPHTTPLIB_OPENSSL_SUPPORT

#ifdef _WIN32
class WSInit {
public:
  WSInit() {
    WSADATA wsaData;
    if (WSAStartup(0x0002, &wsaData) == 0) is_valid_ = true;
  }

  ~WSInit() {
    if (is_valid_) WSACleanup();
  }

  bool is_valid_ = false;
};

static WSInit wsinit_;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline std::pair<std::string, std::string> make_digest_authentication_header(
    const Request &req, const std::map<std::string, std::string> &auth,
    size_t cnonce_count, const std::string &cnonce, const std::string &username,
    const std::string &password, bool is_proxy = false) {
  std::string nc;
  {
    std::stringstream ss;
    ss << std::setfill('0') << std::setw(8) << std::hex << cnonce_count;
    nc = ss.str();
  }

  std::string qop;
  if (auth.find("qop") != auth.end()) {
    qop = auth.at("qop");
    if (qop.find("auth-int") != std::string::npos) {
      qop = "auth-int";
    } else if (qop.find("auth") != std::string::npos) {
      qop = "auth";
    } else {
      qop.clear();
    }
  }

  std::string algo = "MD5";
  if (auth.find("algorithm") != auth.end()) { algo = auth.at("algorithm"); }

  std::string response;
  {
    auto H = algo == "SHA-256"   ? detail::SHA_256
             : algo == "SHA-512" ? detail::SHA_512
                                 : detail::MD5;

    auto A1 = username + ":" + auth.at("realm") + ":" + password;

    auto A2 = req.method + ":" + req.path;
    if (qop == "auth-int") { A2 += ":" + H(req.body); }

    if (qop.empty()) {
      response = H(H(A1) + ":" + auth.at("nonce") + ":" + H(A2));
    } else {
      response = H(H(A1) + ":" + auth.at("nonce") + ":" + nc + ":" + cnonce +
                   ":" + qop + ":" + H(A2));
    }
  }

  auto opaque = (auth.find("opaque") != auth.end()) ? auth.at("opaque") : "";

  auto field = "Digest username=\"" + username + "\", realm=\"" +
               auth.at("realm") + "\", nonce=\"" + auth.at("nonce") +
               "\", uri=\"" + req.path + "\", algorithm=" + algo +
               (qop.empty() ? ", response=\""
                            : ", qop=" + qop + ", nc=" + nc + ", cnonce=\"" +
                                  cnonce + "\", response=\"") +
               response + "\"" +
               (opaque.empty() ? "" : ", opaque=\"" + opaque + "\"");

  auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
  return std::make_pair(key, field);
}
#endif

inline bool parse_www_authenticate(const Response &res,
                                   std::map<std::string, std::string> &auth,
                                   bool is_proxy) {
  auto auth_key = is_proxy ? "Proxy-Authenticate" : "WWW-Authenticate";
  if (res.has_header(auth_key)) {
    static auto re = std::regex(R"~((?:(?:,\s*)?(.+?)=(?:"(.*?)"|([^,]*))))~");
    auto s = res.get_header_value(auth_key);
    auto pos = s.find(' ');
    if (pos != std::string::npos) {
      auto type = s.substr(0, pos);
      if (type == "Basic") {
        return false;
      } else if (type == "Digest") {
        s = s.substr(pos + 1);
        auto beg = std::sregex_iterator(s.begin(), s.end(), re);
        for (auto i = beg; i != std::sregex_iterator(); ++i) {
          const auto &m = *i;
          auto key = s.substr(static_cast<size_t>(m.position(1)),
                              static_cast<size_t>(m.length(1)));
          auto val = m.length(2) > 0
                         ? s.substr(static_cast<size_t>(m.position(2)),
                                    static_cast<size_t>(m.length(2)))
                         : s.substr(static_cast<size_t>(m.position(3)),
                                    static_cast<size_t>(m.length(3)));
          auth[key] = val;
        }
        return true;
      }
    }
  }
  return false;
}

class ContentProviderAdapter {
public:
  explicit ContentProviderAdapter(
      ContentProviderWithoutLength &&content_provider)
      : content_provider_(content_provider) {}

  bool operator()(size_t offset, size_t, DataSink &sink) {
    return content_provider_(offset, sink);
  }

private:
  ContentProviderWithoutLength content_provider_;
};

} // namespace detail

inline std::string hosted_at(const std::string &hostname) {
  std::vector<std::string> addrs;
  hosted_at(hostname, addrs);
  if (addrs.empty()) { return std::string(); }
  return addrs[0];
}

inline void hosted_at(const std::string &hostname,
                      std::vector<std::string> &addrs) {
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = 0;

  if (getaddrinfo(hostname.c_str(), nullptr, &hints, &result)) {
#if defined __linux__ && !defined __ANDROID__
    res_init();
#endif
    return;
  }

  for (auto rp = result; rp; rp = rp->ai_next) {
    const auto &addr =
        *reinterpret_cast<struct sockaddr_storage *>(rp->ai_addr);
    std::string ip;
    auto dummy = -1;
    if (detail::get_ip_and_port(addr, sizeof(struct sockaddr_storage), ip,
                                dummy)) {
      addrs.push_back(ip);
    }
  }

  freeaddrinfo(result);
}

inline std::string append_query_params(const std::string &path,
                                       const Params &params) {
  std::string path_with_query = path;
  const static std::regex re("[^?]+\\?.*");
  auto delm = std::regex_match(path, re) ? '&' : '?';
  path_with_query += delm + detail::params_to_query_str(params);
  return path_with_query;
}

// Header utilities
inline std::pair<std::string, std::string>
make_range_header(const Ranges &ranges) {
  std::string field = "bytes=";
  auto i = 0;
  for (const auto &r : ranges) {
    if (i != 0) { field += ", "; }
    if (r.first != -1) { field += std::to_string(r.first); }
    field += '-';
    if (r.second != -1) { field += std::to_string(r.second); }
    i++;
  }
  return std::make_pair("Range", std::move(field));
}

inline std::pair<std::string, std::string>
make_basic_authentication_header(const std::string &username,
                                 const std::string &password, bool is_proxy) {
  auto field = "Basic " + detail::base64_encode(username + ":" + password);
  auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
  return std::make_pair(key, std::move(field));
}

inline std::pair<std::string, std::string>
make_bearer_token_authentication_header(const std::string &token,
                                        bool is_proxy = false) {
  auto field = "Bearer " + token;
  auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
  return std::make_pair(key, std::move(field));
}

// Request implementation
inline bool Request::has_header(const std::string &key) const {
  return detail::has_header(headers, key);
}

inline std::string Request::get_header_value(const std::string &key,
                                             const char *def, size_t id) const {
  return detail::get_header_value(headers, key, def, id);
}

inline size_t Request::get_header_value_count(const std::string &key) const {
  auto r = headers.equal_range(key);
  return static_cast<size_t>(std::distance(r.first, r.second));
}

inline void Request::set_header(const std::string &key,
                                const std::string &val) {
  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
    headers.emplace(key, val);
  }
}

inline bool Request::has_param(const std::string &key) const {
  return params.find(key) != params.end();
}

inline std::string Request::get_param_value(const std::string &key,
                                            size_t id) const {
  auto rng = params.equal_range(key);
  auto it = rng.first;
  std::advance(it, static_cast<ssize_t>(id));
  if (it != rng.second) { return it->second; }
  return std::string();
}

inline size_t Request::get_param_value_count(const std::string &key) const {
  auto r = params.equal_range(key);
  return static_cast<size_t>(std::distance(r.first, r.second));
}

inline bool Request::is_multipart_form_data() const {
  const auto &content_type = get_header_value("Content-Type");
  return !content_type.rfind("multipart/form-data", 0);
}

inline bool Request::has_file(const std::string &key) const {
  return files.find(key) != files.end();
}

inline MultipartFormData Request::get_file_value(const std::string &key) const {
  auto it = files.find(key);
  if (it != files.end()) { return it->second; }
  return MultipartFormData();
}

inline std::vector<MultipartFormData>
Request::get_file_values(const std::string &key) const {
  std::vector<MultipartFormData> values;
  auto rng = files.equal_range(key);
  for (auto it = rng.first; it != rng.second; it++) {
    values.push_back(it->second);
  }
  return values;
}

// Response implementation
inline bool Response::has_header(const std::string &key) const {
  return headers.find(key) != headers.end();
}

inline std::string Response::get_header_value(const std::string &key,
                                              const char *def,
                                              size_t id) const {
  return detail::get_header_value(headers, key, def, id);
}

inline size_t Response::get_header_value_count(const std::string &key) const {
  auto r = headers.equal_range(key);
  return static_cast<size_t>(std::distance(r.first, r.second));
}

inline void Response::set_header(const std::string &key,
                                 const std::string &val) {
  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
    headers.emplace(key, val);
  }
}

inline void Response::set_redirect(const std::string &url, int stat) {
  if (!detail::has_crlf(url)) {
    set_header("Location", url);
    if (300 <= stat && stat < 400) {
      this->status = stat;
    } else {
      this->status = StatusCode::Found_302;
    }
  }
}

inline void Response::set_content(const char *s, size_t n,
                                  const std::string &content_type) {
  body.assign(s, n);

  auto rng = headers.equal_range("Content-Type");
  headers.erase(rng.first, rng.second);
  set_header("Content-Type", content_type);
}

inline void Response::set_content(const std::string &s,
                                  const std::string &content_type) {
  set_content(s.data(), s.size(), content_type);
}

inline void Response::set_content(std::string &&s,
                                  const std::string &content_type) {
  body = std::move(s);

  auto rng = headers.equal_range("Content-Type");
  headers.erase(rng.first, rng.second);
  set_header("Content-Type", content_type);
}

inline void Response::set_content_provider(
    size_t in_length, const std::string &content_type, ContentProvider provider,
    ContentProviderResourceReleaser resource_releaser) {
  set_header("Content-Type", content_type);
  content_length_ = in_length;
  if (in_length > 0) { content_provider_ = std::move(provider); }
  content_provider_resource_releaser_ = std::move(resource_releaser);
  is_chunked_content_provider_ = false;
}

inline void Response::set_content_provider(
    const std::string &content_type, ContentProviderWithoutLength provider,
    ContentProviderResourceReleaser resource_releaser) {
  set_header("Content-Type", content_type);
  content_length_ = 0;
  content_provider_ = detail::ContentProviderAdapter(std::move(provider));
  content_provider_resource_releaser_ = std::move(resource_releaser);
  is_chunked_content_provider_ = false;
}

inline void Response::set_chunked_content_provider(
    const std::string &content_type, ContentProviderWithoutLength provider,
    ContentProviderResourceReleaser resource_releaser) {
  set_header("Content-Type", content_type);
  content_length_ = 0;
  content_provider_ = detail::ContentProviderAdapter(std::move(provider));
  content_provider_resource_releaser_ = std::move(resource_releaser);
  is_chunked_content_provider_ = true;
}

// Result implementation
inline bool Result::has_request_header(const std::string &key) const {
  return request_headers_.find(key) != request_headers_.end();
}

inline std::string Result::get_request_header_value(const std::string &key,
                                                    const char *def,
                                                    size_t id) const {
  return detail::get_header_value(request_headers_, key, def, id);
}

inline size_t
Result::get_request_header_value_count(const std::string &key) const {
  auto r = request_headers_.equal_range(key);
  return static_cast<size_t>(std::distance(r.first, r.second));
}

// Stream implementation
inline ssize_t Stream::write(const char *ptr) {
  return write(ptr, strlen(ptr));
}

inline ssize_t Stream::write(const std::string &s) {
  return write(s.data(), s.size());
}

namespace detail {

// Socket stream implementation
inline SocketStream::SocketStream(socket_t sock, time_t read_timeout_sec,
                                  time_t read_timeout_usec,
                                  time_t write_timeout_sec,
                                  time_t write_timeout_usec)
    : sock_(sock), read_timeout_sec_(read_timeout_sec),
      read_timeout_usec_(read_timeout_usec),
      write_timeout_sec_(write_timeout_sec),
      write_timeout_usec_(write_timeout_usec), read_buff_(read_buff_size_, 0) {}

inline SocketStream::~SocketStream() = default;

inline bool SocketStream::is_readable() const {
  return select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;
}

inline bool SocketStream::is_writable() const {
  return select_write(sock_, write_timeout_sec_, write_timeout_usec_) > 0 &&
         is_socket_alive(sock_);
}

inline ssize_t SocketStream::read(char *ptr, size_t size) {
#ifdef _WIN32
  size =
      (std::min)(size, static_cast<size_t>((std::numeric_limits<int>::max)()));
#else
  size = (std::min)(size,
                    static_cast<size_t>((std::numeric_limits<ssize_t>::max)()));
#endif

  if (read_buff_off_ < read_buff_content_size_) {
    auto remaining_size = read_buff_content_size_ - read_buff_off_;
    if (size <= remaining_size) {
      memcpy(ptr, read_buff_.data() + read_buff_off_, size);
      read_buff_off_ += size;
      return static_cast<ssize_t>(size);
    } else {
      memcpy(ptr, read_buff_.data() + read_buff_off_, remaining_size);
      read_buff_off_ += remaining_size;
      return static_cast<ssize_t>(remaining_size);
    }
  }

  if (!is_readable()) { return -1; }

  read_buff_off_ = 0;
  read_buff_content_size_ = 0;

  if (size < read_buff_size_) {
    auto n = read_socket(sock_, read_buff_.data(), read_buff_size_,
                         CPPHTTPLIB_RECV_FLAGS);
    if (n <= 0) {
      return n;
    } else if (n <= static_cast<ssize_t>(size)) {
      memcpy(ptr, read_buff_.data(), static_cast<size_t>(n));
      return n;
    } else {
      memcpy(ptr, read_buff_.data(), size);
      read_buff_off_ = size;
      read_buff_content_size_ = static_cast<size_t>(n);
      return static_cast<ssize_t>(size);
    }
  } else {
    return read_socket(sock_, ptr, size, CPPHTTPLIB_RECV_FLAGS);
  }
}

inline ssize_t SocketStream::write(const char *ptr, size_t size) {
  if (!is_writable()) { return -1; }

#if defined(_WIN32) && !defined(_WIN64)
  size =
      (std::min)(size, static_cast<size_t>((std::numeric_limits<int>::max)()));
#endif

  return send_socket(sock_, ptr, size, CPPHTTPLIB_SEND_FLAGS);
}

inline void SocketStream::get_remote_ip_and_port(std::string &ip,
                                                 int &port) const {
  return detail::get_remote_ip_and_port(sock_, ip, port);
}

inline void SocketStream::get_local_ip_and_port(std::string &ip,
                                                int &port) const {
  return detail::get_local_ip_and_port(sock_, ip, port);
}

inline socket_t SocketStream::socket() const { return sock_; }

// Buffer stream implementation
inline bool BufferStream::is_readable() const { return true; }

inline bool BufferStream::is_writable() const { return true; }

inline ssize_t BufferStream::read(char *ptr, size_t size) {
#if defined(_MSC_VER) && _MSC_VER < 1910
  auto len_read = buffer._Copy_s(ptr, size, size, position);
#else
  auto len_read = buffer.copy(ptr, size, position);
#endif
  position += static_cast<size_t>(len_read);
  return static_cast<ssize_t>(len_read);
}

inline ssize_t BufferStream::write(const char *ptr, size_t size) {
  buffer.append(ptr, size);
  return static_cast<ssize_t>(size);
}

inline void BufferStream::get_remote_ip_and_port(std::string & /*ip*/,
                                                 int & /*port*/) const {}

inline void BufferStream::get_local_ip_and_port(std::string & /*ip*/,
                                                int & /*port*/) const {}

inline socket_t BufferStream::socket() const { return 0; }

inline const std::string &BufferStream::get_buffer() const { return buffer; }

inline PathParamsMatcher::PathParamsMatcher(const std::string &pattern) {
  // One past the last ending position of a path param substring
  std::size_t last_param_end = 0;

#ifndef CPPHTTPLIB_NO_EXCEPTIONS
  // Needed to ensure that parameter names are unique during matcher
  // construction
  // If exceptions are disabled, only last duplicate path
  // parameter will be set
  std::unordered_set<std::string> param_name_set;
#endif

  while (true) {
    const auto marker_pos = pattern.find(marker, last_param_end);
    if (marker_pos == std::string::npos) { break; }

    static_fragments_.push_back(
        pattern.substr(last_param_end, marker_pos - last_param_end));

    const auto param_name_start = marker_pos + 1;

    auto sep_pos = pattern.find(separator, param_name_start);
    if (sep_pos == std::string::npos) { sep_pos = pattern.length(); }

    auto param_name =
        pattern.substr(param_name_start, sep_pos - param_name_start);

#ifndef CPPHTTPLIB_NO_EXCEPTIONS
    if (param_name_set.find(param_name) != param_name_set.cend()) {
      std::string msg = "Encountered path parameter '" + param_name +
                        "' multiple times in route pattern '" + pattern + "'.";
      throw std::invalid_argument(msg);
    }
#endif

    param_names_.push_back(std::move(param_name));

    last_param_end = sep_pos + 1;
  }

  if (last_param_end < pattern.length()) {
    static_fragments_.push_back(pattern.substr(last_param_end));
  }
}

inline bool PathParamsMatcher::match(Request &request) const {
  request.matches = std::smatch();
  request.path_params.clear();
  request.path_params.reserve(param_names_.size());

  // One past the position at which the path matched the pattern last time
  std::size_t starting_pos = 0;
  for (size_t i = 0; i < static_fragments_.size(); ++i) {
    const auto &fragment = static_fragments_[i];

    if (starting_pos + fragment.length() > request.path.length()) {
      return false;
    }

    // Avoid unnecessary allocation by using strncmp instead of substr +
    // comparison
    if (std::strncmp(request.path.c_str() + starting_pos, fragment.c_str(),
                     fragment.length()) != 0) {
      return false;
    }

    starting_pos += fragment.length();

    // Should only happen when we have a static fragment after a param
    // Example: '/users/:id/subscriptions'
    // The 'subscriptions' fragment here does not have a corresponding param
    if (i >= param_names_.size()) { continue; }

    auto sep_pos = request.path.find(separator, starting_pos);
    if (sep_pos == std::string::npos) { sep_pos = request.path.length(); }

    const auto &param_name = param_names_[i];

    request.path_params.emplace(
        param_name, request.path.substr(starting_pos, sep_pos - starting_pos));

    // Mark everythin up to '/' as matched
    starting_pos = sep_pos + 1;
  }
  // Returns false if the path is longer than the pattern
  return starting_pos >= request.path.length();
}

inline bool RegexMatcher::match(Request &request) const {
  request.path_params.clear();
  return std::regex_match(request.path, request.matches, regex_);
}

} // namespace detail

// HTTP server implementation
inline Server::Server()
    : new_task_queue(
          [] { return new ThreadPool(CPPHTTPLIB_THREAD_POOL_COUNT); }) {
#ifndef _WIN32
  signal(SIGPIPE, SIG_IGN);
#endif
}

inline Server::~Server() = default;

inline std::unique_ptr<detail::MatcherBase>
Server::make_matcher(const std::string &pattern) {
  if (pattern.find("/:") != std::string::npos) {
    return detail::make_unique<detail::PathParamsMatcher>(pattern);
  } else {
    return detail::make_unique<detail::RegexMatcher>(pattern);
  }
}

inline Server &Server::Get(const std::string &pattern, Handler handler) {
  get_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &Server::Post(const std::string &pattern, Handler handler) {
  post_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &Server::Post(const std::string &pattern,
                            HandlerWithContentReader handler) {
  post_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                 std::move(handler));
  return *this;
}

inline Server &Server::Put(const std::string &pattern, Handler handler) {
  put_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &Server::Put(const std::string &pattern,
                           HandlerWithContentReader handler) {
  put_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                std::move(handler));
  return *this;
}

inline Server &Server::Patch(const std::string &pattern, Handler handler) {
  patch_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &Server::Patch(const std::string &pattern,
                             HandlerWithContentReader handler) {
  patch_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                  std::move(handler));
  return *this;
}

inline Server &Server::Delete(const std::string &pattern, Handler handler) {
  delete_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &Server::Delete(const std::string &pattern,
                              HandlerWithContentReader handler) {
  delete_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                   std::move(handler));
  return *this;
}

inline Server &Server::Options(const std::string &pattern, Handler handler) {
  options_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline bool Server::set_base_dir(const std::string &dir,
                                 const std::string &mount_point) {
  return set_mount_point(mount_point, dir);
}

inline bool Server::set_mount_point(const std::string &mount_point,
                                    const std::string &dir, Headers headers) {
  if (detail::is_dir(dir)) {
    std::string mnt = !mount_point.empty() ? mount_point : "/";
    if (!mnt.empty() && mnt[0] == '/') {
      base_dirs_.push_back({mnt, dir, std::move(headers)});
      return true;
    }
  }
  return false;
}

inline bool Server::remove_mount_point(const std::string &mount_point) {
  for (auto it = base_dirs_.begin(); it != base_dirs_.end(); ++it) {
    if (it->mount_point == mount_point) {
      base_dirs_.erase(it);
      return true;
    }
  }
  return false;
}

inline Server &
Server::set_file_extension_and_mimetype_mapping(const std::string &ext,
                                                const std::string &mime) {
  file_extension_and_mimetype_map_[ext] = mime;
  return *this;
}

inline Server &Server::set_default_file_mimetype(const std::string &mime) {
  default_file_mimetype_ = mime;
  return *this;
}

inline Server &Server::set_file_request_handler(Handler handler) {
  file_request_handler_ = std::move(handler);
  return *this;
}

inline Server &Server::set_error_handler_core(HandlerWithResponse handler,
                                              std::true_type) {
  error_handler_ = std::move(handler);
  return *this;
}

inline Server &Server::set_error_handler_core(Handler handler,
                                              std::false_type) {
  error_handler_ = [handler](const Request &req, Response &res) {
    handler(req, res);
    return HandlerResponse::Handled;
  };
  return *this;
}

inline Server &Server::set_exception_handler(ExceptionHandler handler) {
  exception_handler_ = std::move(handler);
  return *this;
}

inline Server &Server::set_pre_routing_handler(HandlerWithResponse handler) {
  pre_routing_handler_ = std::move(handler);
  return *this;
}

inline Server &Server::set_post_routing_handler(Handler handler) {
  post_routing_handler_ = std::move(handler);
  return *this;
}

inline Server &Server::set_logger(Logger logger) {
  logger_ = std::move(logger);
  return *this;
}

inline Server &
Server::set_expect_100_continue_handler(Expect100ContinueHandler handler) {
  expect_100_continue_handler_ = std::move(handler);
  return *this;
}

inline Server &Server::set_address_family(int family) {
  address_family_ = family;
  return *this;
}

inline Server &Server::set_tcp_nodelay(bool on) {
  tcp_nodelay_ = on;
  return *this;
}

inline Server &Server::set_ipv6_v6only(bool on) {
  ipv6_v6only_ = on;
  return *this;
}

inline Server &Server::set_socket_options(SocketOptions socket_options) {
  socket_options_ = std::move(socket_options);
  return *this;
}

inline Server &Server::set_default_headers(Headers headers) {
  default_headers_ = std::move(headers);
  return *this;
}

inline Server &Server::set_header_writer(
    std::function<ssize_t(Stream &, Headers &)> const &writer) {
  header_writer_ = writer;
  return *this;
}

inline Server &Server::set_keep_alive_max_count(size_t count) {
  keep_alive_max_count_ = count;
  return *this;
}

inline Server &Server::set_keep_alive_timeout(time_t sec) {
  keep_alive_timeout_sec_ = sec;
  return *this;
}

inline Server &Server::set_read_timeout(time_t sec, time_t usec) {
  read_timeout_sec_ = sec;
  read_timeout_usec_ = usec;
  return *this;
}

inline Server &Server::set_write_timeout(time_t sec, time_t usec) {
  write_timeout_sec_ = sec;
  write_timeout_usec_ = usec;
  return *this;
}

inline Server &Server::set_idle_interval(time_t sec, time_t usec) {
  idle_interval_sec_ = sec;
  idle_interval_usec_ = usec;
  return *this;
}

inline Server &Server::set_payload_max_length(size_t length) {
  payload_max_length_ = length;
  return *this;
}

inline bool Server::bind_to_port(const std::string &host, int port,
                                 int socket_flags) {
  auto ret = bind_internal(host, port, socket_flags);
  if (ret == -1) { is_decommisioned = true; }
  return ret >= 0;
}
inline int Server::bind_to_any_port(const std::string &host, int socket_flags) {
  auto ret = bind_internal(host, 0, socket_flags);
  if (ret == -1) { is_decommisioned = true; }
  return ret;
}

inline bool Server::listen_after_bind() { return listen_internal(); }

inline bool Server::listen(const std::string &host, int port,
                           int socket_flags) {
  return bind_to_port(host, port, socket_flags) && listen_internal();
}

inline bool Server::is_running() const { return is_running_; }

inline void Server::wait_until_ready() const {
  while (!is_running_ && !is_decommisioned) {
    std::this_thread::sleep_for(std::chrono::milliseconds{1});
  }
}

inline void Server::stop() {
  if (is_running_) {
    assert(svr_sock_ != INVALID_SOCKET);
    std::atomic<socket_t> sock(svr_sock_.exchange(INVALID_SOCKET));
    detail::shutdown_socket(sock);
    detail::close_socket(sock);
  }
  is_decommisioned = false;
}

inline void Server::decommission() { is_decommisioned = true; }

inline bool Server::parse_request_line(const char *s, Request &req) const {
  auto len = strlen(s);
  if (len < 2 || s[len - 2] != '\r' || s[len - 1] != '\n') { return false; }
  len -= 2;

  {
    size_t count = 0;

    detail::split(s, s + len, ' ', [&](const char *b, const char *e) {
      switch (count) {
      case 0: req.method = std::string(b, e); break;
      case 1: req.target = std::string(b, e); break;
      case 2: req.version = std::string(b, e); break;
      default: break;
      }
      count++;
    });

    if (count != 3) { return false; }
  }

  static const std::set<std::string> methods{
      "GET",     "HEAD",    "POST",  "PUT",   "DELETE",
      "CONNECT", "OPTIONS", "TRACE", "PATCH", "PRI"};

  if (methods.find(req.method) == methods.end()) { return false; }

  if (req.version != "HTTP/1.1" && req.version != "HTTP/1.0") { return false; }

  {
    // Skip URL fragment
    for (size_t i = 0; i < req.target.size(); i++) {
      if (req.target[i] == '#') {
        req.target.erase(i);
        break;
      }
    }

    detail::divide(req.target, '?',
                   [&](const char *lhs_data, std::size_t lhs_size,
                       const char *rhs_data, std::size_t rhs_size) {
                     req.path = detail::decode_url(
                         std::string(lhs_data, lhs_size), false);
                     detail::parse_query_text(rhs_data, rhs_size, req.params);
                   });
  }

  return true;
}

inline bool Server::write_response(Stream &strm, bool close_connection,
                                   Request &req, Response &res) {
  // NOTE: `req.ranges` should be empty, otherwise it will be applied
  // incorrectly to the error content.
  req.ranges.clear();
  return write_response_core(strm, close_connection, req, res, false);
}

inline bool Server::write_response_with_content(Stream &strm,
                                                bool close_connection,
                                                const Request &req,
                                                Response &res) {
  return write_response_core(strm, close_connection, req, res, true);
}

inline bool Server::write_response_core(Stream &strm, bool close_connection,
                                        const Request &req, Response &res,
                                        bool need_apply_ranges) {
  assert(res.status != -1);

  if (400 <= res.status && error_handler_ &&
      error_handler_(req, res) == HandlerResponse::Handled) {
    need_apply_ranges = true;
  }

  std::string content_type;
  std::string boundary;
  if (need_apply_ranges) { apply_ranges(req, res, content_type, boundary); }

  // Prepare additional headers
  if (close_connection || req.get_header_value("Connection") == "close") {
    res.set_header("Connection", "close");
  } else {
    std::stringstream ss;
    ss << "timeout=" << keep_alive_timeout_sec_
       << ", max=" << keep_alive_max_count_;
    res.set_header("Keep-Alive", ss.str());
  }

  if (!res.has_header("Content-Type") &&
      (!res.body.empty() || res.content_length_ > 0 || res.content_provider_)) {
    res.set_header("Content-Type", "text/plain");
  }

  if (!res.has_header("Content-Length") && res.body.empty() &&
      !res.content_length_ && !res.content_provider_) {
    res.set_header("Content-Length", "0");
  }

  if (!res.has_header("Accept-Ranges") && req.method == "HEAD") {
    res.set_header("Accept-Ranges", "bytes");
  }

  if (post_routing_handler_) { post_routing_handler_(req, res); }

  // Response line and headers
  {
    detail::BufferStream bstrm;

    if (!bstrm.write_format("HTTP/1.1 %d %s\r\n", res.status,
                            status_message(res.status))) {
      return false;
    }

    if (!header_writer_(bstrm, res.headers)) { return false; }

    // Flush buffer
    auto &data = bstrm.get_buffer();
    detail::write_data(strm, data.data(), data.size());
  }

  // Body
  auto ret = true;
  if (req.method != "HEAD") {
    if (!res.body.empty()) {
      if (!detail::write_data(strm, res.body.data(), res.body.size())) {
        ret = false;
      }
    } else if (res.content_provider_) {
      if (write_content_with_provider(strm, req, res, boundary, content_type)) {
        res.content_provider_success_ = true;
      } else {
        ret = false;
      }
    }
  }

  // Log
  if (logger_) { logger_(req, res); }

  return ret;
}

inline bool
Server::write_content_with_provider(Stream &strm, const Request &req,
                                    Response &res, const std::string &boundary,
                                    const std::string &content_type) {
  auto is_shutting_down = [this]() {
    return this->svr_sock_ == INVALID_SOCKET;
  };

  if (res.content_length_ > 0) {
    if (req.ranges.empty()) {
      return detail::write_content(strm, res.content_provider_, 0,
                                   res.content_length_, is_shutting_down);
    } else if (req.ranges.size() == 1) {
      auto offset_and_length = detail::get_range_offset_and_length(
          req.ranges[0], res.content_length_);

      return detail::write_content(strm, res.content_provider_,
                                   offset_and_length.first,
                                   offset_and_length.second, is_shutting_down);
    } else {
      return detail::write_multipart_ranges_data(
          strm, req, res, boundary, content_type, res.content_length_,
          is_shutting_down);
    }
  } else {
    if (res.is_chunked_content_provider_) {
      auto type = detail::encoding_type(req, res);

      std::unique_ptr<detail::compressor> compressor;
      if (type == detail::EncodingType::Gzip) {
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
        compressor = detail::make_unique<detail::gzip_compressor>();
#endif
      } else if (type == detail::EncodingType::Brotli) {
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
        compressor = detail::make_unique<detail::brotli_compressor>();
#endif
      } else {
        compressor = detail::make_unique<detail::nocompressor>();
      }
      assert(compressor != nullptr);

      return detail::write_content_chunked(strm, res.content_provider_,
                                           is_shutting_down, *compressor);
    } else {
      return detail::write_content_without_length(strm, res.content_provider_,
                                                  is_shutting_down);
    }
  }
}

inline bool Server::read_content(Stream &strm, Request &req, Response &res) {
  MultipartFormDataMap::iterator cur;
  auto file_count = 0;
  if (read_content_core(
          strm, req, res,
          // Regular
          [&](const char *buf, size_t n) {
            if (req.body.size() + n > req.body.max_size()) { return false; }
            req.body.append(buf, n);
            return true;
          },
          // Multipart
          [&](const MultipartFormData &file) {
            if (file_count++ == CPPHTTPLIB_MULTIPART_FORM_DATA_FILE_MAX_COUNT) {
              return false;
            }
            cur = req.files.emplace(file.name, file);
            return true;
          },
          [&](const char *buf, size_t n) {
            auto &content = cur->second.content;
            if (content.size() + n > content.max_size()) { return false; }
            content.append(buf, n);
            return true;
          })) {
    const auto &content_type = req.get_header_value("Content-Type");
    if (!content_type.find("application/x-www-form-urlencoded")) {
      if (req.body.size() > CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH) {
        res.status = StatusCode::PayloadTooLarge_413; // NOTE: should be 414?
        return false;
      }
      detail::parse_query_text(req.body, req.params);
    }
    return true;
  }
  return false;
}

inline bool Server::read_content_with_content_receiver(
    Stream &strm, Request &req, Response &res, ContentReceiver receiver,
    MultipartContentHeader multipart_header,
    ContentReceiver multipart_receiver) {
  return read_content_core(strm, req, res, std::move(receiver),
                           std::move(multipart_header),
                           std::move(multipart_receiver));
}

inline bool
Server::read_content_core(Stream &strm, Request &req, Response &res,
                          ContentReceiver receiver,
                          MultipartContentHeader multipart_header,
                          ContentReceiver multipart_receiver) const {
  detail::MultipartFormDataParser multipart_form_data_parser;
  ContentReceiverWithProgress out;

  if (req.is_multipart_form_data()) {
    const auto &content_type = req.get_header_value("Content-Type");
    std::string boundary;
    if (!detail::parse_multipart_boundary(content_type, boundary)) {
      res.status = StatusCode::BadRequest_400;
      return false;
    }

    multipart_form_data_parser.set_boundary(std::move(boundary));
    out = [&](const char *buf, size_t n, uint64_t /*off*/, uint64_t /*len*/) {
      /* For debug
      size_t pos = 0;
      while (pos < n) {
        auto read_size = (std::min)<size_t>(1, n - pos);
        auto ret = multipart_form_data_parser.parse(
            buf + pos, read_size, multipart_receiver, multipart_header);
        if (!ret) { return false; }
        pos += read_size;
      }
      return true;
      */
      return multipart_form_data_parser.parse(buf, n, multipart_receiver,
                                              multipart_header);
    };
  } else {
    out = [receiver](const char *buf, size_t n, uint64_t /*off*/,
                     uint64_t /*len*/) { return receiver(buf, n); };
  }

  if (req.method == "DELETE" && !req.has_header("Content-Length")) {
    return true;
  }

  if (!detail::read_content(strm, req, payload_max_length_, res.status, nullptr,
                            out, true)) {
    return false;
  }

  if (req.is_multipart_form_data()) {
    if (!multipart_form_data_parser.is_valid()) {
      res.status = StatusCode::BadRequest_400;
      return false;
    }
  }

  return true;
}

inline bool Server::handle_file_request(const Request &req, Response &res,
                                        bool head) {
  for (const auto &entry : base_dirs_) {
    // Prefix match
    if (!req.path.compare(0, entry.mount_point.size(), entry.mount_point)) {
      std::string sub_path = "/" + req.path.substr(entry.mount_point.size());
      if (detail::is_valid_path(sub_path)) {
        auto path = entry.base_dir + sub_path;
        if (path.back() == '/') { path += "index.html"; }

        if (detail::is_file(path)) {
          for (const auto &kv : entry.headers) {
            res.set_header(kv.first, kv.second);
          }

          auto mm = std::make_shared<detail::mmap>(path.c_str());
          if (!mm->is_open()) { return false; }

          res.set_content_provider(
              mm->size(),
              detail::find_content_type(path, file_extension_and_mimetype_map_,
                                        default_file_mimetype_),
              [mm](size_t offset, size_t length, DataSink &sink) -> bool {
                sink.write(mm->data() + offset, length);
                return true;
              });

          if (!head && file_request_handler_) {
            file_request_handler_(req, res);
          }

          return true;
        }
      }
    }
  }
  return false;
}

inline socket_t
Server::create_server_socket(const std::string &host, int port,
                             int socket_flags,
                             SocketOptions socket_options) const {
  return detail::create_socket(
      host, std::string(), port, address_family_, socket_flags, tcp_nodelay_,
      ipv6_v6only_, std::move(socket_options),
      [](socket_t sock, struct addrinfo &ai, bool & /*quit*/) -> bool {
        if (::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {
          return false;
        }
        if (::listen(sock, CPPHTTPLIB_LISTEN_BACKLOG)) { return false; }
        return true;
      });
}

inline int Server::bind_internal(const std::string &host, int port,
                                 int socket_flags) {
  if (is_decommisioned) { return -1; }

  if (!is_valid()) { return -1; }

  svr_sock_ = create_server_socket(host, port, socket_flags, socket_options_);
  if (svr_sock_ == INVALID_SOCKET) { return -1; }

  if (port == 0) {
    struct sockaddr_storage addr;
    socklen_t addr_len = sizeof(addr);
    if (getsockname(svr_sock_, reinterpret_cast<struct sockaddr *>(&addr),
                    &addr_len) == -1) {
      return -1;
    }
    if (addr.ss_family == AF_INET) {
      return ntohs(reinterpret_cast<struct sockaddr_in *>(&addr)->sin_port);
    } else if (addr.ss_family == AF_INET6) {
      return ntohs(reinterpret_cast<struct sockaddr_in6 *>(&addr)->sin6_port);
    } else {
      return -1;
    }
  } else {
    return port;
  }
}

inline bool Server::listen_internal() {
  if (is_decommisioned) { return false; }

  auto ret = true;
  is_running_ = true;
  auto se = detail::scope_exit([&]() { is_running_ = false; });

  {
    std::unique_ptr<TaskQueue> task_queue(new_task_queue());

    while (svr_sock_ != INVALID_SOCKET) {
#ifndef _WIN32
      if (idle_interval_sec_ > 0 || idle_interval_usec_ > 0) {
#endif
        auto val = detail::select_read(svr_sock_, idle_interval_sec_,
                                       idle_interval_usec_);
        if (val == 0) { // Timeout
          task_queue->on_idle();
          continue;
        }
#ifndef _WIN32
      }
#endif

#if defined _WIN32
      // sockets conneced via WASAccept inherit flags NO_HANDLE_INHERIT,
      // OVERLAPPED
      socket_t sock = WSAAccept(svr_sock_, nullptr, nullptr, nullptr, 0);
#elif defined SOCK_CLOEXEC
      socket_t sock = accept4(svr_sock_, nullptr, nullptr, SOCK_CLOEXEC);
#else
      socket_t sock = accept(svr_sock_, nullptr, nullptr);
#endif

      if (sock == INVALID_SOCKET) {
        if (errno == EMFILE) {
          // The per-process limit of open file descriptors has been reached.
          // Try to accept new connections after a short sleep.
          std::this_thread::sleep_for(std::chrono::milliseconds(1));
          continue;
        } else if (errno == EINTR || errno == EAGAIN) {
          continue;
        }
        if (svr_sock_ != INVALID_SOCKET) {
          detail::close_socket(svr_sock_);
          ret = false;
        } else {
          ; // The server socket was closed by user.
        }
        break;
      }

      {
#ifdef _WIN32
        auto timeout = static_cast<uint32_t>(read_timeout_sec_ * 1000 +
                                             read_timeout_usec_ / 1000);
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,
                   reinterpret_cast<const char *>(&timeout), sizeof(timeout));
#else
        timeval tv;
        tv.tv_sec = static_cast<long>(read_timeout_sec_);
        tv.tv_usec = static_cast<decltype(tv.tv_usec)>(read_timeout_usec_);
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,
                   reinterpret_cast<const void *>(&tv), sizeof(tv));
#endif
      }
      {

#ifdef _WIN32
        auto timeout = static_cast<uint32_t>(write_timeout_sec_ * 1000 +
                                             write_timeout_usec_ / 1000);
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO,
                   reinterpret_cast<const char *>(&timeout), sizeof(timeout));
#else
        timeval tv;
        tv.tv_sec = static_cast<long>(write_timeout_sec_);
        tv.tv_usec = static_cast<decltype(tv.tv_usec)>(write_timeout_usec_);
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO,
                   reinterpret_cast<const void *>(&tv), sizeof(tv));
#endif
      }

      if (!task_queue->enqueue(
              [this, sock]() { process_and_close_socket(sock); })) {
        detail::shutdown_socket(sock);
        detail::close_socket(sock);
      }
    }

    task_queue->shutdown();
  }

  is_decommisioned = !ret;
  return ret;
}

inline bool Server::routing(Request &req, Response &res, Stream &strm) {
  if (pre_routing_handler_ &&
      pre_routing_handler_(req, res) == HandlerResponse::Handled) {
    return true;
  }

  // File handler
  auto is_head_request = req.method == "HEAD";
  if ((req.method == "GET" || is_head_request) &&
      handle_file_request(req, res, is_head_request)) {
    return true;
  }

  if (detail::expect_content(req)) {
    // Content reader handler
    {
      ContentReader reader(
          [&](ContentReceiver receiver) {
            return read_content_with_content_receiver(
                strm, req, res, std::move(receiver), nullptr, nullptr);
          },
          [&](MultipartContentHeader header, ContentReceiver receiver) {
            return read_content_with_content_receiver(strm, req, res, nullptr,
                                                      std::move(header),
                                                      std::move(receiver));
          });

      if (req.method == "POST") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                post_handlers_for_content_reader_)) {
          return true;
        }
      } else if (req.method == "PUT") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                put_handlers_for_content_reader_)) {
          return true;
        }
      } else if (req.method == "PATCH") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                patch_handlers_for_content_reader_)) {
          return true;
        }
      } else if (req.method == "DELETE") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                delete_handlers_for_content_reader_)) {
          return true;
        }
      }
    }

    // Read content into `req.body`
    if (!read_content(strm, req, res)) { return false; }
  }

  // Regular handler
  if (req.method == "GET" || req.method == "HEAD") {
    return dispatch_request(req, res, get_handlers_);
  } else if (req.method == "POST") {
    return dispatch_request(req, res, post_handlers_);
  } else if (req.method == "PUT") {
    return dispatch_request(req, res, put_handlers_);
  } else if (req.method == "DELETE") {
    return dispatch_request(req, res, delete_handlers_);
  } else if (req.method == "OPTIONS") {
    return dispatch_request(req, res, options_handlers_);
  } else if (req.method == "PATCH") {
    return dispatch_request(req, res, patch_handlers_);
  }

  res.status = StatusCode::BadRequest_400;
  return false;
}

inline bool Server::dispatch_request(Request &req, Response &res,
                                     const Handlers &handlers) const {
  for (const auto &x : handlers) {
    const auto &matcher = x.first;
    const auto &handler = x.second;

    if (matcher->match(req)) {
      handler(req, res);
      return true;
    }
  }
  return false;
}

inline void Server::apply_ranges(const Request &req, Response &res,
                                 std::string &content_type,
                                 std::string &boundary) const {
  if (req.ranges.size() > 1 && res.status == StatusCode::PartialContent_206) {
    auto it = res.headers.find("Content-Type");
    if (it != res.headers.end()) {
      content_type = it->second;
      res.headers.erase(it);
    }

    boundary = detail::make_multipart_data_boundary();

    res.set_header("Content-Type",
                   "multipart/byteranges; boundary=" + boundary);
  }

  auto type = detail::encoding_type(req, res);

  if (res.body.empty()) {
    if (res.content_length_ > 0) {
      size_t length = 0;
      if (req.ranges.empty() || res.status != StatusCode::PartialContent_206) {
        length = res.content_length_;
      } else if (req.ranges.size() == 1) {
        auto offset_and_length = detail::get_range_offset_and_length(
            req.ranges[0], res.content_length_);

        length = offset_and_length.second;

        auto content_range = detail::make_content_range_header_field(
            offset_and_length, res.content_length_);
        res.set_header("Content-Range", content_range);
      } else {
        length = detail::get_multipart_ranges_data_length(
            req, boundary, content_type, res.content_length_);
      }
      res.set_header("Content-Length", std::to_string(length));
    } else {
      if (res.content_provider_) {
        if (res.is_chunked_content_provider_) {
          res.set_header("Transfer-Encoding", "chunked");
          if (type == detail::EncodingType::Gzip) {
            res.set_header("Content-Encoding", "gzip");
          } else if (type == detail::EncodingType::Brotli) {
            res.set_header("Content-Encoding", "br");
          }
        }
      }
    }
  } else {
    if (req.ranges.empty() || res.status != StatusCode::PartialContent_206) {
      ;
    } else if (req.ranges.size() == 1) {
      auto offset_and_length =
          detail::get_range_offset_and_length(req.ranges[0], res.body.size());
      auto offset = offset_and_length.first;
      auto length = offset_and_length.second;

      auto content_range = detail::make_content_range_header_field(
          offset_and_length, res.body.size());
      res.set_header("Content-Range", content_range);

      assert(offset + length <= res.body.size());
      res.body = res.body.substr(offset, length);
    } else {
      std::string data;
      detail::make_multipart_ranges_data(req, res, boundary, content_type,
                                         res.body.size(), data);
      res.body.swap(data);
    }

    if (type != detail::EncodingType::None) {
      std::unique_ptr<detail::compressor> compressor;
      std::string content_encoding;

      if (type == detail::EncodingType::Gzip) {
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
        compressor = detail::make_unique<detail::gzip_compressor>();
        content_encoding = "gzip";
#endif
      } else if (type == detail::EncodingType::Brotli) {
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
        compressor = detail::make_unique<detail::brotli_compressor>();
        content_encoding = "br";
#endif
      }

      if (compressor) {
        std::string compressed;
        if (compressor->compress(res.body.data(), res.body.size(), true,
                                 [&](const char *data, size_t data_len) {
                                   compressed.append(data, data_len);
                                   return true;
                                 })) {
          res.body.swap(compressed);
          res.set_header("Content-Encoding", content_encoding);
        }
      }
    }

    auto length = std::to_string(res.body.size());
    res.set_header("Content-Length", length);
  }
}

inline bool Server::dispatch_request_for_content_reader(
    Request &req, Response &res, ContentReader content_reader,
    const HandlersForContentReader &handlers) const {
  for (const auto &x : handlers) {
    const auto &matcher = x.first;
    const auto &handler = x.second;

    if (matcher->match(req)) {
      handler(req, res, content_reader);
      return true;
    }
  }
  return false;
}

inline bool
Server::process_request(Stream &strm, bool close_connection,
                        bool &connection_closed,
                        const std::function<void(Request &)> &setup_request) {
  std::array<char, 2048> buf{};

  detail::stream_line_reader line_reader(strm, buf.data(), buf.size());

  // Connection has been closed on client
  if (!line_reader.getline()) { return false; }

  Request req;

  Response res;
  res.version = "HTTP/1.1";
  res.headers = default_headers_;

#ifdef _WIN32
  // TODO: Increase FD_SETSIZE statically (libzmq), dynamically (MySQL).
#else
#ifndef CPPHTTPLIB_USE_POLL
  // Socket file descriptor exceeded FD_SETSIZE...
  if (strm.socket() >= FD_SETSIZE) {
    Headers dummy;
    detail::read_headers(strm, dummy);
    res.status = StatusCode::InternalServerError_500;
    return write_response(strm, close_connection, req, res);
  }
#endif
#endif

  // Check if the request URI doesn't exceed the limit
  if (line_reader.size() > CPPHTTPLIB_REQUEST_URI_MAX_LENGTH) {
    Headers dummy;
    detail::read_headers(strm, dummy);
    res.status = StatusCode::UriTooLong_414;
    return write_response(strm, close_connection, req, res);
  }

  // Request line and headers
  if (!parse_request_line(line_reader.ptr(), req) ||
      !detail::read_headers(strm, req.headers)) {
    res.status = StatusCode::BadRequest_400;
    return write_response(strm, close_connection, req, res);
  }

  if (req.get_header_value("Connection") == "close") {
    connection_closed = true;
  }

  if (req.version == "HTTP/1.0" &&
      req.get_header_value("Connection") != "Keep-Alive") {
    connection_closed = true;
  }

  strm.get_remote_ip_and_port(req.remote_addr, req.remote_port);
  req.set_header("REMOTE_ADDR", req.remote_addr);
  req.set_header("REMOTE_PORT", std::to_string(req.remote_port));

  strm.get_local_ip_and_port(req.local_addr, req.local_port);
  req.set_header("LOCAL_ADDR", req.local_addr);
  req.set_header("LOCAL_PORT", std::to_string(req.local_port));

  if (req.has_header("Range")) {
    const auto &range_header_value = req.get_header_value("Range");
    if (!detail::parse_range_header(range_header_value, req.ranges)) {
      res.status = StatusCode::RangeNotSatisfiable_416;
      return write_response(strm, close_connection, req, res);
    }
  }

  if (setup_request) { setup_request(req); }

  if (req.get_header_value("Expect") == "100-continue") {
    int status = StatusCode::Continue_100;
    if (expect_100_continue_handler_) {
      status = expect_100_continue_handler_(req, res);
    }
    switch (status) {
    case StatusCode::Continue_100:
    case StatusCode::ExpectationFailed_417:
      strm.write_format("HTTP/1.1 %d %s\r\n\r\n", status,
                        status_message(status));
      break;
    default: return write_response(strm, close_connection, req, res);
    }
  }

  // Routing
  auto routed = false;
#ifdef CPPHTTPLIB_NO_EXCEPTIONS
  routed = routing(req, res, strm);
#else
  try {
    routed = routing(req, res, strm);
  } catch (std::exception &e) {
    if (exception_handler_) {
      auto ep = std::current_exception();
      exception_handler_(req, res, ep);
      routed = true;
    } else {
      res.status = StatusCode::InternalServerError_500;
      std::string val;
      auto s = e.what();
      for (size_t i = 0; s[i]; i++) {
        switch (s[i]) {
        case '\r': val += "\\r"; break;
        case '\n': val += "\\n"; break;
        default: val += s[i]; break;
        }
      }
      res.set_header("EXCEPTION_WHAT", val);
    }
  } catch (...) {
    if (exception_handler_) {
      auto ep = std::current_exception();
      exception_handler_(req, res, ep);
      routed = true;
    } else {
      res.status = StatusCode::InternalServerError_500;
      res.set_header("EXCEPTION_WHAT", "UNKNOWN");
    }
  }
#endif
  if (routed) {
    if (res.status == -1) {
      res.status = req.ranges.empty() ? StatusCode::OK_200
                                      : StatusCode::PartialContent_206;
    }

    if (detail::range_error(req, res)) {
      res.body.clear();
      res.content_length_ = 0;
      res.content_provider_ = nullptr;
      res.status = StatusCode::RangeNotSatisfiable_416;
      return write_response(strm, close_connection, req, res);
    }

    return write_response_with_content(strm, close_connection, req, res);
  } else {
    if (res.status == -1) { res.status = StatusCode::NotFound_404; }

    return write_response(strm, close_connection, req, res);
  }
}

inline bool Server::is_valid() const { return true; }

inline bool Server::process_and_close_socket(socket_t sock) {
  auto ret = detail::process_server_socket(
      svr_sock_, sock, keep_alive_max_count_, keep_alive_timeout_sec_,
      read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
      write_timeout_usec_,
      [this](Stream &strm, bool close_connection, bool &connection_closed) {
        return process_request(strm, close_connection, connection_closed,
                               nullptr);
      });

  detail::shutdown_socket(sock);
  detail::close_socket(sock);
  return ret;
}

// HTTP client implementation
inline ClientImpl::ClientImpl(const std::string &host)
    : ClientImpl(host, 80, std::string(), std::string()) {}

inline ClientImpl::ClientImpl(const std::string &host, int port)
    : ClientImpl(host, port, std::string(), std::string()) {}

inline ClientImpl::ClientImpl(const std::string &host, int port,
                              const std::string &client_cert_path,
                              const std::string &client_key_path)
    : host_(host), port_(port),
      host_and_port_(adjust_host_string(host) + ":" + std::to_string(port)),
      client_cert_path_(client_cert_path), client_key_path_(client_key_path) {}

inline ClientImpl::~ClientImpl() {
  std::lock_guard<std::mutex> guard(socket_mutex_);
  shutdown_socket(socket_);
  close_socket(socket_);
}

inline bool ClientImpl::is_valid() const { return true; }

inline void ClientImpl::copy_settings(const ClientImpl &rhs) {
  client_cert_path_ = rhs.client_cert_path_;
  client_key_path_ = rhs.client_key_path_;
  connection_timeout_sec_ = rhs.connection_timeout_sec_;
  read_timeout_sec_ = rhs.read_timeout_sec_;
  read_timeout_usec_ = rhs.read_timeout_usec_;
  write_timeout_sec_ = rhs.write_timeout_sec_;
  write_timeout_usec_ = rhs.write_timeout_usec_;
  basic_auth_username_ = rhs.basic_auth_username_;
  basic_auth_password_ = rhs.basic_auth_password_;
  bearer_token_auth_token_ = rhs.bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  digest_auth_username_ = rhs.digest_auth_username_;
  digest_auth_password_ = rhs.digest_auth_password_;
#endif
  keep_alive_ = rhs.keep_alive_;
  follow_location_ = rhs.follow_location_;
  url_encode_ = rhs.url_encode_;
  address_family_ = rhs.address_family_;
  tcp_nodelay_ = rhs.tcp_nodelay_;
  ipv6_v6only_ = rhs.ipv6_v6only_;
  socket_options_ = rhs.socket_options_;
  compress_ = rhs.compress_;
  decompress_ = rhs.decompress_;
  interface_ = rhs.interface_;
  proxy_host_ = rhs.proxy_host_;
  proxy_port_ = rhs.proxy_port_;
  proxy_basic_auth_username_ = rhs.proxy_basic_auth_username_;
  proxy_basic_auth_password_ = rhs.proxy_basic_auth_password_;
  proxy_bearer_token_auth_token_ = rhs.proxy_bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  proxy_digest_auth_username_ = rhs.proxy_digest_auth_username_;
  proxy_digest_auth_password_ = rhs.proxy_digest_auth_password_;
#endif
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  ca_cert_file_path_ = rhs.ca_cert_file_path_;
  ca_cert_dir_path_ = rhs.ca_cert_dir_path_;
  ca_cert_store_ = rhs.ca_cert_store_;
#endif
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  server_certificate_verification_ = rhs.server_certificate_verification_;
#endif
  logger_ = rhs.logger_;
}

inline socket_t ClientImpl::create_client_socket(Error &error) const {
  if (!proxy_host_.empty() && proxy_port_ != -1) {
    return detail::create_client_socket(
        proxy_host_, std::string(), proxy_port_, address_family_, tcp_nodelay_,
        ipv6_v6only_, socket_options_, connection_timeout_sec_,
        connection_timeout_usec_, read_timeout_sec_, read_timeout_usec_,
        write_timeout_sec_, write_timeout_usec_, interface_, error);
  }

  // Check is custom IP specified for host_
  std::string ip;
  auto it = addr_map_.find(host_);
  if (it != addr_map_.end()) { ip = it->second; }

  return detail::create_client_socket(
      host_, ip, port_, address_family_, tcp_nodelay_, ipv6_v6only_,
      socket_options_, connection_timeout_sec_, connection_timeout_usec_,
      read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
      write_timeout_usec_, interface_, error);
}

inline bool ClientImpl::create_and_connect_socket(Socket &socket,
                                                  Error &error) {
  auto sock = create_client_socket(error);
  if (sock == INVALID_SOCKET) { return false; }
  socket.sock = sock;
  return true;
}

inline void ClientImpl::shutdown_ssl(Socket & /*socket*/,
                                     bool /*shutdown_gracefully*/) {
  // If there are any requests in flight from threads other than us, then it's
  // a thread-unsafe race because individual ssl* objects are not thread-safe.
  assert(socket_requests_in_flight_ == 0 ||
         socket_requests_are_from_thread_ == std::this_thread::get_id());
}

inline void ClientImpl::shutdown_socket(Socket &socket) const {
  if (socket.sock == INVALID_SOCKET) { return; }
  detail::shutdown_socket(socket.sock);
}

inline void ClientImpl::close_socket(Socket &socket) {
  // If there are requests in flight in another thread, usually closing
  // the socket will be fine and they will simply receive an error when
  // using the closed socket, but it is still a bug since rarely the OS
  // may reassign the socket id to be used for a new socket, and then
  // suddenly they will be operating on a live socket that is different
  // than the one they intended!
  assert(socket_requests_in_flight_ == 0 ||
         socket_requests_are_from_thread_ == std::this_thread::get_id());

  // It is also a bug if this happens while SSL is still active
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  assert(socket.ssl == nullptr);
#endif
  if (socket.sock == INVALID_SOCKET) { return; }
  detail::close_socket(socket.sock);
  socket.sock = INVALID_SOCKET;
}

inline bool ClientImpl::read_response_line(Stream &strm, const Request &req,
                                           Response &res) const {
  std::array<char, 2048> buf{};

  detail::stream_line_reader line_reader(strm, buf.data(), buf.size());

  if (!line_reader.getline()) { return false; }

#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
  const static std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r?\n");
#else
  const static std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r\n");
#endif

  std::cmatch m;
  if (!std::regex_match(line_reader.ptr(), m, re)) {
    return req.method == "CONNECT";
  }
  res.version = std::string(m[1]);
  res.status = std::stoi(std::string(m[2]));
  res.reason = std::string(m[3]);

  // Ignore '100 Continue'
  while (res.status == StatusCode::Continue_100) {
    if (!line_reader.getline()) { return false; } // CRLF
    if (!line_reader.getline()) { return false; } // next response line

    if (!std::regex_match(line_reader.ptr(), m, re)) { return false; }
    res.version = std::string(m[1]);
    res.status = std::stoi(std::string(m[2]));
    res.reason = std::string(m[3]);
  }

  return true;
}

inline bool ClientImpl::send(Request &req, Response &res, Error &error) {
  std::lock_guard<std::recursive_mutex> request_mutex_guard(request_mutex_);
  auto ret = send_(req, res, error);
  if (error == Error::SSLPeerCouldBeClosed_) {
    assert(!ret);
    ret = send_(req, res, error);
  }
  return ret;
}

inline bool ClientImpl::send_(Request &req, Response &res, Error &error) {
  {
    std::lock_guard<std::mutex> guard(socket_mutex_);

    // Set this to false immediately - if it ever gets set to true by the end of
    // the request, we know another thread instructed us to close the socket.
    socket_should_be_closed_when_request_is_done_ = false;

    auto is_alive = false;
    if (socket_.is_open()) {
      is_alive = detail::is_socket_alive(socket_.sock);
      if (!is_alive) {
        // Attempt to avoid sigpipe by shutting down nongracefully if it seems
        // like the other side has already closed the connection Also, there
        // cannot be any requests in flight from other threads since we locked
        // request_mutex_, so safe to close everything immediately
        const bool shutdown_gracefully = false;
        shutdown_ssl(socket_, shutdown_gracefully);
        shutdown_socket(socket_);
        close_socket(socket_);
      }
    }

    if (!is_alive) {
      if (!create_and_connect_socket(socket_, error)) { return false; }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      // TODO: refactoring
      if (is_ssl()) {
        auto &scli = static_cast<SSLClient &>(*this);
        if (!proxy_host_.empty() && proxy_port_ != -1) {
          auto success = false;
          if (!scli.connect_with_proxy(socket_, res, success, error)) {
            return success;
          }
        }

        if (!scli.initialize_ssl(socket_, error)) { return false; }
      }
#endif
    }

    // Mark the current socket as being in use so that it cannot be closed by
    // anyone else while this request is ongoing, even though we will be
    // releasing the mutex.
    if (socket_requests_in_flight_ > 1) {
      assert(socket_requests_are_from_thread_ == std::this_thread::get_id());
    }
    socket_requests_in_flight_ += 1;
    socket_requests_are_from_thread_ = std::this_thread::get_id();
  }

  for (const auto &header : default_headers_) {
    if (req.headers.find(header.first) == req.headers.end()) {
      req.headers.insert(header);
    }
  }

  auto ret = false;
  auto close_connection = !keep_alive_;

  auto se = detail::scope_exit([&]() {
    // Briefly lock mutex in order to mark that a request is no longer ongoing
    std::lock_guard<std::mutex> guard(socket_mutex_);
    socket_requests_in_flight_ -= 1;
    if (socket_requests_in_flight_ <= 0) {
      assert(socket_requests_in_flight_ == 0);
      socket_requests_are_from_thread_ = std::thread::id();
    }

    if (socket_should_be_closed_when_request_is_done_ || close_connection ||
        !ret) {
      shutdown_ssl(socket_, true);
      shutdown_socket(socket_);
      close_socket(socket_);
    }
  });

  ret = process_socket(socket_, [&](Stream &strm) {
    return handle_request(strm, req, res, close_connection, error);
  });

  if (!ret) {
    if (error == Error::Success) { error = Error::Unknown; }
  }

  return ret;
}

inline Result ClientImpl::send(const Request &req) {
  auto req2 = req;
  return send_(std::move(req2));
}

inline Result ClientImpl::send_(Request &&req) {
  auto res = detail::make_unique<Response>();
  auto error = Error::Success;
  auto ret = send(req, *res, error);
  return Result{ret ? std::move(res) : nullptr, error, std::move(req.headers)};
}

inline bool ClientImpl::handle_request(Stream &strm, Request &req,
                                       Response &res, bool close_connection,
                                       Error &error) {
  if (req.path.empty()) {
    error = Error::Connection;
    return false;
  }

  auto req_save = req;

  bool ret;

  if (!is_ssl() && !proxy_host_.empty() && proxy_port_ != -1) {
    auto req2 = req;
    req2.path = "http://" + host_and_port_ + req.path;
    ret = process_request(strm, req2, res, close_connection, error);
    req = req2;
    req.path = req_save.path;
  } else {
    ret = process_request(strm, req, res, close_connection, error);
  }

  if (!ret) { return false; }

  if (res.get_header_value("Connection") == "close" ||
      (res.version == "HTTP/1.0" && res.reason != "Connection established")) {
    // TODO this requires a not-entirely-obvious chain of calls to be correct
    // for this to be safe.

    // This is safe to call because handle_request is only called by send_
    // which locks the request mutex during the process. It would be a bug
    // to call it from a different thread since it's a thread-safety issue
    // to do these things to the socket if another thread is using the socket.
    std::lock_guard<std::mutex> guard(socket_mutex_);
    shutdown_ssl(socket_, true);
    shutdown_socket(socket_);
    close_socket(socket_);
  }

  if (300 < res.status && res.status < 400 && follow_location_) {
    req = req_save;
    ret = redirect(req, res, error);
  }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  if ((res.status == StatusCode::Unauthorized_401 ||
       res.status == StatusCode::ProxyAuthenticationRequired_407) &&
      req.authorization_count_ < 5) {
    auto is_proxy = res.status == StatusCode::ProxyAuthenticationRequired_407;
    const auto &username =
        is_proxy ? proxy_digest_auth_username_ : digest_auth_username_;
    const auto &password =
        is_proxy ? proxy_digest_auth_password_ : digest_auth_password_;

    if (!username.empty() && !password.empty()) {
      std::map<std::string, std::string> auth;
      if (detail::parse_www_authenticate(res, auth, is_proxy)) {
        Request new_req = req;
        new_req.authorization_count_ += 1;
        new_req.headers.erase(is_proxy ? "Proxy-Authorization"
                                       : "Authorization");
        new_req.headers.insert(detail::make_digest_authentication_header(
            req, auth, new_req.authorization_count_, detail::random_string(10),
            username, password, is_proxy));

        Response new_res;

        ret = send(new_req, new_res, error);
        if (ret) { res = new_res; }
      }
    }
  }
#endif

  return ret;
}

inline bool ClientImpl::redirect(Request &req, Response &res, Error &error) {
  if (req.redirect_count_ == 0) {
    error = Error::ExceedRedirectCount;
    return false;
  }

  auto location = res.get_header_value("location");
  if (location.empty()) { return false; }

  const static std::regex re(
      R"((?:(https?):)?(?://(?:\[([a-fA-F\d:]+)\]|([^:/?#]+))(?::(\d+))?)?([^?#]*)(\?[^#]*)?(?:#.*)?)");

  std::smatch m;
  if (!std::regex_match(location, m, re)) { return false; }

  auto scheme = is_ssl() ? "https" : "http";

  auto next_scheme = m[1].str();
  auto next_host = m[2].str();
  if (next_host.empty()) { next_host = m[3].str(); }
  auto port_str = m[4].str();
  auto next_path = m[5].str();
  auto next_query = m[6].str();

  auto next_port = port_;
  if (!port_str.empty()) {
    next_port = std::stoi(port_str);
  } else if (!next_scheme.empty()) {
    next_port = next_scheme == "https" ? 443 : 80;
  }

  if (next_scheme.empty()) { next_scheme = scheme; }
  if (next_host.empty()) { next_host = host_; }
  if (next_path.empty()) { next_path = "/"; }

  auto path = detail::decode_url(next_path, true) + next_query;

  if (next_scheme == scheme && next_host == host_ && next_port == port_) {
    return detail::redirect(*this, req, res, path, location, error);
  } else {
    if (next_scheme == "https") {
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      SSLClient cli(next_host, next_port);
      cli.copy_settings(*this);
      if (ca_cert_store_) { cli.set_ca_cert_store(ca_cert_store_); }
      return detail::redirect(cli, req, res, path, location, error);
#else
      return false;
#endif
    } else {
      ClientImpl cli(next_host, next_port);
      cli.copy_settings(*this);
      return detail::redirect(cli, req, res, path, location, error);
    }
  }
}

inline bool ClientImpl::write_content_with_provider(Stream &strm,
                                                    const Request &req,
                                                    Error &error) const {
  auto is_shutting_down = []() { return false; };

  if (req.is_chunked_content_provider_) {
    // TODO: Brotli support
    std::unique_ptr<detail::compressor> compressor;
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
    if (compress_) {
      compressor = detail::make_unique<detail::gzip_compressor>();
    } else
#endif
    {
      compressor = detail::make_unique<detail::nocompressor>();
    }

    return detail::write_content_chunked(strm, req.content_provider_,
                                         is_shutting_down, *compressor, error);
  } else {
    return detail::write_content(strm, req.content_provider_, 0,
                                 req.content_length_, is_shutting_down, error);
  }
}

inline bool ClientImpl::write_request(Stream &strm, Request &req,
                                      bool close_connection, Error &error) {
  // Prepare additional headers
  if (close_connection) {
    if (!req.has_header("Connection")) {
      req.set_header("Connection", "close");
    }
  }

  if (!req.has_header("Host")) {
    if (is_ssl()) {
      if (port_ == 443) {
        req.set_header("Host", host_);
      } else {
        req.set_header("Host", host_and_port_);
      }
    } else {
      if (port_ == 80) {
        req.set_header("Host", host_);
      } else {
        req.set_header("Host", host_and_port_);
      }
    }
  }

  if (!req.has_header("Accept")) { req.set_header("Accept", "*/*"); }

#ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT
  if (!req.has_header("User-Agent")) {
    auto agent = std::string("cpp-httplib/") + CPPHTTPLIB_VERSION;
    req.set_header("User-Agent", agent);
  }
#endif

  if (req.body.empty()) {
    if (req.content_provider_) {
      if (!req.is_chunked_content_provider_) {
        if (!req.has_header("Content-Length")) {
          auto length = std::to_string(req.content_length_);
          req.set_header("Content-Length", length);
        }
      }
    } else {
      if (req.method == "POST" || req.method == "PUT" ||
          req.method == "PATCH") {
        req.set_header("Content-Length", "0");
      }
    }
  } else {
    if (!req.has_header("Content-Type")) {
      req.set_header("Content-Type", "text/plain");
    }

    if (!req.has_header("Content-Length")) {
      auto length = std::to_string(req.body.size());
      req.set_header("Content-Length", length);
    }
  }

  if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) {
    if (!req.has_header("Authorization")) {
      req.headers.insert(make_basic_authentication_header(
          basic_auth_username_, basic_auth_password_, false));
    }
  }

  if (!proxy_basic_auth_username_.empty() &&
      !proxy_basic_auth_password_.empty()) {
    if (!req.has_header("Proxy-Authorization")) {
      req.headers.insert(make_basic_authentication_header(
          proxy_basic_auth_username_, proxy_basic_auth_password_, true));
    }
  }

  if (!bearer_token_auth_token_.empty()) {
    if (!req.has_header("Authorization")) {
      req.headers.insert(make_bearer_token_authentication_header(
          bearer_token_auth_token_, false));
    }
  }

  if (!proxy_bearer_token_auth_token_.empty()) {
    if (!req.has_header("Proxy-Authorization")) {
      req.headers.insert(make_bearer_token_authentication_header(
          proxy_bearer_token_auth_token_, true));
    }
  }

  // Request line and headers
  {
    detail::BufferStream bstrm;

    const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path;
    bstrm.write_format("%s %s HTTP/1.1\r\n", req.method.c_str(), path.c_str());

    header_writer_(bstrm, req.headers);

    // Flush buffer
    auto &data = bstrm.get_buffer();
    if (!detail::write_data(strm, data.data(), data.size())) {
      error = Error::Write;
      return false;
    }
  }

  // Body
  if (req.body.empty()) {
    return write_content_with_provider(strm, req, error);
  }

  if (!detail::write_data(strm, req.body.data(), req.body.size())) {
    error = Error::Write;
    return false;
  }

  return true;
}

inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(
    Request &req, const char *body, size_t content_length,
    ContentProvider content_provider,
    ContentProviderWithoutLength content_provider_without_length,
    const std::string &content_type, Error &error) {
  if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
  if (compress_) { req.set_header("Content-Encoding", "gzip"); }
#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
  if (compress_ && !content_provider_without_length) {
    // TODO: Brotli support
    detail::gzip_compressor compressor;

    if (content_provider) {
      auto ok = true;
      size_t offset = 0;
      DataSink data_sink;

      data_sink.write = [&](const char *data, size_t data_len) -> bool {
        if (ok) {
          auto last = offset + data_len == content_length;

          auto ret = compressor.compress(
              data, data_len, last,
              [&](const char *compressed_data, size_t compressed_data_len) {
                req.body.append(compressed_data, compressed_data_len);
                return true;
              });

          if (ret) {
            offset += data_len;
          } else {
            ok = false;
          }
        }
        return ok;
      };

      while (ok && offset < content_length) {
        if (!content_provider(offset, content_length - offset, data_sink)) {
          error = Error::Canceled;
          return nullptr;
        }
      }
    } else {
      if (!compressor.compress(body, content_length, true,
                               [&](const char *data, size_t data_len) {
                                 req.body.append(data, data_len);
                                 return true;
                               })) {
        error = Error::Compression;
        return nullptr;
      }
    }
  } else
#endif
  {
    if (content_provider) {
      req.content_length_ = content_length;
      req.content_provider_ = std::move(content_provider);
      req.is_chunked_content_provider_ = false;
    } else if (content_provider_without_length) {
      req.content_length_ = 0;
      req.content_provider_ = detail::ContentProviderAdapter(
          std::move(content_provider_without_length));
      req.is_chunked_content_provider_ = true;
      req.set_header("Transfer-Encoding", "chunked");
    } else {
      req.body.assign(body, content_length);
    }
  }

  auto res = detail::make_unique<Response>();
  return send(req, *res, error) ? std::move(res) : nullptr;
}

inline Result ClientImpl::send_with_content_provider(
    const std::string &method, const std::string &path, const Headers &headers,
    const char *body, size_t content_length, ContentProvider content_provider,
    ContentProviderWithoutLength content_provider_without_length,
    const std::string &content_type, Progress progress) {
  Request req;
  req.method = method;
  req.headers = headers;
  req.path = path;
  req.progress = progress;

  auto error = Error::Success;

  auto res = send_with_content_provider(
      req, body, content_length, std::move(content_provider),
      std::move(content_provider_without_length), content_type, error);

  return Result{std::move(res), error, std::move(req.headers)};
}

inline std::string
ClientImpl::adjust_host_string(const std::string &host) const {
  if (host.find(':') != std::string::npos) { return "[" + host + "]"; }
  return host;
}

inline bool ClientImpl::process_request(Stream &strm, Request &req,
                                        Response &res, bool close_connection,
                                        Error &error) {
  // Send request
  if (!write_request(strm, req, close_connection, error)) { return false; }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  if (is_ssl()) {
    auto is_proxy_enabled = !proxy_host_.empty() && proxy_port_ != -1;
    if (!is_proxy_enabled) {
      char buf[1];
      if (SSL_peek(socket_.ssl, buf, 1) == 0 &&
          SSL_get_error(socket_.ssl, 0) == SSL_ERROR_ZERO_RETURN) {
        error = Error::SSLPeerCouldBeClosed_;
        return false;
      }
    }
  }
#endif

  // Receive response and headers
  if (!read_response_line(strm, req, res) ||
      !detail::read_headers(strm, res.headers)) {
    error = Error::Read;
    return false;
  }

  // Body
  if ((res.status != StatusCode::NoContent_204) && req.method != "HEAD" &&
      req.method != "CONNECT") {
    auto redirect = 300 < res.status && res.status < 400 && follow_location_;

    if (req.response_handler && !redirect) {
      if (!req.response_handler(res)) {
        error = Error::Canceled;
        return false;
      }
    }

    auto out =
        req.content_receiver
            ? static_cast<ContentReceiverWithProgress>(
                  [&](const char *buf, size_t n, uint64_t off, uint64_t len) {
                    if (redirect) { return true; }
                    auto ret = req.content_receiver(buf, n, off, len);
                    if (!ret) { error = Error::Canceled; }
                    return ret;
                  })
            : static_cast<ContentReceiverWithProgress>(
                  [&](const char *buf, size_t n, uint64_t /*off*/,
                      uint64_t /*len*/) {
                    if (res.body.size() + n > res.body.max_size()) {
                      return false;
                    }
                    res.body.append(buf, n);
                    return true;
                  });

    auto progress = [&](uint64_t current, uint64_t total) {
      if (!req.progress || redirect) { return true; }
      auto ret = req.progress(current, total);
      if (!ret) { error = Error::Canceled; }
      return ret;
    };

    if (res.has_header("Content-Length")) {
      if (!req.content_receiver) {
        auto len = std::min<size_t>(res.get_header_value_u64("Content-Length"),
                                    res.body.max_size());
        if (len > 0) { res.body.reserve(len); }
      }
    }

    int dummy_status;
    if (!detail::read_content(strm, res, (std::numeric_limits<size_t>::max)(),
                              dummy_status, std::move(progress), std::move(out),
                              decompress_)) {
      if (error != Error::Canceled) { error = Error::Read; }
      return false;
    }
  }

  // Log
  if (logger_) { logger_(req, res); }

  return true;
}

inline ContentProviderWithoutLength ClientImpl::get_multipart_content_provider(
    const std::string &boundary, const MultipartFormDataItems &items,
    const MultipartFormDataProviderItems &provider_items) const {
  size_t cur_item = 0;
  size_t cur_start = 0;
  // cur_item and cur_start are copied to within the std::function and maintain
  // state between successive calls
  return [&, cur_item, cur_start](size_t offset,
                                  DataSink &sink) mutable -> bool {
    if (!offset && !items.empty()) {
      sink.os << detail::serialize_multipart_formdata(items, boundary, false);
      return true;
    } else if (cur_item < provider_items.size()) {
      if (!cur_start) {
        const auto &begin = detail::serialize_multipart_formdata_item_begin(
            provider_items[cur_item], boundary);
        offset += begin.size();
        cur_start = offset;
        sink.os << begin;
      }

      DataSink cur_sink;
      auto has_data = true;
      cur_sink.write = sink.write;
      cur_sink.done = [&]() { has_data = false; };

      if (!provider_items[cur_item].provider(offset - cur_start, cur_sink)) {
        return false;
      }

      if (!has_data) {
        sink.os << detail::serialize_multipart_formdata_item_end();
        cur_item++;
        cur_start = 0;
      }
      return true;
    } else {
      sink.os << detail::serialize_multipart_formdata_finish(boundary);
      sink.done();
      return true;
    }
  };
}

inline bool
ClientImpl::process_socket(const Socket &socket,
                           std::function<bool(Stream &strm)> callback) {
  return detail::process_client_socket(
      socket.sock, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
      write_timeout_usec_, std::move(callback));
}

inline bool ClientImpl::is_ssl() const { return false; }

inline Result ClientImpl::Get(const std::string &path) {
  return Get(path, Headers(), Progress());
}

inline Result ClientImpl::Get(const std::string &path, Progress progress) {
  return Get(path, Headers(), std::move(progress));
}

inline Result ClientImpl::Get(const std::string &path, const Headers &headers) {
  return Get(path, headers, Progress());
}

inline Result ClientImpl::Get(const std::string &path, const Headers &headers,
                              Progress progress) {
  Request req;
  req.method = "GET";
  req.path = path;
  req.headers = headers;
  req.progress = std::move(progress);

  return send_(std::move(req));
}

inline Result ClientImpl::Get(const std::string &path,
                              ContentReceiver content_receiver) {
  return Get(path, Headers(), nullptr, std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &path,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, Headers(), nullptr, std::move(content_receiver),
             std::move(progress));
}

inline Result ClientImpl::Get(const std::string &path, const Headers &headers,
                              ContentReceiver content_receiver) {
  return Get(path, headers, nullptr, std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &path, const Headers &headers,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, headers, nullptr, std::move(content_receiver),
             std::move(progress));
}

inline Result ClientImpl::Get(const std::string &path,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver) {
  return Get(path, Headers(), std::move(response_handler),
             std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &path, const Headers &headers,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver) {
  return Get(path, headers, std::move(response_handler),
             std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &path,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, Headers(), std::move(response_handler),
             std::move(content_receiver), std::move(progress));
}

inline Result ClientImpl::Get(const std::string &path, const Headers &headers,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver,
                              Progress progress) {
  Request req;
  req.method = "GET";
  req.path = path;
  req.headers = headers;
  req.response_handler = std::move(response_handler);
  req.content_receiver =
      [content_receiver](const char *data, size_t data_length,
                         uint64_t /*offset*/, uint64_t /*total_length*/) {
        return content_receiver(data, data_length);
      };
  req.progress = std::move(progress);

  return send_(std::move(req));
}

inline Result ClientImpl::Get(const std::string &path, const Params &params,
                              const Headers &headers, Progress progress) {
  if (params.empty()) { return Get(path, headers); }

  std::string path_with_query = append_query_params(path, params);
  return Get(path_with_query, headers, std::move(progress));
}

inline Result ClientImpl::Get(const std::string &path, const Params &params,
                              const Headers &headers,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, params, headers, nullptr, std::move(content_receiver),
             std::move(progress));
}

inline Result ClientImpl::Get(const std::string &path, const Params &params,
                              const Headers &headers,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver,
                              Progress progress) {
  if (params.empty()) {
    return Get(path, headers, std::move(response_handler),
               std::move(content_receiver), std::move(progress));
  }

  std::string path_with_query = append_query_params(path, params);
  return Get(path_with_query, headers, std::move(response_handler),
             std::move(content_receiver), std::move(progress));
}

inline Result ClientImpl::Head(const std::string &path) {
  return Head(path, Headers());
}

inline Result ClientImpl::Head(const std::string &path,
                               const Headers &headers) {
  Request req;
  req.method = "HEAD";
  req.headers = headers;
  req.path = path;

  return send_(std::move(req));
}

inline Result ClientImpl::Post(const std::string &path) {
  return Post(path, std::string(), std::string());
}

inline Result ClientImpl::Post(const std::string &path,
                               const Headers &headers) {
  return Post(path, headers, nullptr, 0, std::string());
}

inline Result ClientImpl::Post(const std::string &path, const char *body,
                               size_t content_length,
                               const std::string &content_type) {
  return Post(path, Headers(), body, content_length, content_type, nullptr);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const char *body, size_t content_length,
                               const std::string &content_type) {
  return send_with_content_provider("POST", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, nullptr);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const char *body, size_t content_length,
                               const std::string &content_type,
                               Progress progress) {
  return send_with_content_provider("POST", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, progress);
}

inline Result ClientImpl::Post(const std::string &path, const std::string &body,
                               const std::string &content_type) {
  return Post(path, Headers(), body, content_type);
}

inline Result ClientImpl::Post(const std::string &path, const std::string &body,
                               const std::string &content_type,
                               Progress progress) {
  return Post(path, Headers(), body, content_type, progress);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const std::string &body,
                               const std::string &content_type) {
  return send_with_content_provider("POST", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    nullptr);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const std::string &body,
                               const std::string &content_type,
                               Progress progress) {
  return send_with_content_provider("POST", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    progress);
}

inline Result ClientImpl::Post(const std::string &path, const Params &params) {
  return Post(path, Headers(), params);
}

inline Result ClientImpl::Post(const std::string &path, size_t content_length,
                               ContentProvider content_provider,
                               const std::string &content_type) {
  return Post(path, Headers(), content_length, std::move(content_provider),
              content_type);
}

inline Result ClientImpl::Post(const std::string &path,
                               ContentProviderWithoutLength content_provider,
                               const std::string &content_type) {
  return Post(path, Headers(), std::move(content_provider), content_type);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               size_t content_length,
                               ContentProvider content_provider,
                               const std::string &content_type) {
  return send_with_content_provider("POST", path, headers, nullptr,
                                    content_length, std::move(content_provider),
                                    nullptr, content_type, nullptr);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               ContentProviderWithoutLength content_provider,
                               const std::string &content_type) {
  return send_with_content_provider("POST", path, headers, nullptr, 0, nullptr,
                                    std::move(content_provider), content_type,
                                    nullptr);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const Params &params) {
  auto query = detail::params_to_query_str(params);
  return Post(path, headers, query, "application/x-www-form-urlencoded");
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const Params &params, Progress progress) {
  auto query = detail::params_to_query_str(params);
  return Post(path, headers, query, "application/x-www-form-urlencoded",
              progress);
}

inline Result ClientImpl::Post(const std::string &path,
                               const MultipartFormDataItems &items) {
  return Post(path, Headers(), items);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const MultipartFormDataItems &items) {
  const auto &boundary = detail::make_multipart_data_boundary();
  const auto &content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &body = detail::serialize_multipart_formdata(items, boundary);
  return Post(path, headers, body, content_type);
}

inline Result ClientImpl::Post(const std::string &path, const Headers &headers,
                               const MultipartFormDataItems &items,
                               const std::string &boundary) {
  if (!detail::is_multipart_boundary_chars_valid(boundary)) {
    return Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
  }

  const auto &content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &body = detail::serialize_multipart_formdata(items, boundary);
  return Post(path, headers, body, content_type);
}

inline Result
ClientImpl::Post(const std::string &path, const Headers &headers,
                 const MultipartFormDataItems &items,
                 const MultipartFormDataProviderItems &provider_items) {
  const auto &boundary = detail::make_multipart_data_boundary();
  const auto &content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  return send_with_content_provider(
      "POST", path, headers, nullptr, 0, nullptr,
      get_multipart_content_provider(boundary, items, provider_items),
      content_type, nullptr);
}

inline Result ClientImpl::Put(const std::string &path) {
  return Put(path, std::string(), std::string());
}

inline Result ClientImpl::Put(const std::string &path, const char *body,
                              size_t content_length,
                              const std::string &content_type) {
  return Put(path, Headers(), body, content_length, content_type);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const char *body, size_t content_length,
                              const std::string &content_type) {
  return send_with_content_provider("PUT", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, nullptr);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const char *body, size_t content_length,
                              const std::string &content_type,
                              Progress progress) {
  return send_with_content_provider("PUT", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, progress);
}

inline Result ClientImpl::Put(const std::string &path, const std::string &body,
                              const std::string &content_type) {
  return Put(path, Headers(), body, content_type);
}

inline Result ClientImpl::Put(const std::string &path, const std::string &body,
                              const std::string &content_type,
                              Progress progress) {
  return Put(path, Headers(), body, content_type, progress);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const std::string &body,
                              const std::string &content_type) {
  return send_with_content_provider("PUT", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    nullptr);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const std::string &body,
                              const std::string &content_type,
                              Progress progress) {
  return send_with_content_provider("PUT", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    progress);
}

inline Result ClientImpl::Put(const std::string &path, size_t content_length,
                              ContentProvider content_provider,
                              const std::string &content_type) {
  return Put(path, Headers(), content_length, std::move(content_provider),
             content_type);
}

inline Result ClientImpl::Put(const std::string &path,
                              ContentProviderWithoutLength content_provider,
                              const std::string &content_type) {
  return Put(path, Headers(), std::move(content_provider), content_type);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              size_t content_length,
                              ContentProvider content_provider,
                              const std::string &content_type) {
  return send_with_content_provider("PUT", path, headers, nullptr,
                                    content_length, std::move(content_provider),
                                    nullptr, content_type, nullptr);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              ContentProviderWithoutLength content_provider,
                              const std::string &content_type) {
  return send_with_content_provider("PUT", path, headers, nullptr, 0, nullptr,
                                    std::move(content_provider), content_type,
                                    nullptr);
}

inline Result ClientImpl::Put(const std::string &path, const Params &params) {
  return Put(path, Headers(), params);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const Params &params) {
  auto query = detail::params_to_query_str(params);
  return Put(path, headers, query, "application/x-www-form-urlencoded");
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const Params &params, Progress progress) {
  auto query = detail::params_to_query_str(params);
  return Put(path, headers, query, "application/x-www-form-urlencoded",
             progress);
}

inline Result ClientImpl::Put(const std::string &path,
                              const MultipartFormDataItems &items) {
  return Put(path, Headers(), items);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const MultipartFormDataItems &items) {
  const auto &boundary = detail::make_multipart_data_boundary();
  const auto &content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &body = detail::serialize_multipart_formdata(items, boundary);
  return Put(path, headers, body, content_type);
}

inline Result ClientImpl::Put(const std::string &path, const Headers &headers,
                              const MultipartFormDataItems &items,
                              const std::string &boundary) {
  if (!detail::is_multipart_boundary_chars_valid(boundary)) {
    return Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
  }

  const auto &content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &body = detail::serialize_multipart_formdata(items, boundary);
  return Put(path, headers, body, content_type);
}

inline Result
ClientImpl::Put(const std::string &path, const Headers &headers,
                const MultipartFormDataItems &items,
                const MultipartFormDataProviderItems &provider_items) {
  const auto &boundary = detail::make_multipart_data_boundary();
  const auto &content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  return send_with_content_provider(
      "PUT", path, headers, nullptr, 0, nullptr,
      get_multipart_content_provider(boundary, items, provider_items),
      content_type, nullptr);
}
inline Result ClientImpl::Patch(const std::string &path) {
  return Patch(path, std::string(), std::string());
}

inline Result ClientImpl::Patch(const std::string &path, const char *body,
                                size_t content_length,
                                const std::string &content_type) {
  return Patch(path, Headers(), body, content_length, content_type);
}

inline Result ClientImpl::Patch(const std::string &path, const char *body,
                                size_t content_length,
                                const std::string &content_type,
                                Progress progress) {
  return Patch(path, Headers(), body, content_length, content_type, progress);
}

inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,
                                const char *body, size_t content_length,
                                const std::string &content_type) {
  return Patch(path, headers, body, content_length, content_type, nullptr);
}

inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,
                                const char *body, size_t content_length,
                                const std::string &content_type,
                                Progress progress) {
  return send_with_content_provider("PATCH", path, headers, body,
                                    content_length, nullptr, nullptr,
                                    content_type, progress);
}

inline Result ClientImpl::Patch(const std::string &path,
                                const std::string &body,
                                const std::string &content_type) {
  return Patch(path, Headers(), body, content_type);
}

inline Result ClientImpl::Patch(const std::string &path,
                                const std::string &body,
                                const std::string &content_type,
                                Progress progress) {
  return Patch(path, Headers(), body, content_type, progress);
}

inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,
                                const std::string &body,
                                const std::string &content_type) {
  return Patch(path, headers, body, content_type, nullptr);
}

inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,
                                const std::string &body,
                                const std::string &content_type,
                                Progress progress) {
  return send_with_content_provider("PATCH", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    progress);
}

inline Result ClientImpl::Patch(const std::string &path, size_t content_length,
                                ContentProvider content_provider,
                                const std::string &content_type) {
  return Patch(path, Headers(), content_length, std::move(content_provider),
               content_type);
}

inline Result ClientImpl::Patch(const std::string &path,
                                ContentProviderWithoutLength content_provider,
                                const std::string &content_type) {
  return Patch(path, Headers(), std::move(content_provider), content_type);
}

inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,
                                size_t content_length,
                                ContentProvider content_provider,
                                const std::string &content_type) {
  return send_with_content_provider("PATCH", path, headers, nullptr,
                                    content_length, std::move(content_provider),
                                    nullptr, content_type, nullptr);
}

inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,
                                ContentProviderWithoutLength content_provider,
                                const std::string &content_type) {
  return send_with_content_provider("PATCH", path, headers, nullptr, 0, nullptr,
                                    std::move(content_provider), content_type,
                                    nullptr);
}

inline Result ClientImpl::Delete(const std::string &path) {
  return Delete(path, Headers(), std::string(), std::string());
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const Headers &headers) {
  return Delete(path, headers, std::string(), std::string());
}

inline Result ClientImpl::Delete(const std::string &path, const char *body,
                                 size_t content_length,
                                 const std::string &content_type) {
  return Delete(path, Headers(), body, content_length, content_type);
}

inline Result ClientImpl::Delete(const std::string &path, const char *body,
                                 size_t content_length,
                                 const std::string &content_type,
                                 Progress progress) {
  return Delete(path, Headers(), body, content_length, content_type, progress);
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const Headers &headers, const char *body,
                                 size_t content_length,
                                 const std::string &content_type) {
  return Delete(path, headers, body, content_length, content_type, nullptr);
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const Headers &headers, const char *body,
                                 size_t content_length,
                                 const std::string &content_type,
                                 Progress progress) {
  Request req;
  req.method = "DELETE";
  req.headers = headers;
  req.path = path;
  req.progress = progress;

  if (!content_type.empty()) { req.set_header("Content-Type", content_type); }
  req.body.assign(body, content_length);

  return send_(std::move(req));
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const std::string &body,
                                 const std::string &content_type) {
  return Delete(path, Headers(), body.data(), body.size(), content_type);
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const std::string &body,
                                 const std::string &content_type,
                                 Progress progress) {
  return Delete(path, Headers(), body.data(), body.size(), content_type,
                progress);
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const Headers &headers,
                                 const std::string &body,
                                 const std::string &content_type) {
  return Delete(path, headers, body.data(), body.size(), content_type);
}

inline Result ClientImpl::Delete(const std::string &path,
                                 const Headers &headers,
                                 const std::string &body,
                                 const std::string &content_type,
                                 Progress progress) {
  return Delete(path, headers, body.data(), body.size(), content_type,
                progress);
}

inline Result ClientImpl::Options(const std::string &path) {
  return Options(path, Headers());
}

inline Result ClientImpl::Options(const std::string &path,
                                  const Headers &headers) {
  Request req;
  req.method = "OPTIONS";
  req.headers = headers;
  req.path = path;

  return send_(std::move(req));
}

inline void ClientImpl::stop() {
  std::lock_guard<std::mutex> guard(socket_mutex_);

  // If there is anything ongoing right now, the ONLY thread-safe thing we can
  // do is to shutdown_socket, so that threads using this socket suddenly
  // discover they can't read/write any more and error out. Everything else
  // (closing the socket, shutting ssl down) is unsafe because these actions are
  // not thread-safe.
  if (socket_requests_in_flight_ > 0) {
    shutdown_socket(socket_);

    // Aside from that, we set a flag for the socket to be closed when we're
    // done.
    socket_should_be_closed_when_request_is_done_ = true;
    return;
  }

  // Otherwise, still holding the mutex, we can shut everything down ourselves
  shutdown_ssl(socket_, true);
  shutdown_socket(socket_);
  close_socket(socket_);
}

inline std::string ClientImpl::host() const { return host_; }

inline int ClientImpl::port() const { return port_; }

inline size_t ClientImpl::is_socket_open() const {
  std::lock_guard<std::mutex> guard(socket_mutex_);
  return socket_.is_open();
}

inline socket_t ClientImpl::socket() const { return socket_.sock; }

inline void ClientImpl::set_connection_timeout(time_t sec, time_t usec) {
  connection_timeout_sec_ = sec;
  connection_timeout_usec_ = usec;
}

inline void ClientImpl::set_read_timeout(time_t sec, time_t usec) {
  read_timeout_sec_ = sec;
  read_timeout_usec_ = usec;
}

inline void ClientImpl::set_write_timeout(time_t sec, time_t usec) {
  write_timeout_sec_ = sec;
  write_timeout_usec_ = usec;
}

inline void ClientImpl::set_basic_auth(const std::string &username,
                                       const std::string &password) {
  basic_auth_username_ = username;
  basic_auth_password_ = password;
}

inline void ClientImpl::set_bearer_token_auth(const std::string &token) {
  bearer_token_auth_token_ = token;
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void ClientImpl::set_digest_auth(const std::string &username,
                                        const std::string &password) {
  digest_auth_username_ = username;
  digest_auth_password_ = password;
}
#endif

inline void ClientImpl::set_keep_alive(bool on) { keep_alive_ = on; }

inline void ClientImpl::set_follow_location(bool on) { follow_location_ = on; }

inline void ClientImpl::set_url_encode(bool on) { url_encode_ = on; }

inline void
ClientImpl::set_hostname_addr_map(std::map<std::string, std::string> addr_map) {
  addr_map_ = std::move(addr_map);
}

inline void ClientImpl::set_default_headers(Headers headers) {
  default_headers_ = std::move(headers);
}

inline void ClientImpl::set_header_writer(
    std::function<ssize_t(Stream &, Headers &)> const &writer) {
  header_writer_ = writer;
}

inline void ClientImpl::set_address_family(int family) {
  address_family_ = family;
}

inline void ClientImpl::set_tcp_nodelay(bool on) { tcp_nodelay_ = on; }

inline void ClientImpl::set_ipv6_v6only(bool on) { ipv6_v6only_ = on; }

inline void ClientImpl::set_socket_options(SocketOptions socket_options) {
  socket_options_ = std::move(socket_options);
}

inline void ClientImpl::set_compress(bool on) { compress_ = on; }

inline void ClientImpl::set_decompress(bool on) { decompress_ = on; }

inline void ClientImpl::set_interface(const std::string &intf) {
  interface_ = intf;
}

inline void ClientImpl::set_proxy(const std::string &host, int port) {
  proxy_host_ = host;
  proxy_port_ = port;
}

inline void ClientImpl::set_proxy_basic_auth(const std::string &username,
                                             const std::string &password) {
  proxy_basic_auth_username_ = username;
  proxy_basic_auth_password_ = password;
}

inline void ClientImpl::set_proxy_bearer_token_auth(const std::string &token) {
  proxy_bearer_token_auth_token_ = token;
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void ClientImpl::set_proxy_digest_auth(const std::string &username,
                                              const std::string &password) {
  proxy_digest_auth_username_ = username;
  proxy_digest_auth_password_ = password;
}

inline void ClientImpl::set_ca_cert_path(const std::string &ca_cert_file_path,
                                         const std::string &ca_cert_dir_path) {
  ca_cert_file_path_ = ca_cert_file_path;
  ca_cert_dir_path_ = ca_cert_dir_path;
}

inline void ClientImpl::set_ca_cert_store(X509_STORE *ca_cert_store) {
  if (ca_cert_store && ca_cert_store != ca_cert_store_) {
    ca_cert_store_ = ca_cert_store;
  }
}

inline X509_STORE *ClientImpl::create_ca_cert_store(const char *ca_cert,
                                                    std::size_t size) const {
  auto mem = BIO_new_mem_buf(ca_cert, static_cast<int>(size));
  if (!mem) { return nullptr; }

  auto inf = PEM_X509_INFO_read_bio(mem, nullptr, nullptr, nullptr);
  if (!inf) {
    BIO_free_all(mem);
    return nullptr;
  }

  auto cts = X509_STORE_new();
  if (cts) {
    for (auto i = 0; i < static_cast<int>(sk_X509_INFO_num(inf)); i++) {
      auto itmp = sk_X509_INFO_value(inf, i);
      if (!itmp) { continue; }

      if (itmp->x509) { X509_STORE_add_cert(cts, itmp->x509); }
      if (itmp->crl) { X509_STORE_add_crl(cts, itmp->crl); }
    }
  }

  sk_X509_INFO_pop_free(inf, X509_INFO_free);
  BIO_free_all(mem);
  return cts;
}

inline void ClientImpl::enable_server_certificate_verification(bool enabled) {
  server_certificate_verification_ = enabled;
}
#endif

inline void ClientImpl::set_logger(Logger logger) {
  logger_ = std::move(logger);
}

/*
 * SSL Implementation
 */
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
namespace detail {

template <typename U, typename V>
inline SSL *ssl_new(socket_t sock, SSL_CTX *ctx, std::mutex &ctx_mutex,
                    U SSL_connect_or_accept, V setup) {
  SSL *ssl = nullptr;
  {
    std::lock_guard<std::mutex> guard(ctx_mutex);
    ssl = SSL_new(ctx);
  }

  if (ssl) {
    set_nonblocking(sock, true);
    auto bio = BIO_new_socket(static_cast<int>(sock), BIO_NOCLOSE);
    BIO_set_nbio(bio, 1);
    SSL_set_bio(ssl, bio, bio);

    if (!setup(ssl) || SSL_connect_or_accept(ssl) != 1) {
      SSL_shutdown(ssl);
      {
        std::lock_guard<std::mutex> guard(ctx_mutex);
        SSL_free(ssl);
      }
      set_nonblocking(sock, false);
      return nullptr;
    }
    BIO_set_nbio(bio, 0);
    set_nonblocking(sock, false);
  }

  return ssl;
}

inline void ssl_delete(std::mutex &ctx_mutex, SSL *ssl, socket_t sock,
                       bool shutdown_gracefully) {
  // sometimes we may want to skip this to try to avoid SIGPIPE if we know
  // the remote has closed the network connection
  // Note that it is not always possible to avoid SIGPIPE, this is merely a
  // best-efforts.
  if (shutdown_gracefully) {
#ifdef _WIN32
    SSL_shutdown(ssl);
#else
    timeval tv;
    tv.tv_sec = 1;
    tv.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,
               reinterpret_cast<const void *>(&tv), sizeof(tv));

    auto ret = SSL_shutdown(ssl);
    while (ret == 0) {
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      ret = SSL_shutdown(ssl);
    }
#endif
  }

  std::lock_guard<std::mutex> guard(ctx_mutex);
  SSL_free(ssl);
}

template <typename U>
bool ssl_connect_or_accept_nonblocking(socket_t sock, SSL *ssl,
                                       U ssl_connect_or_accept,
                                       time_t timeout_sec,
                                       time_t timeout_usec) {
  auto res = 0;
  while ((res = ssl_connect_or_accept(ssl)) != 1) {
    auto err = SSL_get_error(ssl, res);
    switch (err) {
    case SSL_ERROR_WANT_READ:
      if (select_read(sock, timeout_sec, timeout_usec) > 0) { continue; }
      break;
    case SSL_ERROR_WANT_WRITE:
      if (select_write(sock, timeout_sec, timeout_usec) > 0) { continue; }
      break;
    default: break;
    }
    return false;
  }
  return true;
}

template <typename T>
inline bool process_server_socket_ssl(
    const std::atomic<socket_t> &svr_sock, SSL *ssl, socket_t sock,
    size_t keep_alive_max_count, time_t keep_alive_timeout_sec,
    time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
    time_t write_timeout_usec, T callback) {
  return process_server_socket_core(
      svr_sock, sock, keep_alive_max_count, keep_alive_timeout_sec,
      [&](bool close_connection, bool &connection_closed) {
        SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,
                             write_timeout_sec, write_timeout_usec);
        return callback(strm, close_connection, connection_closed);
      });
}

template <typename T>
inline bool
process_client_socket_ssl(SSL *ssl, socket_t sock, time_t read_timeout_sec,
                          time_t read_timeout_usec, time_t write_timeout_sec,
                          time_t write_timeout_usec, T callback) {
  SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,
                       write_timeout_sec, write_timeout_usec);
  return callback(strm);
}

class SSLInit {
public:
  SSLInit() {
    OPENSSL_init_ssl(
        OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
  }
};

// SSL socket stream implementation
inline SSLSocketStream::SSLSocketStream(socket_t sock, SSL *ssl,
                                        time_t read_timeout_sec,
                                        time_t read_timeout_usec,
                                        time_t write_timeout_sec,
                                        time_t write_timeout_usec)
    : sock_(sock), ssl_(ssl), read_timeout_sec_(read_timeout_sec),
      read_timeout_usec_(read_timeout_usec),
      write_timeout_sec_(write_timeout_sec),
      write_timeout_usec_(write_timeout_usec) {
  SSL_clear_mode(ssl, SSL_MODE_AUTO_RETRY);
}

inline SSLSocketStream::~SSLSocketStream() = default;

inline bool SSLSocketStream::is_readable() const {
  return detail::select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;
}

inline bool SSLSocketStream::is_writable() const {
  return select_write(sock_, write_timeout_sec_, write_timeout_usec_) > 0 &&
         is_socket_alive(sock_);
}

inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {
  if (SSL_pending(ssl_) > 0) {
    return SSL_read(ssl_, ptr, static_cast<int>(size));
  } else if (is_readable()) {
    auto ret = SSL_read(ssl_, ptr, static_cast<int>(size));
    if (ret < 0) {
      auto err = SSL_get_error(ssl_, ret);
      auto n = 1000;
#ifdef _WIN32
      while (--n >= 0 && (err == SSL_ERROR_WANT_READ ||
                          (err == SSL_ERROR_SYSCALL &&
                           WSAGetLastError() == WSAETIMEDOUT))) {
#else
      while (--n >= 0 && err == SSL_ERROR_WANT_READ) {
#endif
        if (SSL_pending(ssl_) > 0) {
          return SSL_read(ssl_, ptr, static_cast<int>(size));
        } else if (is_readable()) {
          std::this_thread::sleep_for(std::chrono::milliseconds(1));
          ret = SSL_read(ssl_, ptr, static_cast<int>(size));
          if (ret >= 0) { return ret; }
          err = SSL_get_error(ssl_, ret);
        } else {
          return -1;
        }
      }
    }
    return ret;
  }
  return -1;
}

inline ssize_t SSLSocketStream::write(const char *ptr, size_t size) {
  if (is_writable()) {
    auto handle_size = static_cast<int>(
        std::min<size_t>(size, (std::numeric_limits<int>::max)()));

    auto ret = SSL_write(ssl_, ptr, static_cast<int>(handle_size));
    if (ret < 0) {
      auto err = SSL_get_error(ssl_, ret);
      auto n = 1000;
#ifdef _WIN32
      while (--n >= 0 && (err == SSL_ERROR_WANT_WRITE ||
                          (err == SSL_ERROR_SYSCALL &&
                           WSAGetLastError() == WSAETIMEDOUT))) {
#else
      while (--n >= 0 && err == SSL_ERROR_WANT_WRITE) {
#endif
        if (is_writable()) {
          std::this_thread::sleep_for(std::chrono::milliseconds(1));
          ret = SSL_write(ssl_, ptr, static_cast<int>(handle_size));
          if (ret >= 0) { return ret; }
          err = SSL_get_error(ssl_, ret);
        } else {
          return -1;
        }
      }
    }
    return ret;
  }
  return -1;
}

inline void SSLSocketStream::get_remote_ip_and_port(std::string &ip,
                                                    int &port) const {
  detail::get_remote_ip_and_port(sock_, ip, port);
}

inline void SSLSocketStream::get_local_ip_and_port(std::string &ip,
                                                   int &port) const {
  detail::get_local_ip_and_port(sock_, ip, port);
}

inline socket_t SSLSocketStream::socket() const { return sock_; }

static SSLInit sslinit_;

} // namespace detail

// SSL HTTP server implementation
inline SSLServer::SSLServer(const char *cert_path, const char *private_key_path,
                            const char *client_ca_cert_file_path,
                            const char *client_ca_cert_dir_path,
                            const char *private_key_password) {
  ctx_ = SSL_CTX_new(TLS_server_method());

  if (ctx_) {
    SSL_CTX_set_options(ctx_,
                        SSL_OP_NO_COMPRESSION |
                            SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);

    SSL_CTX_set_min_proto_version(ctx_, TLS1_2_VERSION);

    if (private_key_password != nullptr && (private_key_password[0] != '\0')) {
      SSL_CTX_set_default_passwd_cb_userdata(
          ctx_,
          reinterpret_cast<void *>(const_cast<char *>(private_key_password)));
    }

    if (SSL_CTX_use_certificate_chain_file(ctx_, cert_path) != 1 ||
        SSL_CTX_use_PrivateKey_file(ctx_, private_key_path, SSL_FILETYPE_PEM) !=
            1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    } else if (client_ca_cert_file_path || client_ca_cert_dir_path) {
      SSL_CTX_load_verify_locations(ctx_, client_ca_cert_file_path,
                                    client_ca_cert_dir_path);

      SSL_CTX_set_verify(
          ctx_, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
    }
  }
}

inline SSLServer::SSLServer(X509 *cert, EVP_PKEY *private_key,
                            X509_STORE *client_ca_cert_store) {
  ctx_ = SSL_CTX_new(TLS_server_method());

  if (ctx_) {
    SSL_CTX_set_options(ctx_,
                        SSL_OP_NO_COMPRESSION |
                            SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);

    SSL_CTX_set_min_proto_version(ctx_, TLS1_2_VERSION);

    if (SSL_CTX_use_certificate(ctx_, cert) != 1 ||
        SSL_CTX_use_PrivateKey(ctx_, private_key) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    } else if (client_ca_cert_store) {
      SSL_CTX_set_cert_store(ctx_, client_ca_cert_store);

      SSL_CTX_set_verify(
          ctx_, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
    }
  }
}

inline SSLServer::SSLServer(
    const std::function<bool(SSL_CTX &ssl_ctx)> &setup_ssl_ctx_callback) {
  ctx_ = SSL_CTX_new(TLS_method());
  if (ctx_) {
    if (!setup_ssl_ctx_callback(*ctx_)) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    }
  }
}

inline SSLServer::~SSLServer() {
  if (ctx_) { SSL_CTX_free(ctx_); }
}

inline bool SSLServer::is_valid() const { return ctx_; }

inline SSL_CTX *SSLServer::ssl_context() const { return ctx_; }

inline void SSLServer::update_certs(X509 *cert, EVP_PKEY *private_key,
                                    X509_STORE *client_ca_cert_store) {

  std::lock_guard<std::mutex> guard(ctx_mutex_);

  SSL_CTX_use_certificate(ctx_, cert);
  SSL_CTX_use_PrivateKey(ctx_, private_key);

  if (client_ca_cert_store != nullptr) {
    SSL_CTX_set_cert_store(ctx_, client_ca_cert_store);
  }
}

inline bool SSLServer::process_and_close_socket(socket_t sock) {
  auto ssl = detail::ssl_new(
      sock, ctx_, ctx_mutex_,
      [&](SSL *ssl2) {
        return detail::ssl_connect_or_accept_nonblocking(
            sock, ssl2, SSL_accept, read_timeout_sec_, read_timeout_usec_);
      },
      [](SSL * /*ssl2*/) { return true; });

  auto ret = false;
  if (ssl) {
    ret = detail::process_server_socket_ssl(
        svr_sock_, ssl, sock, keep_alive_max_count_, keep_alive_timeout_sec_,
        read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
        write_timeout_usec_,
        [this, ssl](Stream &strm, bool close_connection,
                    bool &connection_closed) {
          return process_request(strm, close_connection, connection_closed,
                                 [&](Request &req) { req.ssl = ssl; });
        });

    // Shutdown gracefully if the result seemed successful, non-gracefully if
    // the connection appeared to be closed.
    const bool shutdown_gracefully = ret;
    detail::ssl_delete(ctx_mutex_, ssl, sock, shutdown_gracefully);
  }

  detail::shutdown_socket(sock);
  detail::close_socket(sock);
  return ret;
}

// SSL HTTP client implementation
inline SSLClient::SSLClient(const std::string &host)
    : SSLClient(host, 443, std::string(), std::string()) {}

inline SSLClient::SSLClient(const std::string &host, int port)
    : SSLClient(host, port, std::string(), std::string()) {}

inline SSLClient::SSLClient(const std::string &host, int port,
                            const std::string &client_cert_path,
                            const std::string &client_key_path,
                            const std::string &private_key_password)
    : ClientImpl(host, port, client_cert_path, client_key_path) {
  ctx_ = SSL_CTX_new(TLS_client_method());

  detail::split(&host_[0], &host_[host_.size()], '.',
                [&](const char *b, const char *e) {
                  host_components_.emplace_back(b, e);
                });

  if (!client_cert_path.empty() && !client_key_path.empty()) {
    if (!private_key_password.empty()) {
      SSL_CTX_set_default_passwd_cb_userdata(
          ctx_, reinterpret_cast<void *>(
                    const_cast<char *>(private_key_password.c_str())));
    }

    if (SSL_CTX_use_certificate_file(ctx_, client_cert_path.c_str(),
                                     SSL_FILETYPE_PEM) != 1 ||
        SSL_CTX_use_PrivateKey_file(ctx_, client_key_path.c_str(),
                                    SSL_FILETYPE_PEM) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    }
  }
}

inline SSLClient::SSLClient(const std::string &host, int port,
                            X509 *client_cert, EVP_PKEY *client_key,
                            const std::string &private_key_password)
    : ClientImpl(host, port) {
  ctx_ = SSL_CTX_new(TLS_client_method());

  detail::split(&host_[0], &host_[host_.size()], '.',
                [&](const char *b, const char *e) {
                  host_components_.emplace_back(b, e);
                });

  if (client_cert != nullptr && client_key != nullptr) {
    if (!private_key_password.empty()) {
      SSL_CTX_set_default_passwd_cb_userdata(
          ctx_, reinterpret_cast<void *>(
                    const_cast<char *>(private_key_password.c_str())));
    }

    if (SSL_CTX_use_certificate(ctx_, client_cert) != 1 ||
        SSL_CTX_use_PrivateKey(ctx_, client_key) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    }
  }
}

inline SSLClient::~SSLClient() {
  if (ctx_) { SSL_CTX_free(ctx_); }
  // Make sure to shut down SSL since shutdown_ssl will resolve to the
  // base function rather than the derived function once we get to the
  // base class destructor, and won't free the SSL (causing a leak).
  shutdown_ssl_impl(socket_, true);
}

inline bool SSLClient::is_valid() const { return ctx_; }

inline void SSLClient::set_ca_cert_store(X509_STORE *ca_cert_store) {
  if (ca_cert_store) {
    if (ctx_) {
      if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store) {
        // Free memory allocated for old cert and use new store `ca_cert_store`
        SSL_CTX_set_cert_store(ctx_, ca_cert_store);
      }
    } else {
      X509_STORE_free(ca_cert_store);
    }
  }
}

inline void SSLClient::load_ca_cert_store(const char *ca_cert,
                                          std::size_t size) {
  set_ca_cert_store(ClientImpl::create_ca_cert_store(ca_cert, size));
}

inline long SSLClient::get_openssl_verify_result() const {
  return verify_result_;
}

inline SSL_CTX *SSLClient::ssl_context() const { return ctx_; }

inline bool SSLClient::create_and_connect_socket(Socket &socket, Error &error) {
  return is_valid() && ClientImpl::create_and_connect_socket(socket, error);
}

// Assumes that socket_mutex_ is locked and that there are no requests in flight
inline bool SSLClient::connect_with_proxy(Socket &socket, Response &res,
                                          bool &success, Error &error) {
  success = true;
  Response proxy_res;
  if (!detail::process_client_socket(
          socket.sock, read_timeout_sec_, read_timeout_usec_,
          write_timeout_sec_, write_timeout_usec_, [&](Stream &strm) {
            Request req2;
            req2.method = "CONNECT";
            req2.path = host_and_port_;
            return process_request(strm, req2, proxy_res, false, error);
          })) {
    // Thread-safe to close everything because we are assuming there are no
    // requests in flight
    shutdown_ssl(socket, true);
    shutdown_socket(socket);
    close_socket(socket);
    success = false;
    return false;
  }

  if (proxy_res.status == StatusCode::ProxyAuthenticationRequired_407) {
    if (!proxy_digest_auth_username_.empty() &&
        !proxy_digest_auth_password_.empty()) {
      std::map<std::string, std::string> auth;
      if (detail::parse_www_authenticate(proxy_res, auth, true)) {
        proxy_res = Response();
        if (!detail::process_client_socket(
                socket.sock, read_timeout_sec_, read_timeout_usec_,
                write_timeout_sec_, write_timeout_usec_, [&](Stream &strm) {
                  Request req3;
                  req3.method = "CONNECT";
                  req3.path = host_and_port_;
                  req3.headers.insert(detail::make_digest_authentication_header(
                      req3, auth, 1, detail::random_string(10),
                      proxy_digest_auth_username_, proxy_digest_auth_password_,
                      true));
                  return process_request(strm, req3, proxy_res, false, error);
                })) {
          // Thread-safe to close everything because we are assuming there are
          // no requests in flight
          shutdown_ssl(socket, true);
          shutdown_socket(socket);
          close_socket(socket);
          success = false;
          return false;
        }
      }
    }
  }

  // If status code is not 200, proxy request is failed.
  // Set error to ProxyConnection and return proxy response
  // as the response of the request
  if (proxy_res.status != StatusCode::OK_200) {
    error = Error::ProxyConnection;
    res = std::move(proxy_res);
    // Thread-safe to close everything because we are assuming there are
    // no requests in flight
    shutdown_ssl(socket, true);
    shutdown_socket(socket);
    close_socket(socket);
    return false;
  }

  return true;
}

inline bool SSLClient::load_certs() {
  auto ret = true;

  std::call_once(initialize_cert_, [&]() {
    std::lock_guard<std::mutex> guard(ctx_mutex_);
    if (!ca_cert_file_path_.empty()) {
      if (!SSL_CTX_load_verify_locations(ctx_, ca_cert_file_path_.c_str(),
                                         nullptr)) {
        ret = false;
      }
    } else if (!ca_cert_dir_path_.empty()) {
      if (!SSL_CTX_load_verify_locations(ctx_, nullptr,
                                         ca_cert_dir_path_.c_str())) {
        ret = false;
      }
    } else {
      auto loaded = false;
#ifdef _WIN32
      loaded =
          detail::load_system_certs_on_windows(SSL_CTX_get_cert_store(ctx_));
#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) && defined(__APPLE__)
#if TARGET_OS_OSX
      loaded = detail::load_system_certs_on_macos(SSL_CTX_get_cert_store(ctx_));
#endif // TARGET_OS_OSX
#endif // _WIN32
      if (!loaded) { SSL_CTX_set_default_verify_paths(ctx_); }
    }
  });

  return ret;
}

inline bool SSLClient::initialize_ssl(Socket &socket, Error &error) {
  auto ssl = detail::ssl_new(
      socket.sock, ctx_, ctx_mutex_,
      [&](SSL *ssl2) {
        if (server_certificate_verification_) {
          if (!load_certs()) {
            error = Error::SSLLoadingCerts;
            return false;
          }
          SSL_set_verify(ssl2, SSL_VERIFY_NONE, nullptr);
        }

        if (!detail::ssl_connect_or_accept_nonblocking(
                socket.sock, ssl2, SSL_connect, connection_timeout_sec_,
                connection_timeout_usec_)) {
          error = Error::SSLConnection;
          return false;
        }

        if (server_certificate_verification_) {
          verify_result_ = SSL_get_verify_result(ssl2);

          if (verify_result_ != X509_V_OK) {
            error = Error::SSLServerVerification;
            return false;
          }

          auto server_cert = SSL_get1_peer_certificate(ssl2);

          if (server_cert == nullptr) {
            error = Error::SSLServerVerification;
            return false;
          }

          if (!verify_host(server_cert)) {
            X509_free(server_cert);
            error = Error::SSLServerVerification;
            return false;
          }
          X509_free(server_cert);
        }

        return true;
      },
      [&](SSL *ssl2) {
#if defined(OPENSSL_IS_BORINGSSL)
        SSL_set_tlsext_host_name(ssl2, host_.c_str());
#else
        // NOTE: Direct call instead of using the OpenSSL macro to suppress
        // -Wold-style-cast warning
        SSL_ctrl(ssl2, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name,
                 static_cast<void *>(const_cast<char *>(host_.c_str())));
#endif
        return true;
      });

  if (ssl) {
    socket.ssl = ssl;
    return true;
  }

  shutdown_socket(socket);
  close_socket(socket);
  return false;
}

inline void SSLClient::shutdown_ssl(Socket &socket, bool shutdown_gracefully) {
  shutdown_ssl_impl(socket, shutdown_gracefully);
}

inline void SSLClient::shutdown_ssl_impl(Socket &socket,
                                         bool shutdown_gracefully) {
  if (socket.sock == INVALID_SOCKET) {
    assert(socket.ssl == nullptr);
    return;
  }
  if (socket.ssl) {
    detail::ssl_delete(ctx_mutex_, socket.ssl, socket.sock,
                       shutdown_gracefully);
    socket.ssl = nullptr;
  }
  assert(socket.ssl == nullptr);
}

inline bool
SSLClient::process_socket(const Socket &socket,
                          std::function<bool(Stream &strm)> callback) {
  assert(socket.ssl);
  return detail::process_client_socket_ssl(
      socket.ssl, socket.sock, read_timeout_sec_, read_timeout_usec_,
      write_timeout_sec_, write_timeout_usec_, std::move(callback));
}

inline bool SSLClient::is_ssl() const { return true; }

inline bool SSLClient::verify_host(X509 *server_cert) const {
  /* Quote from RFC2818 section 3.1 "Server Identity"

     If a subjectAltName extension of type dNSName is present, that MUST
     be used as the identity. Otherwise, the (most specific) Common Name
     field in the Subject field of the certificate MUST be used. Although
     the use of the Common Name is existing practice, it is deprecated and
     Certification Authorities are encouraged to use the dNSName instead.

     Matching is performed using the matching rules specified by
     [RFC2459].  If more than one identity of a given type is present in
     the certificate (e.g., more than one dNSName name, a match in any one
     of the set is considered acceptable.) Names may contain the wildcard
     character * which is considered to match any single domain name
     component or component fragment. E.g., *.a.com matches foo.a.com but
     not bar.foo.a.com. f*.com matches foo.com but not bar.com.

     In some cases, the URI is specified as an IP address rather than a
     hostname. In this case, the iPAddress subjectAltName must be present
     in the certificate and must exactly match the IP in the URI.

  */
  return verify_host_with_subject_alt_name(server_cert) ||
         verify_host_with_common_name(server_cert);
}

inline bool
SSLClient::verify_host_with_subject_alt_name(X509 *server_cert) const {
  auto ret = false;

  auto type = GEN_DNS;

  struct in6_addr addr6 {};
  struct in_addr addr {};
  size_t addr_len = 0;

#ifndef __MINGW32__
  if (inet_pton(AF_INET6, host_.c_str(), &addr6)) {
    type = GEN_IPADD;
    addr_len = sizeof(struct in6_addr);
  } else if (inet_pton(AF_INET, host_.c_str(), &addr)) {
    type = GEN_IPADD;
    addr_len = sizeof(struct in_addr);
  }
#endif

  auto alt_names = static_cast<const struct stack_st_GENERAL_NAME *>(
      X509_get_ext_d2i(server_cert, NID_subject_alt_name, nullptr, nullptr));

  if (alt_names) {
    auto dsn_matched = false;
    auto ip_matched = false;

    auto count = sk_GENERAL_NAME_num(alt_names);

    for (decltype(count) i = 0; i < count && !dsn_matched; i++) {
      auto val = sk_GENERAL_NAME_value(alt_names, i);
      if (val->type == type) {
        auto name =
            reinterpret_cast<const char *>(ASN1_STRING_get0_data(val->d.ia5));
        auto name_len = static_cast<size_t>(ASN1_STRING_length(val->d.ia5));

        switch (type) {
        case GEN_DNS: dsn_matched = check_host_name(name, name_len); break;

        case GEN_IPADD:
          if (!memcmp(&addr6, name, addr_len) ||
              !memcmp(&addr, name, addr_len)) {
            ip_matched = true;
          }
          break;
        }
      }
    }

    if (dsn_matched || ip_matched) { ret = true; }
  }

  GENERAL_NAMES_free(const_cast<STACK_OF(GENERAL_NAME) *>(
      reinterpret_cast<const STACK_OF(GENERAL_NAME) *>(alt_names)));
  return ret;
}

inline bool SSLClient::verify_host_with_common_name(X509 *server_cert) const {
  const auto subject_name = X509_get_subject_name(server_cert);

  if (subject_name != nullptr) {
    char name[BUFSIZ];
    auto name_len = X509_NAME_get_text_by_NID(subject_name, NID_commonName,
                                              name, sizeof(name));

    if (name_len != -1) {
      return check_host_name(name, static_cast<size_t>(name_len));
    }
  }

  return false;
}

inline bool SSLClient::check_host_name(const char *pattern,
                                       size_t pattern_len) const {
  if (host_.size() == pattern_len && host_ == pattern) { return true; }

  // Wildcard match
  // https://bugs.launchpad.net/ubuntu/+source/firefox-3.0/+bug/376484
  std::vector<std::string> pattern_components;
  detail::split(&pattern[0], &pattern[pattern_len], '.',
                [&](const char *b, const char *e) {
                  pattern_components.emplace_back(b, e);
                });

  if (host_components_.size() != pattern_components.size()) { return false; }

  auto itr = pattern_components.begin();
  for (const auto &h : host_components_) {
    auto &p = *itr;
    if (p != h && p != "*") {
      auto partial_match = (p.size() > 0 && p[p.size() - 1] == '*' &&
                            !p.compare(0, p.size() - 1, h));
      if (!partial_match) { return false; }
    }
    ++itr;
  }

  return true;
}
#endif

// Universal client implementation
inline Client::Client(const std::string &scheme_host_port)
    : Client(scheme_host_port, std::string(), std::string()) {}

inline Client::Client(const std::string &scheme_host_port,
                      const std::string &client_cert_path,
                      const std::string &client_key_path) {
  const static std::regex re(
      R"((?:([a-z]+):\/\/)?(?:\[([a-fA-F\d:]+)\]|([^:/?#]+))(?::(\d+))?)");

  std::smatch m;
  if (std::regex_match(scheme_host_port, m, re)) {
    auto scheme = m[1].str();

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    if (!scheme.empty() && (scheme != "http" && scheme != "https")) {
#else
    if (!scheme.empty() && scheme != "http") {
#endif
#ifndef CPPHTTPLIB_NO_EXCEPTIONS
      std::string msg = "'" + scheme + "' scheme is not supported.";
      throw std::invalid_argument(msg);
#endif
      return;
    }

    auto is_ssl = scheme == "https";

    auto host = m[2].str();
    if (host.empty()) { host = m[3].str(); }

    auto port_str = m[4].str();
    auto port = !port_str.empty() ? std::stoi(port_str) : (is_ssl ? 443 : 80);

    if (is_ssl) {
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      cli_ = detail::make_unique<SSLClient>(host, port, client_cert_path,
                                            client_key_path);
      is_ssl_ = is_ssl;
#endif
    } else {
      cli_ = detail::make_unique<ClientImpl>(host, port, client_cert_path,
                                             client_key_path);
    }
  } else {
    // NOTE: Update TEST(UniversalClientImplTest, Ipv6LiteralAddress)
    // if port param below changes.
    cli_ = detail::make_unique<ClientImpl>(scheme_host_port, 80,
                                           client_cert_path, client_key_path);
  }
} // namespace detail

inline Client::Client(const std::string &host, int port)
    : cli_(detail::make_unique<ClientImpl>(host, port)) {}

inline Client::Client(const std::string &host, int port,
                      const std::string &client_cert_path,
                      const std::string &client_key_path)
    : cli_(detail::make_unique<ClientImpl>(host, port, client_cert_path,
                                           client_key_path)) {}

inline Client::~Client() = default;

inline bool Client::is_valid() const {
  return cli_ != nullptr && cli_->is_valid();
}

inline Result Client::Get(const std::string &path) { return cli_->Get(path); }
inline Result Client::Get(const std::string &path, const Headers &headers) {
  return cli_->Get(path, headers);
}
inline Result Client::Get(const std::string &path, Progress progress) {
  return cli_->Get(path, std::move(progress));
}
inline Result Client::Get(const std::string &path, const Headers &headers,
                          Progress progress) {
  return cli_->Get(path, headers, std::move(progress));
}
inline Result Client::Get(const std::string &path,
                          ContentReceiver content_receiver) {
  return cli_->Get(path, std::move(content_receiver));
}
inline Result Client::Get(const std::string &path, const Headers &headers,
                          ContentReceiver content_receiver) {
  return cli_->Get(path, headers, std::move(content_receiver));
}
inline Result Client::Get(const std::string &path,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_->Get(path, std::move(content_receiver), std::move(progress));
}
inline Result Client::Get(const std::string &path, const Headers &headers,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_->Get(path, headers, std::move(content_receiver),
                   std::move(progress));
}
inline Result Client::Get(const std::string &path,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver) {
  return cli_->Get(path, std::move(response_handler),
                   std::move(content_receiver));
}
inline Result Client::Get(const std::string &path, const Headers &headers,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver) {
  return cli_->Get(path, headers, std::move(response_handler),
                   std::move(content_receiver));
}
inline Result Client::Get(const std::string &path,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_->Get(path, std::move(response_handler),
                   std::move(content_receiver), std::move(progress));
}
inline Result Client::Get(const std::string &path, const Headers &headers,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_->Get(path, headers, std::move(response_handler),
                   std::move(content_receiver), std::move(progress));
}
inline Result Client::Get(const std::string &path, const Params &params,
                          const Headers &headers, Progress progress) {
  return cli_->Get(path, params, headers, std::move(progress));
}
inline Result Client::Get(const std::string &path, const Params &params,
                          const Headers &headers,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_->Get(path, params, headers, std::move(content_receiver),
                   std::move(progress));
}
inline Result Client::Get(const std::string &path, const Params &params,
                          const Headers &headers,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_->Get(path, params, headers, std::move(response_handler),
                   std::move(content_receiver), std::move(progress));
}

inline Result Client::Head(const std::string &path) { return cli_->Head(path); }
inline Result Client::Head(const std::string &path, const Headers &headers) {
  return cli_->Head(path, headers);
}

inline Result Client::Post(const std::string &path) { return cli_->Post(path); }
inline Result Client::Post(const std::string &path, const Headers &headers) {
  return cli_->Post(path, headers);
}
inline Result Client::Post(const std::string &path, const char *body,
                           size_t content_length,
                           const std::string &content_type) {
  return cli_->Post(path, body, content_length, content_type);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const char *body, size_t content_length,
                           const std::string &content_type) {
  return cli_->Post(path, headers, body, content_length, content_type);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const char *body, size_t content_length,
                           const std::string &content_type, Progress progress) {
  return cli_->Post(path, headers, body, content_length, content_type,
                    progress);
}
inline Result Client::Post(const std::string &path, const std::string &body,
                           const std::string &content_type) {
  return cli_->Post(path, body, content_type);
}
inline Result Client::Post(const std::string &path, const std::string &body,
                           const std::string &content_type, Progress progress) {
  return cli_->Post(path, body, content_type, progress);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const std::string &body,
                           const std::string &content_type) {
  return cli_->Post(path, headers, body, content_type);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const std::string &body,
                           const std::string &content_type, Progress progress) {
  return cli_->Post(path, headers, body, content_type, progress);
}
inline Result Client::Post(const std::string &path, size_t content_length,
                           ContentProvider content_provider,
                           const std::string &content_type) {
  return cli_->Post(path, content_length, std::move(content_provider),
                    content_type);
}
inline Result Client::Post(const std::string &path,
                           ContentProviderWithoutLength content_provider,
                           const std::string &content_type) {
  return cli_->Post(path, std::move(content_provider), content_type);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           size_t content_length,
                           ContentProvider content_provider,
                           const std::string &content_type) {
  return cli_->Post(path, headers, content_length, std::move(content_provider),
                    content_type);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           ContentProviderWithoutLength content_provider,
                           const std::string &content_type) {
  return cli_->Post(path, headers, std::move(content_provider), content_type);
}
inline Result Client::Post(const std::string &path, const Params &params) {
  return cli_->Post(path, params);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const Params &params) {
  return cli_->Post(path, headers, params);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const Params &params, Progress progress) {
  return cli_->Post(path, headers, params, progress);
}
inline Result Client::Post(const std::string &path,
                           const MultipartFormDataItems &items) {
  return cli_->Post(path, items);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const MultipartFormDataItems &items) {
  return cli_->Post(path, headers, items);
}
inline Result Client::Post(const std::string &path, const Headers &headers,
                           const MultipartFormDataItems &items,
                           const std::string &boundary) {
  return cli_->Post(path, headers, items, boundary);
}
inline Result
Client::Post(const std::string &path, const Headers &headers,
             const MultipartFormDataItems &items,
             const MultipartFormDataProviderItems &provider_items) {
  return cli_->Post(path, headers, items, provider_items);
}
inline Result Client::Put(const std::string &path) { return cli_->Put(path); }
inline Result Client::Put(const std::string &path, const char *body,
                          size_t content_length,
                          const std::string &content_type) {
  return cli_->Put(path, body, content_length, content_type);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const char *body, size_t content_length,
                          const std::string &content_type) {
  return cli_->Put(path, headers, body, content_length, content_type);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const char *body, size_t content_length,
                          const std::string &content_type, Progress progress) {
  return cli_->Put(path, headers, body, content_length, content_type, progress);
}
inline Result Client::Put(const std::string &path, const std::string &body,
                          const std::string &content_type) {
  return cli_->Put(path, body, content_type);
}
inline Result Client::Put(const std::string &path, const std::string &body,
                          const std::string &content_type, Progress progress) {
  return cli_->Put(path, body, content_type, progress);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const std::string &body,
                          const std::string &content_type) {
  return cli_->Put(path, headers, body, content_type);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const std::string &body,
                          const std::string &content_type, Progress progress) {
  return cli_->Put(path, headers, body, content_type, progress);
}
inline Result Client::Put(const std::string &path, size_t content_length,
                          ContentProvider content_provider,
                          const std::string &content_type) {
  return cli_->Put(path, content_length, std::move(content_provider),
                   content_type);
}
inline Result Client::Put(const std::string &path,
                          ContentProviderWithoutLength content_provider,
                          const std::string &content_type) {
  return cli_->Put(path, std::move(content_provider), content_type);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          size_t content_length,
                          ContentProvider content_provider,
                          const std::string &content_type) {
  return cli_->Put(path, headers, content_length, std::move(content_provider),
                   content_type);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          ContentProviderWithoutLength content_provider,
                          const std::string &content_type) {
  return cli_->Put(path, headers, std::move(content_provider), content_type);
}
inline Result Client::Put(const std::string &path, const Params &params) {
  return cli_->Put(path, params);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const Params &params) {
  return cli_->Put(path, headers, params);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const Params &params, Progress progress) {
  return cli_->Put(path, headers, params, progress);
}
inline Result Client::Put(const std::string &path,
                          const MultipartFormDataItems &items) {
  return cli_->Put(path, items);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const MultipartFormDataItems &items) {
  return cli_->Put(path, headers, items);
}
inline Result Client::Put(const std::string &path, const Headers &headers,
                          const MultipartFormDataItems &items,
                          const std::string &boundary) {
  return cli_->Put(path, headers, items, boundary);
}
inline Result
Client::Put(const std::string &path, const Headers &headers,
            const MultipartFormDataItems &items,
            const MultipartFormDataProviderItems &provider_items) {
  return cli_->Put(path, headers, items, provider_items);
}
inline Result Client::Patch(const std::string &path) {
  return cli_->Patch(path);
}
inline Result Client::Patch(const std::string &path, const char *body,
                            size_t content_length,
                            const std::string &content_type) {
  return cli_->Patch(path, body, content_length, content_type);
}
inline Result Client::Patch(const std::string &path, const char *body,
                            size_t content_length,
                            const std::string &content_type,
                            Progress progress) {
  return cli_->Patch(path, body, content_length, content_type, progress);
}
inline Result Client::Patch(const std::string &path, const Headers &headers,
                            const char *body, size_t content_length,
                            const std::string &content_type) {
  return cli_->Patch(path, headers, body, content_length, content_type);
}
inline Result Client::Patch(const std::string &path, const Headers &headers,
                            const char *body, size_t content_length,
                            const std::string &content_type,
                            Progress progress) {
  return cli_->Patch(path, headers, body, content_length, content_type,
                     progress);
}
inline Result Client::Patch(const std::string &path, const std::string &body,
                            const std::string &content_type) {
  return cli_->Patch(path, body, content_type);
}
inline Result Client::Patch(const std::string &path, const std::string &body,
                            const std::string &content_type,
                            Progress progress) {
  return cli_->Patch(path, body, content_type, progress);
}
inline Result Client::Patch(const std::string &path, const Headers &headers,
                            const std::string &body,
                            const std::string &content_type) {
  return cli_->Patch(path, headers, body, content_type);
}
inline Result Client::Patch(const std::string &path, const Headers &headers,
                            const std::string &body,
                            const std::string &content_type,
                            Progress progress) {
  return cli_->Patch(path, headers, body, content_type, progress);
}
inline Result Client::Patch(const std::string &path, size_t content_length,
                            ContentProvider content_provider,
                            const std::string &content_type) {
  return cli_->Patch(path, content_length, std::move(content_provider),
                     content_type);
}
inline Result Client::Patch(const std::string &path,
                            ContentProviderWithoutLength content_provider,
                            const std::string &content_type) {
  return cli_->Patch(path, std::move(content_provider), content_type);
}
inline Result Client::Patch(const std::string &path, const Headers &headers,
                            size_t content_length,
                            ContentProvider content_provider,
                            const std::string &content_type) {
  return cli_->Patch(path, headers, content_length, std::move(content_provider),
                     content_type);
}
inline Result Client::Patch(const std::string &path, const Headers &headers,
                            ContentProviderWithoutLength content_provider,
                            const std::string &content_type) {
  return cli_->Patch(path, headers, std::move(content_provider), content_type);
}
inline Result Client::Delete(const std::string &path) {
  return cli_->Delete(path);
}
inline Result Client::Delete(const std::string &path, const Headers &headers) {
  return cli_->Delete(path, headers);
}
inline Result Client::Delete(const std::string &path, const char *body,
                             size_t content_length,
                             const std::string &content_type) {
  return cli_->Delete(path, body, content_length, content_type);
}
inline Result Client::Delete(const std::string &path, const char *body,
                             size_t content_length,
                             const std::string &content_type,
                             Progress progress) {
  return cli_->Delete(path, body, content_length, content_type, progress);
}
inline Result Client::Delete(const std::string &path, const Headers &headers,
                             const char *body, size_t content_length,
                             const std::string &content_type) {
  return cli_->Delete(path, headers, body, content_length, content_type);
}
inline Result Client::Delete(const std::string &path, const Headers &headers,
                             const char *body, size_t content_length,
                             const std::string &content_type,
                             Progress progress) {
  return cli_->Delete(path, headers, body, content_length, content_type,
                      progress);
}
inline Result Client::Delete(const std::string &path, const std::string &body,
                             const std::string &content_type) {
  return cli_->Delete(path, body, content_type);
}
inline Result Client::Delete(const std::string &path, const std::string &body,
                             const std::string &content_type,
                             Progress progress) {
  return cli_->Delete(path, body, content_type, progress);
}
inline Result Client::Delete(const std::string &path, const Headers &headers,
                             const std::string &body,
                             const std::string &content_type) {
  return cli_->Delete(path, headers, body, content_type);
}
inline Result Client::Delete(const std::string &path, const Headers &headers,
                             const std::string &body,
                             const std::string &content_type,
                             Progress progress) {
  return cli_->Delete(path, headers, body, content_type, progress);
}
inline Result Client::Options(const std::string &path) {
  return cli_->Options(path);
}
inline Result Client::Options(const std::string &path, const Headers &headers) {
  return cli_->Options(path, headers);
}

inline bool Client::send(Request &req, Response &res, Error &error) {
  return cli_->send(req, res, error);
}

inline Result Client::send(const Request &req) { return cli_->send(req); }

inline void Client::stop() { cli_->stop(); }

inline std::string Client::host() const { return cli_->host(); }

inline int Client::port() const { return cli_->port(); }

inline size_t Client::is_socket_open() const { return cli_->is_socket_open(); }

inline socket_t Client::socket() const { return cli_->socket(); }

inline void
Client::set_hostname_addr_map(std::map<std::string, std::string> addr_map) {
  cli_->set_hostname_addr_map(std::move(addr_map));
}

inline void Client::set_default_headers(Headers headers) {
  cli_->set_default_headers(std::move(headers));
}

inline void Client::set_header_writer(
    std::function<ssize_t(Stream &, Headers &)> const &writer) {
  cli_->set_header_writer(writer);
}

inline void Client::set_address_family(int family) {
  cli_->set_address_family(family);
}

inline void Client::set_tcp_nodelay(bool on) { cli_->set_tcp_nodelay(on); }

inline void Client::set_socket_options(SocketOptions socket_options) {
  cli_->set_socket_options(std::move(socket_options));
}

inline void Client::set_connection_timeout(time_t sec, time_t usec) {
  cli_->set_connection_timeout(sec, usec);
}

inline void Client::set_read_timeout(time_t sec, time_t usec) {
  cli_->set_read_timeout(sec, usec);
}

inline void Client::set_write_timeout(time_t sec, time_t usec) {
  cli_->set_write_timeout(sec, usec);
}

inline void Client::set_basic_auth(const std::string &username,
                                   const std::string &password) {
  cli_->set_basic_auth(username, password);
}
inline void Client::set_bearer_token_auth(const std::string &token) {
  cli_->set_bearer_token_auth(token);
}
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::set_digest_auth(const std::string &username,
                                    const std::string &password) {
  cli_->set_digest_auth(username, password);
}
#endif

inline void Client::set_keep_alive(bool on) { cli_->set_keep_alive(on); }
inline void Client::set_follow_location(bool on) {
  cli_->set_follow_location(on);
}

inline void Client::set_url_encode(bool on) { cli_->set_url_encode(on); }

inline void Client::set_compress(bool on) { cli_->set_compress(on); }

inline void Client::set_decompress(bool on) { cli_->set_decompress(on); }

inline void Client::set_interface(const std::string &intf) {
  cli_->set_interface(intf);
}

inline void Client::set_proxy(const std::string &host, int port) {
  cli_->set_proxy(host, port);
}
inline void Client::set_proxy_basic_auth(const std::string &username,
                                         const std::string &password) {
  cli_->set_proxy_basic_auth(username, password);
}
inline void Client::set_proxy_bearer_token_auth(const std::string &token) {
  cli_->set_proxy_bearer_token_auth(token);
}
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::set_proxy_digest_auth(const std::string &username,
                                          const std::string &password) {
  cli_->set_proxy_digest_auth(username, password);
}
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::enable_server_certificate_verification(bool enabled) {
  cli_->enable_server_certificate_verification(enabled);
}
#endif

inline void Client::set_logger(Logger logger) {
  cli_->set_logger(std::move(logger));
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::set_ca_cert_path(const std::string &ca_cert_file_path,
                                     const std::string &ca_cert_dir_path) {
  cli_->set_ca_cert_path(ca_cert_file_path, ca_cert_dir_path);
}

inline void Client::set_ca_cert_store(X509_STORE *ca_cert_store) {
  if (is_ssl_) {
    static_cast<SSLClient &>(*cli_).set_ca_cert_store(ca_cert_store);
  } else {
    cli_->set_ca_cert_store(ca_cert_store);
  }
}

inline void Client::load_ca_cert_store(const char *ca_cert, std::size_t size) {
  set_ca_cert_store(cli_->create_ca_cert_store(ca_cert, size));
}

inline long Client::get_openssl_verify_result() const {
  if (is_ssl_) {
    return static_cast<SSLClient &>(*cli_).get_openssl_verify_result();
  }
  return -1; // NOTE: -1 doesn't match any of X509_V_ERR_???
}

inline SSL_CTX *Client::ssl_context() const {
  if (is_ssl_) { return static_cast<SSLClient &>(*cli_).ssl_context(); }
  return nullptr;
}
#endif

// ----------------------------------------------------------------------------

} // namespace httplib

#if defined(_WIN32) && defined(CPPHTTPLIB_USE_POLL)
#undef poll
#endif

#endif // CPPHTTPLIB_HTTPLIB_H


--- FILE: Common/elasticsearch_basic.hpp ---
内容:
// es基本的增删查改操作

#pragma once
#include <elasticlient/client.h>
#include <json/json.h>
#include <cpr/cpr.h>
#include <iostream>
#include <memory>
#include <vector>

#include "logger.hpp"

namespace chen_im {

bool Serialize(const Json::Value &val, std::string *out_str)
{
    // 先定义
    Json::StreamWriterBuilder swb;
    std::unique_ptr<Json::StreamWriter> stream_writer(swb.newStreamWriter());
    // 通过streamwriter中的write接口进行序列化
    std::stringstream ss;
    int ret = stream_writer->write(val, &ss);
    if(ret != 0) {
        LOG_ERROR("反序列化失败!");
        return false;
    }
    *out_str = ss.str();
    return true;
}

bool Deserialize(const std::string &src, Json::Value *out_value)
{
    Json::CharReaderBuilder crb;
    std::unique_ptr<Json::CharReader> cr(crb.newCharReader());
    std::string err;
    bool ret = cr->parse(src.c_str(), src.c_str() + src.size(), out_value, &err);
    if (ret == false) {
        LOG_ERROR("json反序列化失败，原因：{}", err);
        return false;
    }
    return true;
}


// 封装创建索引的接口，类似于创建数据库中的表
//   索引如何创建:
//   1.能够设定索引名称，索引类型
//   2.能够添加字段，并设置字段类型，设置分词器类型，给出“是否构造索引”的选项
// 创建索引的本质是根据请求体的json格式，对应构造Value对象
class ESIndex
{
private:
    std::string _name;
    std::string _type;
    Json::Value _index;
    Json::Value _properties;
    std::shared_ptr<elasticlient::Client> _client; // ES客户端

public:
    // 初始化一个索引
    ESIndex(const std::string &index_name, 
    const std::string &index_type, 
    std::shared_ptr<elasticlient::Client> es_client_ptr)
        :_name(index_name)
        , _type(index_type)
        , _client(es_client_ptr)
    {
        Json::Value settings;
        Json::Value analysis;
        Json::Value analyzer;
        Json::Value ik;
        Json::Value tokenizer;
        
        // "settings" : {
        //     "analysis" : {
        //         "analyzer" : {
        //             "ik" : {
        //                 "tokenizer" : "ik_max_word" 
        //             }
        //         }   
        //     }
        // },

        tokenizer = "ik_max_word";
        ik["tokenizer"] = tokenizer;
        analyzer["ik"] = ik;
        analysis["analyzer"] = analyzer;
        settings["analysis"] = analysis;
        _index["settings"] = settings;

        std::string output;
        Serialize(_index, &output);
        LOG_DEBUG("_index被序列化后：{}", output);
    }
    ~ESIndex() {}

    // 往properties中添加内容
    ESIndex& append(const std::string &key, 
                const std::string &type = "text", 
                const std::string &analyzer = "ik_max_word", 
                bool enabled = true)
    {
        // "mappings" : {
        //     "dynamic" : true,
        //     "properties" : {
        //         "nickname" : {
        //             "type" : "text", 
        //             "analyzer" : "ik_max_word"
        //         },
        //         "user_id" : {
        //             "type" : "keyword",
        //             "analyzer" : "standard"
        //         },
        //         "phone" : {
        //             "type" : "keyword",
        //             "analyzer" : "standard"
        //         },
        //         "description" : {
        //             "type" : "text",
        //             "enabled" : false 
        //         },
        //         "avatar_id" : {
        //             "type" : "keyword",
        //             "enabled" : false
        //         }
        //     }
        // }
        Json::Value fields; // “nickname/user_id/phone”中的内容
        fields["type"]= type;
        fields["analyzer"] = analyzer;
        if (enabled == false) fields["enabled"] = enabled;
        _properties[key] = fields;

        return *this; // 支持连续调用
    }

    // 构建mappings，并将mappings放入响应体中，最后序列化整个索引，并发送
    bool create_and_send()
    {
        Json::Value mappings;
        mappings["dynamic"] = true;
        mappings["properties"] = _properties;
        _index["mappings"] = mappings;

        std::string body; // 请求体
        bool ret = Serialize(_index, &body);
        if (ret == false) {
            LOG_ERROR("索引序列化失败！");
            return false;
        } else {
            LOG_DEBUG("索引序列化成功！");
        }

        try {
            // 2. 发起搜索请求
            auto resp = _client->index(_name, _type, "", body);
            if (resp.status_code < 200 | resp.status_code >= 300) {
                LOG_ERROR("创建ES索引 {} 失败，响应状态码：{}", _name, resp.status_code);
                return false;
            } else {
                // 3. 打印响应状态码和响应正文
                LOG_DEBUG("创建ES索引 {} 成功，ES服务器发回响应：", _name);
                LOG_DEBUG("状态码: {}", resp.status_code);
                LOG_DEBUG("响应正文：\n{}", resp.text);
            }
        } catch(std::exception &e) {
            LOG_ERROR("创建ES索引 {} 失败，失败原因：{}", _name, e.what());
            return false;
        }

        return true;
    }
};


// 数据新增：
// 1. 提供用户一个新增字段及数据的接口即可
// 2. 提供一个发起请求的接口

class ESInsert
{
private:
    std::string _name;
    std::string _type;
    Json::Value _item;
    std::shared_ptr<elasticlient::Client> _client; // ES客户端
public:
    ESInsert(const std::string &index_name, 
             const std::string &index_type, 
             std::shared_ptr<elasticlient::Client> es_client_ptr)
        :_name(index_name)
        , _type(index_type)
        , _client(es_client_ptr)
    {}
    ~ESInsert() {}

    ESInsert& append(const std::string &key, const std::string &value)
    {
        _item[key] = value;
        return *this;
    }

    bool insert_and_send(const std::string &id)
    {
        // 1. 序列化请求体
        std::string body;
        bool ret = Serialize(_item, &body);
        if (ret == false) {
            LOG_ERROR("索引序列化失败！");
            return false;
        } else {
            LOG_DEBUG("索引序列化成功！");
        }

        try {
            // 2. 发起搜索请求
            auto resp = _client->index(_name, _type, id, body);
            if (resp.status_code < 200 | resp.status_code >= 300) {
                LOG_ERROR("新增数据 {} 失败，响应状态码：", _name, resp.status_code);
                return false;
            } else {
                // 3. 打印响应状态码和响应正文
                LOG_DEBUG("搜索 {}索引 成功，ES服务器发回响应：", _name);
                LOG_DEBUG("状态码: {}", resp.status_code);
                LOG_DEBUG("响应正文：\n{}", resp.text);
            }
        } catch(std::exception &e) {
            LOG_ERROR("搜索 {} 失败，失败原因：{}", _name, e.what());
            return false;
        }

        return true;
    }
};


// 封装数据删除
class ESRemove
{
private:
    std::string _name;
    std::string _type;
    Json::Value _item;
    std::shared_ptr<elasticlient::Client> _client; // ES客户端
public:
    ESRemove(const std::string &index_name, 
             const std::string &index_type, 
             std::shared_ptr<elasticlient::Client> es_client_ptr)
        :_name(index_name)
        , _type(index_type)
        , _client(es_client_ptr)
    {}
    ~ESRemove() {}

    bool remove(const std::string &id)
    {
        // 1. 序列化请求体
        std::string body;
        bool ret = Serialize(_item, &body);
        if (ret == false) {
            LOG_ERROR("索引序列化失败！");
            return false;
        } else {
            LOG_DEBUG("索引序列化成功！");
        }

        try {
            // 2. 发起搜索请求
            auto resp = _client->remove(_name, _type, id);
            if (resp.status_code < 200 | resp.status_code >= 300) {
                LOG_ERROR("删除数据 {} 失败，响应状态码：", id, resp.status_code);
                return false;
            } else {
                // 3. 打印响应状态码和响应正文
                LOG_DEBUG("删除数据 {} 成功，ES服务器发回响应：", id);
                LOG_DEBUG("状态码: {}", resp.status_code);
                LOG_DEBUG("响应正文：\n{}", resp.text);
            }
        } catch(std::exception &e) {
            LOG_ERROR("删除数据 {} 失败，失败原因：{}", id, e.what());
            return false;
        }

        return true;
    }
};

class ESSearch
{
private:
    std::string _name;
    std::string _type;
    Json::Value _must_not;
    Json::Value _should;

    Json::Value _must;

    std::shared_ptr<elasticlient::Client> _client; // ES客户端
public:
    ESSearch(const std::string &index_name, 
             const std::string &index_type, 
             std::shared_ptr<elasticlient::Client> es_client_ptr)
        :_name(index_name)
        , _type(index_type)
        , _client(es_client_ptr)
    {}
    ~ESSearch() {}

    ESSearch& append_must_term(const std::string &key, const std::string &value)
    {
        Json::Value fields;
        Json::Value term;
        term[key] = value;
        fields["term"] = term;

        _must.append(fields);

        return *this;
    }

    ESSearch& append_must_match(const std::string &key, const std::string &value)
    {
        Json::Value fields;
        Json::Value match;
        match[key] = value;
        fields["match"] = match;

        _must.append(fields);
        return *this;
    }

    ESSearch& append_must_not_terms(const std::string &key, const std::vector<std::string> &value)
    {
        Json::Value fields;
        for(const auto& val:value)
        {
            fields["key"].append(val);
        }
        Json::Value terms;
        terms["terms"]=fields;
        _must_not.append(terms);

        return *this;
    }

    ESSearch& append_should_match(const std::string &key, const std::string &val)
    {
        Json::Value field;
        field[key] = val;
        Json::Value match;
        match["match"] = field;
        _should.append(match);
        return *this;
    }

    Json::Value search()
    {
        Json::Value cond;
        if (_must_not.empty() == false) {
            cond["must_not"] = _must_not;
        }
        if(_should.empty() == false) {
            cond["should"] = _should;
        }
        if(_must.empty() == false) {
            cond["must"] = _must;
        }
        Json::Value query;
        query["bool"] = cond;
        Json::Value req_body;
        req_body["query"] = query;

        // 1. 序列化请求体
        std::string body;
        bool ret = Serialize(req_body, &body);
        if (ret == false) {
            LOG_ERROR("索引序列化失败！");
            return Json::Value();
        } else {
            LOG_DEBUG("索引序列化成功！");
        }

        try {
            // 2. 发起搜索请求
            auto resp = _client->search(_name, _type, body);
            if (resp.status_code < 200 | resp.status_code >= 300) {
                LOG_ERROR("查找数据 {} 失败，响应状态码：", body, resp.status_code);
                LOG_DEBUG("响应正文：\n{}", resp.text);
                return Json::Value();
            } else {
                // 3. 打印响应状态码和响应正文
                LOG_DEBUG("查找数据 {} 成功，查询query：{}", _name, body);
                LOG_DEBUG("ES服务器发回响应，状态码: {}", resp.status_code);
                LOG_DEBUG("响应正文：\n{}", resp.text);
            }
            // 4. 反序列化
            Json::Value json_result;
            ret = Deserialize(resp.text, &json_result);
            if (ret == false) {
                LOG_ERROR("检索数据 {} 结果的反序列化失败", resp.text);
                return Json::Value();
            }
            return json_result["hits"]["hits"];

        } catch(std::exception &e) {
            LOG_ERROR("查找数据 {} 失败，失败原因：{}", body, e.what());
            return Json::Value();
        }
        return Json::Value();
    }
};

}

--- FILE: Common/mysql_chat_session.hpp ---
内容:
#pragma once
#include "logger.hpp"
#include "mysql_odb_factory.hpp"
#include "chat_session.hxx"
#include "chat_session-odb.hxx"
#include "mysql_chat_session_member.hpp"

namespace chen_im
{
    class ChatSessionTable
    {
    public:
        using ptr = std::shared_ptr<ChatSessionTable>;
        ChatSessionTable(const std::shared_ptr<odb::mysql::database> &db) : _db(db) {}
        bool insert(ChatSession &cs)
        {
            try
            {
                odb::transaction trans(_db->begin());
                _db->persist(cs);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("新增会话失败 {}:{}！", cs.chat_session_name(), e.what());
                return false;
            }
            return true;
        }
        bool remove(const std::string &ssid)
        {
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<ChatSession> query;
                typedef odb::result<ChatSession> result;
                _db->erase_query<ChatSession>(query::chat_session_id == ssid);

                typedef odb::query<ChatSessionMember> mquery;
                _db->erase_query<ChatSessionMember>(mquery::chat_session_id == ssid);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除会话失败 {}:{}！", ssid, e.what());
                return false;
            }
            return true;
        }
        bool remove(const std::string &uid, const std::string &pid)
        {
            // 单聊会话的删除，-- 根据单聊会话的两个成员
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<SingleChatSession> query;
                typedef odb::result<SingleChatSession> result;
                auto res = _db->query_one<SingleChatSession>(
                    query::csm1::user_id == uid &&
                    query::csm2::user_id == pid &&
                    query::css::chat_session_type == ChatSessionType::SINGLE);

                std::string cssid = res->chat_session_id;
                typedef odb::query<ChatSession> cquery;
                _db->erase_query<ChatSession>(cquery::chat_session_id == cssid);

                typedef odb::query<ChatSessionMember> mquery;
                _db->erase_query<ChatSessionMember>(mquery::chat_session_id == cssid);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除会话失败 {}-{}:{}！", uid, pid, e.what());
                return false;
            }
            return true;
        }
        std::shared_ptr<ChatSession> select(const std::string &ssid)
        {
            std::shared_ptr<ChatSession> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<ChatSession> query;
                typedef odb::result<ChatSession> result;
                res.reset(_db->query_one<ChatSession>(query::chat_session_id == ssid));
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("通过会话ID获取会话信息失败 {}:{}！", ssid, e.what());
            }
            return res;
        }

        // 获取某个用户的所有单聊会话列表
        std::vector<SingleChatSession> singleChatSession(const std::string &uid)
        {
            std::vector<SingleChatSession> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<SingleChatSession> query;
                typedef odb::result<SingleChatSession> result;

                // 对应的sql类似：
                // SELECT css._chat_session_id, csm2._user_id AS friend_id
                // FROM chat_session AS css
                // JOIN chat_session_member AS csm1 ON css._chat_session_id = csm1._session_id
                // JOIN chat_session_member AS csm2 ON css._chat_session_id = csm2._session_id
                // WHERE css.chat_session_type = 1 -- SINGLE
                //   AND csm1.user_id = 'uid_value' -- 替换为实际的 uid
                //   AND csm2.user_id != csm1.user_id;

                result r(_db->query<SingleChatSession>(
                    query::css::chat_session_type == ChatSessionType::SINGLE &&
                    query::csm1::user_id == uid &&
                    query::csm2::user_id != query::csm1::user_id));
                for (result::iterator i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(*i);
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取用户 {} 的单聊会话失败:{}！", uid, e.what());
            }
            return res;
        }

        // 获取某个用户的所有群聊会话列表
        std::vector<GroupChatSession> groupChatSession(const std::string &uid)
        {
            std::vector<GroupChatSession> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<GroupChatSession> query;
                typedef odb::result<GroupChatSession> result;
                // 当前的uid是被申请者的用户ID
                result r(_db->query<GroupChatSession>(
                    query::css::chat_session_type == ChatSessionType::GROUP &&
                    query::csm::user_id == uid));
                for (result::iterator i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(*i);
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取用户 {} 的群聊会话失败:{}！", uid, e.what());
            }
            return res;
        }

    private:
        std::shared_ptr<odb::mysql::database> _db;
    };
}

--- FILE: Common/mysql_message.hpp ---
内容:
#pragma once
#include "logger.hpp"
#include "mysql_odb_factory.hpp"
#include "message.hxx"
#include "message-odb.hxx"

#include <odb/mysql/database.hxx>
#include <odb/query.hxx>
#include <odb/result.hxx>


namespace chen_im
{
    // mysql数据库的message表的增删查改接口
    class MessageTable
    {
    private:
        std::shared_ptr<odb::mysql::database> _db; // 对数据库message表的增删查改操作，变成了对这个数据库对象的操作

    public:
        using ptr = std::shared_ptr<MessageTable>;
        MessageTable(const std::shared_ptr<odb::mysql::database> &db) : _db(db) {}
        ~MessageTable() {}


        /// @brief MySQL事务：向message表插入一条消息
        /// @param msg Message对象，在"message.hxx"里面定义的
        /// @return 插入是否成功
        bool insert(Message &msg)
        {
            try
            {
                //1. 获取事务对象开启事务
                odb::transaction trans(_db->begin());

                //2. 持久化
                _db->persist(msg);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("向mysql数据库的message表插入一条消息失败，message_id：{}，错误原因：{}！", msg.message_id(), e.what());
                return false;
            }
            LOG_DEBUG("向mysql数据库的message表插入一条消息成功！");
            return true;
        }


        /// @brief MySQL事务：删除message表中指定聊天会话id下的所有消息
        /// @param ssid 聊天会话id
        /// @return 是否成功
        bool remove(const std::string &ssid)
        {
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<Message> query;
                typedef odb::result<Message> result;
                _db->erase_query<Message>(query::session_id == ssid);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除会话 {} 的所有消息失败，错误原因: {}！", ssid, e.what());
                return false;
            }
            LOG_DEBUG("删除会话 {} 的所有消息成功！", ssid);

            return true;
        }


        /// @brief MySQL事务：获取message表中某个聊天会话下的最近的 `count` 条消息
        /// @param ssid 聊天会话id
        /// @param count 消息条数
        /// @return 消息数组
        std::vector<Message> recent(const std::string &ssid, int count)
        {
            std::vector<Message> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<Message> query;
                typedef odb::result<Message> result;
                // 本次查询是以ssid作为过滤条件，然后进行以时间字段进行逆序，通过limit
                // select * from message where session_id='xx' order by create_time desc limit count;
                std::stringstream cond;
                cond << "session_id='" << ssid << "' ";
                cond << "order by create_time desc limit " << count;

                result r(_db->query<Message>(cond.str()));
                for (auto i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(*i);
                }
                std::reverse(res.begin(), res.end());
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取最近的 {} 条消息失败！聊天会话id: {}, 错误原因：{}", count, ssid, e.what());
            }
            return res;
        }


        /// @brief MySQL事务：获取message表中某个聊天会话下的指定时间范围内的消息
        /// @param ssid 聊天会话id
        /// @param stime 开始时间
        /// @param etime 结束时间
        /// @return 消息数组
        std::vector<Message> range(const std::string &ssid,
                                   boost::posix_time::ptime &stime,
                                   boost::posix_time::ptime &etime)
        {
            std::vector<Message> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<Message> query;
                typedef odb::result<Message> result;
                // 获取指定会话指定时间段的信息
                result r(_db->query<Message>(query::session_id == ssid &&
                                             query::create_time >= stime &&
                                             query::create_time <= etime));
                for (auto i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(*i);
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取指定时间范围内的消息失败，时间范围：{}-{}，会话id：{}，错误原因：{}！",
                          boost::posix_time::to_simple_string(stime),
                          boost::posix_time::to_simple_string(etime),
                          ssid, 
                          e.what());
            }
            return res;
        }


    };
}

--- FILE: Common/voice_recognizer.hpp ---
内容:
// 封装出一个语音识别客户端类
// 1. 在构造函数中，输入语音识别平台的key相关信息
// 2. 提供一个语音识别的接口（输入参数就是语音数据）

#pragma once
#include "speech.h"
#include "logger.hpp"


namespace chen_im {

class VoiceRecognizerClient
{
private:
    aip::Speech _client;
public:
    VoiceRecognizerClient(const std::string &app_id, 
                          const std::string &api_key, 
                          const std::string &secret_key) 
        :_client(app_id, api_key, secret_key)
    {}

    std::string recognize(const std::string &speech_data)
    {
        Json::Value result = _client.recognize(speech_data,"pcm",16000,aip::null);
        if (result["err_no"].asInt() != 0)
        {
            LOG_ERROR("语音识别失败：{}", result["err_msg"].asString());
            return std::string();
        }
        return result["result"][0].asString();
    }

    ~VoiceRecognizerClient() {}
};

}

--- FILE: Common/redis_CRUD.hpp ---
内容:
// redis数据管理：
// 1.会话信息的管理：会话ID和用户ID的键值对
// - 用户登录的时候创建登录会话：分配一个登录会话ID出来，向redis中添加键值
// - 对用户进行其他的操作的时候：发送会话ID过来；通过会话ID在redis中查找键值对;
// - 操作：会话信息的新增/删除/获取;

// 2.登录状态的管理：用户ID和空值的键值对
// - 用户登录的时候，添加用户ID进去;
// - 用户长连接断开的时候，删除这个用户ID的键值
// - 对重复登录的时候，查询对应的用户ID信息是否存在，如果存在就是重复登录
// - 操作：登录状态的新增/删除/判断是否存在

// 3.验证码的管理：验证码ID和验证码的键值对
// - 用户获取短信验证码的时候：生成验证码和ID，添加redis管理(验证码信息具有时效)
// - 手机号注册/登录/修改绑定手机号的时候：进行验证码及ID的验证
// - 当验证验证码的时候：删除验证码
// - 操作：验证码信息的新增/删除/获取

#include <sw/redis++/redis.h>
#include <iostream>

namespace chen_im
{
    class RedisDatabaseUtility
    {
    private:
        std::shared_ptr<sw::redis::Redis> _sw_redis_client;
    
    public:
        using ptr = std::shared_ptr<RedisDatabaseUtility>;

        RedisDatabaseUtility(const std::shared_ptr<sw::redis::Redis> &sw_redis_client)
            : _sw_redis_client(sw_redis_client)
        {}
        ~RedisDatabaseUtility() {}

        // 清理redis所有的缓存
        bool flush_all_db()
        {
            _sw_redis_client->flushall();
        }

    };
    

    class RedisClientFactory
    {
    public:
        /// @brief 构建Redis客户端
        /// @param host redis服务器地址
        /// @param port redis服务器端口号
        /// @param db 
        /// @param keep_alive 是否进行长连接保活
        /// @return 
        static std::shared_ptr<sw::redis::Redis> create(
            const std::string &host,
            int port,
            int db,
            bool keep_alive)
        {
            sw::redis::ConnectionOptions opts;
            opts.host = host;
            opts.port = port;
            opts.db = db;
            opts.keep_alive = keep_alive;
            auto res = std::make_shared<sw::redis::Redis>(opts);
            return res;
        }
    };

    // 会话ID和用户ID的键值对
    class Session
    {
    public:
        using ptr = std::shared_ptr<Session>;
        Session(const std::shared_ptr<sw::redis::Redis> &redis_client) 
            : _redis_client(redis_client) 
        {}

        void append(const std::string &ssid, const std::string &uid)
        {
            _redis_client->set(ssid, uid);
        }

        void remove(const std::string &ssid)
        {
            _redis_client->del(ssid);
        }

        sw::redis::OptionalString get_uid(const std::string &ssid)
        {
            return _redis_client->get(ssid);
        }

    private:
        std::shared_ptr<sw::redis::Redis> _redis_client;
    };

    // 用户ID和空值的键值对
    class Status
    {
    public:
        using ptr = std::shared_ptr<Status>;
        Status(const std::shared_ptr<sw::redis::Redis> &redis_client) : _redis_client(redis_client) {}
        void append(const std::string &uid)
        {
            _redis_client->set(uid, "");
        }

        void remove(const std::string &uid)
        {
            _redis_client->del(uid);
        }

        bool exists(const std::string &uid)
        {
            auto res = _redis_client->get(uid);
            if (res)
                return true;
            return false;
        }

    private:
        std::shared_ptr<sw::redis::Redis> _redis_client;
    };

    // 验证码ID和验证码的键值对
    class Codes
    {
    public:
        using ptr = std::shared_ptr<Codes>;
        Codes(const std::shared_ptr<sw::redis::Redis> &redis_client) 
            : _redis_client(redis_client) 
        {}


        /// @param ttl 键值对过期时间
        void append(const std::string &cid, const std::string &code,
                    const std::chrono::milliseconds &ttl = std::chrono::milliseconds(300000))
        {
            _redis_client->set(cid, code, ttl);
        }

        void remove(const std::string &cid)
        {
            _redis_client->del(cid);
        }

        sw::redis::OptionalString code(const std::string &cid)
        {
            return _redis_client->get(cid);
        }

    private:
        std::shared_ptr<sw::redis::Redis> _redis_client;
    };
}

--- FILE: Common/rpc_service_manager.hpp ---
内容:
// 我们的子服务之间存在相互调用的关系，相互调用的本质是某个子服务需要调用其他子服务提供的rpc接口，
// 在brpc框架下：
// 1. 服务的调用者通过一个brpc::Channel来调用提供这个rpc服务的实例，
//    而提供同一种rpc服务的服务实例会有很多，当然要把这些brpc::Channel管理起来，于是就有了ChannelManager类
// 2. 服务的调用者可能会调用不止一个子服务，当然要把每个服务的ChannelManager对象都管理起来，
//    于是就有了ServiceManager，它采用<服务名称, 该服务的信道管理对象>来管理服务

#pragma once
#include <brpc/channel.h>
#include <string>
#include <vector>

#include "./logger.hpp"

namespace chen_im {

// 信道管理对象
// 1. 把一种服务的所有提供该服务的信道管理起来，因为提供同一种服务的主机可能有很多(目前只设计一对多)
// 一个ChannelManager对象管理一种服务，但是管理多个信道，而信道和一个套接字是对应的
class ChannelManager
{
public:
    using ChannelPtr = std::shared_ptr<brpc::Channel>;
private:
    std::mutex _mutex;                 // 保证增删查改的线程安全
    int32_t _index;                    // 当前轮转的下标计数器
    std::string _service_name;         // 服务名称
    std::vector<ChannelPtr> _channels; // 所有的信道的集合
    std::unordered_map<std::string, ChannelPtr> _host_to_channle; // 存放主机名称到channel智能指针的映射
public:
    ChannelManager(const std::string &name) 
        :_service_name(name), _index(0)
    {}
    ~ChannelManager() {}

    /// @brief  上线一个服务节点后，调用append新增对应信道
    /// @param host 主机+端口号，例如："127.0.0.1:8787"
    void append_host(const std::string &host)
    {
        // 1. 构造一个channel，用于连接服务器
        ChannelPtr channel = std::make_shared<brpc::Channel>();
        brpc::ChannelOptions options;
        options.connect_timeout_ms = -1;
        options.max_retry = 3;
        options.protocol = "baidu_std";

        int ret = channel->Init(host.c_str(), &options);
        if (ret == -1) {
            LOG_ERROR("初始化{}-{}的信道失败！", _service_name, host);
        }

        // 插入操作，加锁
        std::unique_lock<std::mutex> _lock(_mutex);
        _host_to_channle.insert(std::make_pair(host, channel));
        _channels.push_back(channel);
    }
    // 下线一个服务节点后，调用remove删除对应信道
    void remove_host(const std::string &host)
    {
        // 删除操作，加锁
        std::unique_lock<std::mutex> _lock(_mutex);
        auto hash_iter = _host_to_channle.find(host);
        if (hash_iter == _host_to_channle.end()) {
            LOG_WARN("没有找到信道{}-{}，无法删除信道", _service_name, host);
        }

        for (auto vector_iter = _channels.begin(); vector_iter != _channels.end(); vector_iter++)
        {
            if (*vector_iter == hash_iter->second) {
                _channels.erase(vector_iter);
                _host_to_channle.erase(hash_iter);
                break;
            }
        }
    }

    // 获取信道的智能指针，以便调用服务
    ChannelPtr get()
    {
        std::unique_lock<std::mutex> lock(_mutex);
        if (_channels.size() == 0) {
            return nullptr;
        }
        std::size_t i = _index++ %_channels.size();
        return _channels[i];
    }
};


// 2. 把各种服务管理起来
class ServiceManager
{
public:
    using ptr = std::shared_ptr<ServiceManager>;
private:
    std::mutex _mutex;
    std::unordered_set<std::string> _concern; // 关心的服务
    std::unordered_map<std::string, std::shared_ptr<ChannelManager>> _services; // <服务名称, 该服务的信道管理对象>

    std::string get_service_name(const std::string &service_instance)
    {
        auto pos = service_instance.find_last_of('/');
        if(pos == std::string::npos) {
            return service_instance;
        }
        return service_instance.substr(0, pos);
    }
public:
    ServiceManager() {}
    ~ServiceManager() {}

    // 声明需要关心上下线的服务，不关心的服务不会被管理起来
    void concern(const std::string &service_name)
    {
        std::unique_lock<std::mutex> _lock(_mutex);
        _concern.insert(service_name);
    }

    // 某个服务的某个节点上线的时候被Discovery客户端回调的接口，如果这个服务被设置为“关心”，则会被ServiceManager管理起来
    void when_service_online(const std::string &service_instance_name, const std::string &host)
    {
        std::string service_name = get_service_name(service_instance_name);
        std::shared_ptr<ChannelManager> s;
        {        
            std::unique_lock<std::mutex> _lock(_mutex);

            auto cit = _concern.find(service_name);
            if (cit == _concern.end()) {
                LOG_DEBUG("节点 {}-{} 上线了，但是服务管理对象并不关心它！", service_name, host);
                return;
            }

            // 先获取该服务的信道管理对象，没有则创建新的管理对象
            auto sit = _services.find(service_name);
            if (sit == _services.end()) {// 没有则创建新的管理对象
                s = std::make_shared<ChannelManager>(service_name);
                _services.insert({service_name, s});
            } else {
                s = sit->second;    
            } 
        }

        if(!s) {
            LOG_ERROR("新增 {} 信道管理对象失败！", service_name);
        }

        // 往管理对象中添加该节点
        s->append_host(host); // 添加主机操作的线程安全已经由ChannelManager类保证了
    }



    // 某个服务的某个节点下线的时候被Discovery客户端回调的接口
    void when_service_offline(const std::string &service_instance_name, const std::string &host)
    {
        std::string service_name = get_service_name(service_instance_name);
        std::shared_ptr<ChannelManager> s;
        {        
            std::unique_lock<std::mutex> _lock(_mutex);
            auto sit = _services.find(service_name);
            if (sit == _services.end()) {
                LOG_WARN("删除 {}-{} 信道时，没有找到它的信道管理对象，停止删除", service_name, host);
                return;
            }
            s = sit->second;
        }
        s->remove_host(host);
    }

    // 获取指定服务的原生brpc的channel的智能指针
    ChannelManager::ChannelPtr get(const std::string &service_name)
    {
        std::unique_lock<std::mutex> _lock(_mutex);
        auto sit = _services.find(service_name);
        if (sit == _services.end()) {
            LOG_ERROR("当前没有能够提供 {} 服务的节点！", service_name);
            return nullptr;
        }
        return sit->second->get();
    }
};

}

--- FILE: Common/mysql_apply.hpp ---
内容:
#pragma once
#include "logger.hpp"
#include "mysql_odb_factory.hpp"
#include "friend_apply.hxx"
#include "friend_apply-odb.hxx"

namespace chen_im
{
    class FriendApplyTable
    {
    public:
        using ptr = std::shared_ptr<FriendApplyTable>;
        FriendApplyTable(const std::shared_ptr<odb::mysql::database> &db) : _db(db) {}
        bool insert(FriendApply &ev)
        {
            try
            {
                odb::transaction trans(_db->begin());
                _db->persist(ev);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("新增好友申请事件失败 {}-{}:{}！", ev.user_id(), ev.peer_id(), e.what());
                return false;
            }
            return true;
        }
        bool exists(const std::string &uid, const std::string &pid)
        {
            bool flag = false;
            try
            {
                typedef odb::query<FriendApply> query;
                typedef odb::result<FriendApply> result;
                odb::transaction trans(_db->begin());
                result r(_db->query<FriendApply>(query::user_id == uid && query::peer_id == pid));
                LOG_DEBUG("{} - {} 好友事件数量：{}", uid, pid, r.size());
                flag = !r.empty();
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取好友申请事件失败:{}-{}-{}！", uid, pid, e.what());
            }
            return flag;
        }
        bool remove(const std::string &uid, const std::string &pid)
        {
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<FriendApply> query;
                typedef odb::result<FriendApply> result;
                _db->erase_query<FriendApply>(query::user_id == uid && query::peer_id == pid);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除好友申请事件失败 {}-{}:{}！", uid, pid, e.what());
                return false;
            }
            return true;
        }
        // 获取当前指定用户的，所有正在申请添加好友的user_id
        std::vector<std::string> apply_users(const std::string &uid)
        {
            std::vector<std::string> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<FriendApply> query;
                typedef odb::result<FriendApply> result;
                // 当前的uid是被申请者的用户ID
                result r(_db->query<FriendApply>(query::peer_id == uid));
                for (result::iterator i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(i->user_id());
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("通过用户{}的好友申请者失败:{}！", uid, e.what());
            }
            return res;
        }

    private:
        std::shared_ptr<odb::mysql::database> _db;
    };
}

--- FILE: Common/utility.hpp ---
内容:
/// @namespace chen_im  
/// 命名空间chen_im包含项目中一些公共的工具类接口  
  
#include <iostream>  
#include <fstream>  
#include <sstream>  
#include <string>  
#include <atomic>  
#include <random>  
#include <iomanip>  
#include "logger.hpp"  
  
namespace chen_im {  
  
    /// @brief 生成一个唯一ID  
    /// @return 返回生成的唯一ID字符串 形如：34cc-e65243b7-0000
    std::string generate_uuid() {  
        std::random_device rd;  
        std::mt19937 generator(rd());  
        std::uniform_int_distribution<int> distribution(0,255);  
  
        std::stringstream ss;  
        for (int i = 0; i < 6; i++) {  
            if (i == 2) ss << "-";  
            ss << std::setw(2) << std::setfill('0') << std::hex << distribution(generator);  
        }  
        ss << "-";  
  
        static std::atomic<short> idx(0);  
        short tmp = idx.fetch_add(1);  
        ss << std::setw(4) << std::setfill('0') << std::hex << tmp;  
        return ss.str();  
    }  
  
    /// @brief 生成一个四位数字的验证码  
    /// @return 返回生成的验证码字符串  
    std::string generate_verification_code() {  
        std::random_device rd;  
        std::mt19937 generator(rd());  
        std::uniform_int_distribution<int> distribution(0,9);  
  
        std::stringstream ss;  
        for (int i = 0; i < 4; i++) {  
            ss << distribution(generator);  
        }  
        return ss.str();  
    }  
  
    /// @brief 读取文件内容  
    /// @param filename 文件名  
    /// @param body 用于存储文件内容的字符串  
    /// @return 读取成功返回true，失败返回false  
    bool read_file(const std::string &filename, std::string &body) {  
        std::ifstream ifs(filename, std::ios::binary | std::ios::in);  
        if (!ifs.is_open()) {  
            LOG_ERROR("打开文件 {} 失败！", filename);  
            return false;  
        }  
        ifs.seekg(0, std::ios::end);  
        size_t flen = ifs.tellg();  
        ifs.seekg(0, std::ios::beg);  
        body.resize(flen);  
        ifs.read(&body[0], flen);  
        if (!ifs.good()) {  
            LOG_ERROR("读取文件 {} 数据失败！", filename);  
            ifs.close();  
            return false;  
        }  
        ifs.close();  
        return true;  
    }  
  
    /// @brief 写入文件内容  
    /// @param filename 文件名  
    /// @param body 要写入文件的内容  
    /// @return 写入成功返回true，失败返回false  
    bool write_file(const std::string &filename, const std::string &body) {  
        std::ofstream ofs(filename, std::ios::out | std::ios::binary | std::ios::trunc);  
        if (!ofs.is_open()) {  
            LOG_ERROR("打开文件 {} 失败！", filename);  
            return false;  
        }  
        ofs.write(body.c_str(), body.size());  
        if (!ofs.good()) {  
            LOG_ERROR("写入文件 {} 数据失败！", filename);  
            ofs.close();  
            return false;  
        }  
        ofs.close();  
        return true;  
    }  
  
}

--- FILE: Common/etcd.hpp ---
内容:
#pragma once
#include <etcd/Client.hpp>
#include <etcd/Response.hpp>
#include <etcd/KeepAlive.hpp>  
#include <etcd/Value.hpp>  
#include <etcd/Watcher.hpp>

#include <thread>
#include <functional>

#include "./logger.hpp"


namespace chen_im {

// 服务注册客户端类，本质上是在放数据
class Registry
{
public:
    using ptr = std::shared_ptr<Registry>;
private:
    std::shared_ptr<etcd::Client> _client; // etcd的客户端对象
    std::shared_ptr<etcd::KeepAlive> _keep_alive; // 一个租约的保活对象
    int64_t _lease_id; // 保活对象的租约ID
public:
    Registry(const string &host_url)
        :_client(make_shared<etcd::Client>(host_url))
        ,_keep_alive(_client->leasekeepalive(3).get()) // 它的创建伴随着创建一个指定时长的租约（3s）
        ,_lease_id(_keep_alive->Lease())
    {}

    // 注册kv，返回bool值表示是否成功
    bool registry(const std::string &key, const std::string &val)
    {
        auto resp = _client->put(key, val, _lease_id).get();
        if(resp.is_ok() == false)
        {
            LOG_ERROR("向etcd注册键值对数据时失败，原因：{}", resp.error_message());
            return false;
        }
        return true;
    }

    ~Registry()
    {
        _keep_alive->Cancel(); // 取消租约
    }
};



// 服务发现客户端类，本质上是在获取数据
class Discovery
{
public:
    using ptr = std::shared_ptr<Discovery>;
    using NotifyCallback = std::function<void(const std::string &, const std::string &)>;
private:
    std::shared_ptr<etcd::Client> _client;
    std::shared_ptr<etcd::Watcher> _watcher;
    NotifyCallback _put_cb;
    NotifyCallback _del_cb;

private:
    // std::function<void(etcd::Response)> callback
    void callback(const etcd::Response &resp)
    {
        if(resp.is_ok() == false)
        {
            LOG_ERROR("收到一个错误的事件通知：{}", resp.error_message());
            return;
        }
        for(const auto& ev : resp.events())
        {
            if(ev.event_type() == etcd::Event::EventType::PUT) {
                if(_put_cb) _put_cb(ev.kv().key(), ev.kv().as_string());
                // LOG_DEBUG("新增业务节点：{} -> {}", ev.kv().key(), ev.kv().as_string());
            } else if(ev.event_type() == etcd::Event::EventType::DELETE_) {
                if(_del_cb) _del_cb(ev.prev_kv().key(), ev.prev_kv().as_string()); // 看的是被删除的kv，因此用prev_kv
                // LOG_DEBUG("业务节点下线：{} -> {}", ev.kv().key(), ev.kv().as_string());
            }
        }
    }

public:
    Discovery(const std::string &host_url, 
              const std::string &base_dir, 
              const NotifyCallback &put_cb, 
              const NotifyCallback &del_cb)
        :_client(std::make_shared<etcd::Client>(host_url))
        ,_watcher(std::make_shared<etcd::Watcher>(*_client, base_dir, 
                  std::bind(&Discovery::callback, this, std::placeholders::_1), true))
        ,_put_cb(put_cb)
        ,_del_cb(del_cb)
    {
        // 1. 先拉取服务（服务发现）
        auto resp = _client->ls("/service").get();
        if(resp.is_ok() == false)
        {
            LOG_ERROR("获取服务信息数据失败：{}", resp.error_message());
            abort();
        }

        // 2. 打印服务列表
        LOG_DEBUG("服务发现客户端被初始化，拉取当前服务列表：");
        size_t sz = resp.keys().size();
        for(int i = 0; i < sz; i++)
        {
            LOG_DEBUG(" {} 可以提供 {} 服务", resp.value(i).as_string(), resp.key(i));
            if(_put_cb) _put_cb(resp.key(i), resp.value(i).as_string());
        }
        LOG_DEBUG("服务列表打印完毕");
        
        // 3. 然后进行事件监控
        // _watcher->Wait();
    }

    ~Discovery() { }
};


}

--- FILE: Common/logger.hpp ---
内容:
#pragma once
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/basic_file_sink.h>
#include <spdlog/async.h>
#include <iostream>
#include <memory>
#include <string>
#include <string_view>

namespace chen_im {

// 全局的日志器
std::shared_ptr<spdlog::logger> g_default_logger;

/// @brief 初始化日志器
/// @param mode 运行模式：true-发布模式，false-调试模式
/// @param file_name 发布模式下，如果输出到文件，输出到的文件名
/// @param level 发布模式下的日志等级和刷新时机
void init_logger(bool mode, const std::string &file_name, int log_level)
{
    if(mode == false) {
        // 如果是调试模式，则创建标准输出的同步日志器，输出等级为最低
        // 1. 创建同步日志器
        g_default_logger = spdlog::stdout_color_mt("global_sync_logger", spdlog::color_mode::automatic);

        // 2. 设置等级(刷新阈值)
        g_default_logger->set_level(spdlog::level::level_enum::trace);

        // 3. 刷新时机
        g_default_logger->flush_on(spdlog::level::level_enum::trace);
    } else {
        // 如果是发布模式，则创建文件输出的异步日志器，输出等级依参数而定
        // 1. 创建异步日志器
        g_default_logger = spdlog::basic_logger_mt("global_async_logger", file_name, false);

        // 2. 设置等级(刷新阈值)
        g_default_logger->set_level(static_cast<spdlog::level::level_enum>(log_level));

        // 3. 刷新时机
        g_default_logger->flush_on(static_cast<spdlog::level::level_enum>(log_level));
    }

    // 4. 设置格式 [日志器名称][时间][线程ID][日志等级全称]
    g_default_logger->set_pattern("[%n][%H:%M:%S][%t][%^%-8l%$]%v");
}

// [文件名:行号]
#define LOG_TRACE(format, ...)    chen_im::g_default_logger->trace(   std::string("[{:>10s}:{:<4d}] ") + format , __FILE__, __LINE__, ##__VA_ARGS__)
#define LOG_DEBUG(format, ...)    chen_im::g_default_logger->debug(   std::string("[{:>10s}:{:<4d}] ") + format , __FILE__, __LINE__, ##__VA_ARGS__)
#define LOG_INFO(format, ...)     chen_im::g_default_logger->info(    std::string("[{:>10s}:{:<4d}] ") + format , __FILE__, __LINE__, ##__VA_ARGS__)
#define LOG_WARN(format, ...)     chen_im::g_default_logger->warn(    std::string("[{:>10s}:{:<4d}] ") + format , __FILE__, __LINE__, ##__VA_ARGS__)
#define LOG_ERROR(format, ...)    chen_im::g_default_logger->error(   std::string("[{:>10s}:{:<4d}] ") + format , __FILE__, __LINE__, ##__VA_ARGS__)
#define LOG_CRITICAL(format, ...) chen_im::g_default_logger->critical(std::string("[{:>10s}:{:<4d}] ") + format , __FILE__, __LINE__, ##__VA_ARGS__)


}

--- FILE: Common/elasticsearch_user.hpp ---
内容:
// ES数据管理：（二次封装一下elasticsearch_basic.hpp，做用户索引的CRUD，这份头文件更加贴近业务）
//     在用户注册成功的时候，将用户的元信息，向ES也进行一份存储，以便于进行用户的搜索
//     搜索关键字：是一个字符串，可能是一个用户ID,也可能是一个手机号，也可能是一个昵称的一部分
//                且搜索的时候，不能搜索到自己，以及自己的好友，过滤条件其实就是一组用户ID

//     ES存放的是用户元信息：用户ID，用户昵称，手机号，签名，头像ID

//     ES的管理操作:
//          1.创建用户索引
//          2.新增数据／更新数据
//          3.搜索用户 (输入一个关键字，以及一组过滤用户ID)
#pragma once
#include "elasticsearch_basic.hpp"
#include "user.hxx"
#include "message.hxx"
#include "message-odb.hxx"

namespace chen_im
{
    class ESClientFactory
    {
    public:
        static std::shared_ptr<elasticlient::Client> create(const std::vector<std::string> host_list)
        {
            return std::make_shared<elasticlient::Client>(host_list);
        }
    };

    // ES的管理操作:
    //  1.创建用户索引
    //  2.新增数据／更新数据
    //  3.搜索用户 (输入一个关键字，以及一组过滤用户ID)
    class ESUser
    {
    public:
        using ptr = std::shared_ptr<ESUser>;
        ESUser(const std::shared_ptr<elasticlient::Client> &client) 
            : _es_client(client) 
        {}
        bool create_index()
        {
            bool ret = ESIndex("user", "_doc", _es_client)
                        .append("user_id", "keyword", "standard", true)
                        .append("nickname")
                        .append("phone", "keyword", "standard", true)
                        .append("description", "text", "standard", false)
                        .append("avatar_id", "keyword", "standard", false)
                        .create_and_send();
            if (ret == false)
            {
                LOG_INFO("用户信息索引创建失败!");
                return false;
            }
            LOG_INFO("用户信息索引创建成功!");
            return true;
        }

        bool append_user(const std::string &uid,
                        const std::string &phone,
                        const std::string &nickname,
                        const std::string &description,
                        const std::string &avatar_id)
        {
            bool ret = ESInsert("user", "_doc", _es_client)
                           .append("user_id", uid)
                           .append("nickname", nickname)
                           .append("phone", phone)
                           .append("description", description)
                           .append("avatar_id", avatar_id)
                           .insert_and_send(uid);
            if (ret == false)
            {
                LOG_ERROR("用户数据插入/更新失败!");
                return false;
            }
            LOG_INFO("用户数据新增/更新成功!");
            return true;
        }

        /// @brief 通过关键词key，匹配用户ID或手机号或昵称关键字，找到一组用户
        /// @param key 
        /// @param uid_list 要排除的用户ID（自己、自己的好友）
        std::vector<User> search(const std::string &key, const std::vector<std::string> &uid_list)
        {
            std::vector<User> res;
            Json::Value json_user = ESSearch("user", "_doc", _es_client)
                                        .append_should_match("phone.keyword", key)
                                        .append_should_match("user_id.keyword", key)
                                        .append_should_match("nickname", key)
                                        .append_must_not_terms("user_id.keyword", uid_list)
                                        .search();
            if (json_user.isArray() == false)
            {
                LOG_ERROR("用户搜索结果为空，或者结果不是数组类型");
                return res;
            }
            int sz = json_user.size();
            LOG_DEBUG("检索结果条目数量：{}", sz);
            
            for (int i = 0; i < sz; i++)
            {
                User user;
                user.user_id(json_user[i]["_source"]["user_id"].asString());
                user.nickname(json_user[i]["_source"]["nickname"].asString());
                user.description(json_user[i]["_source"]["description"].asString());
                user.phone(json_user[i]["_source"]["phone"].asString());
                user.avatar_id(json_user[i]["_source"]["avatar_id"].asString());
                res.push_back(user);
            }
            return res;
        }

    private:
        // const std::string _uid_key = "user_id";
        // const std::string _desc_key = "user_id";
        // const std::string _phone_key = "user_id";
        // const std::string _name_key = "user_id";
        // const std::string _avatar_key = "user_id";
        std::shared_ptr<elasticlient::Client> _es_client;
    };

    class ESMessage
    {
    public:
        using ptr = std::shared_ptr<ESMessage>;
        ESMessage(const std::shared_ptr<elasticlient::Client> &es_client) : _es_client(es_client) {}
        bool create_index()
        {
            bool ret = ESIndex("message", "_doc", _es_client)
                           .append("user_id", "keyword", "standard", false)
                           .append("message_id", "keyword", "standard", false)
                           .append("create_time", "long", "standard", false)
                           .append("chat_session_id", "keyword", "standard", true)
                           .append("content")
                           .create_and_send();
            if (ret == false)
            {
                LOG_INFO("消息信息索引创建失败!");
                return false;
            }
            LOG_INFO("消息信息索引创建成功!");
            return true;
        }
        bool append_message(const std::string &user_id,
                        const std::string &message_id,
                        const long create_time,
                        const std::string &chat_session_id,
                        const std::string &content)
        {
            bool ret = ESInsert("message", "_doc", _es_client)
                           .append("message_id", message_id)
                           .append("create_time", std::to_string(create_time))
                           .append("user_id", user_id)
                           .append("chat_session_id", chat_session_id)
                           .append("content", content)
                           .insert_and_send(message_id);

            if (ret == false)
            {
                LOG_ERROR("消息数据插入/更新失败!");
                return false;
            }
            LOG_INFO("消息数据新增/更新成功!");
            return true;
        }
        bool remove(const std::string &mid)
        {
            bool ret = ESRemove("message", "_doc", _es_client).remove(mid);
            if (ret == false)
            {
                LOG_ERROR("消息数据删除失败!");
                return false;
            }
            LOG_INFO("消息数据删除成功!");
            return true;
        }
        std::vector<chen_im::Message> search(const std::string &key, const std::string &ssid)
        {
            std::vector<chen_im::Message> res;
            Json::Value json_user = ESSearch("message", "_doc", _es_client)
                                        .append_must_term("chat_session_id.keyword", ssid)
                                        .append_must_match("content", key)
                                        .search();
            if (json_user.isArray() == false)
            {
                LOG_ERROR("用户搜索结果为空，或者结果不是数组类型");
                return res;
            }
            int sz = json_user.size();
            LOG_DEBUG("检索结果条目数量：{}", sz);
            for (int i = 0; i < sz; i++)
            {
                chen_im::Message message;
                message.user_id(json_user[i]["_source"]["user_id"].asString());
                message.message_id(json_user[i]["_source"]["message_id"].asString());
                boost::posix_time::ptime ctime(boost::posix_time::from_time_t(
                    stoi(json_user[i]["_source"]["create_time"].asString())));
                message.create_time(ctime);
                message.session_id(json_user[i]["_source"]["chat_session_id"].asString());
                message.content(json_user[i]["_source"]["content"].asString());
                res.push_back(message);
            }
            return res;
        }

    private:
        std::shared_ptr<elasticlient::Client> _es_client;
    };
}

--- FILE: Common/mysql_relation.hpp ---
内容:
#pragma once
#include "logger.hpp"
#include "mysql_odb_factory.hpp"
#include "relation.hxx"
#include "relation-odb.hxx"

namespace chen_im
{
    class RelationTable
    {
    public:
        using ptr = std::shared_ptr<RelationTable>;
        RelationTable(const std::shared_ptr<odb::mysql::database> &db) : _db(db) {}
        // 新增关系信息
        bool insert(const std::string &uid, const std::string &pid)
        {
            //{1,2} {2,1}
            // 1的好友是2，2的好友是1
            try
            {
                Relation r1(uid, pid);
                Relation r2(pid, uid);
                odb::transaction trans(_db->begin());
                _db->persist(r1);
                _db->persist(r2);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("新增用户好友关系信息失败 {}-{}:{}！", uid, pid, e.what());
                return false;
            }
            return true;
        }
        // 移除关系信息
        bool remove(const std::string &uid, const std::string &pid)
        {
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<Relation> query;
                typedef odb::result<Relation> result;
                _db->erase_query<Relation>(query::user_id == uid && query::peer_id == pid);
                _db->erase_query<Relation>(query::user_id == pid && query::peer_id == uid);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除好友关系信息失败 {}-{}:{}！", uid, pid, e.what());
                return false;
            }
            return true;
        }
        // 判断关系是否存在
        bool exists(const std::string &uid, const std::string &pid)
        {
            typedef odb::query<Relation> query;
            typedef odb::result<Relation> result;
            result r;
            bool flag = false;
            try
            {
                odb::transaction trans(_db->begin());
                r = _db->query<Relation>(query::user_id == uid && query::peer_id == pid);
                flag = !r.empty();
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取用户好友关系失败:{}-{}-{}！", uid, pid, e.what());
            }
            return flag;
        }
        
        // 获取指定用户的所有好友ID
        std::vector<std::string> get_friends(const std::string &uid)
        {
            std::vector<std::string> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<Relation> query;
                typedef odb::result<Relation> result;
                result r(_db->query<Relation>(query::user_id == uid));
                for (result::iterator i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(i->peer_id());
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("通过用户-{}的所有好友ID失败:{}！", uid, e.what());
            }
            return res;
        }

    private:
        std::shared_ptr<odb::mysql::database> _db;
    };
}

--- FILE: Common/mysql_odb_factory.hpp ---
内容:
#pragma once
#include <string>
#include <memory>  // std::auto_ptr
#include <cstdlib> // std::exit
#include <iostream>

#include <odb/database.hxx>
#include <odb/mysql/database.hxx>
#include <gflags/gflags.h>

namespace chen_im
{
    class ODBFactory
    {
    public:
        static std::shared_ptr<odb::mysql::database> create(
            const std::string &user,
            const std::string &pswd,
            const std::string &db,
            const std::string &host,
            int port,
            const std::string &char_set,
            int max_connections)
        {
            // 1. 构造连接池工厂配置对象 
            std::unique_ptr<odb::mysql::connection_pool_factory> cpf(
                new odb::mysql::connection_pool_factory(
                    max_connections, 0
                )
            );
            
            // 2. 构造数据库操作对象
            auto res = std::make_shared<odb::mysql::database>(
                user, pswd, db, host, port, "", char_set, 0, std::move(cpf));
            
            return res;
        }
    };

}

--- FILE: Common/mysql_chat_session_member.hpp ---
内容:
#pragma once
#include "mysql_odb_factory.hpp"
#include "chat_session_member.hxx"
#include "chat_session_member-odb.hxx"

namespace chen_im
{
    class ChatSessionMemeberTable
    {
    public:
        using ptr = std::shared_ptr<ChatSessionMemeberTable>;
        ChatSessionMemeberTable(const std::shared_ptr<odb::mysql::database> &db) : _db(db) {}
        // 单个会话成员的新增 <chat_session_id, uid>
        bool append(ChatSessionMember &csm)
        {
            try
            {
                odb::transaction trans(_db->begin());
                _db->persist(csm);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("新增单会话成员失败 {}-{}:{}！",
                          csm.chat_session_id(), csm.user_id(), e.what());
                return false;
            }
            return true;
        }

        // 多个会话成员的新增
        bool append(std::vector<ChatSessionMember> &csm_lists)
        {
            try
            {
                odb::transaction trans(_db->begin());
                for (auto &csm : csm_lists)
                {
                    _db->persist(csm);
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("新增多会话成员失败 {}-{}:{}！",
                          csm_lists[0].chat_session_id(), csm_lists.size(), e.what());
                return false;
            }
            return true;
        }

        // 删除指定会话中的指定成员 <chat_session_id, uid>
        bool remove(ChatSessionMember &csm)
        {
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<ChatSessionMember> query;
                typedef odb::result<ChatSessionMember> result;
                _db->erase_query<ChatSessionMember>(query::chat_session_id == csm.chat_session_id() &&
                                                    query::user_id == csm.user_id());
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除单会话成员失败 {}-{}:{}！",
                          csm.chat_session_id(), csm.user_id(), e.what());
                return false;
            }
            return true;
        }
        
        // 删除会话的所有成员信息 
        bool remove(const std::string &ssid)
        {
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<ChatSessionMember> query;
                typedef odb::result<ChatSessionMember> result;
                _db->erase_query<ChatSessionMember>(query::chat_session_id == ssid);
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("删除会话所有成员失败 {}:{}！", ssid, e.what());
                return false;
            }
            return true;
        }


        /// @brief 获取MySQL中的聊天会话表中的某个会话id下的所有会话成员id
        /// @param ssid 要查找的聊天会话id
        /// @return 成员id的数组
        std::vector<std::string> get_members(const std::string &ssid)
        {
            std::vector<std::string> res;
            try
            {
                odb::transaction trans(_db->begin());
                typedef odb::query<ChatSessionMember> query;
                typedef odb::result<ChatSessionMember> result;
                result r(_db->query<ChatSessionMember>(query::chat_session_id == ssid));
                for (result::iterator i(r.begin()); i != r.end(); ++i)
                {
                    res.push_back(i->user_id());
                }
                trans.commit();
            }
            catch (std::exception &e)
            {
                LOG_ERROR("获取会话成员失败:{}-{}！", ssid, e.what());
            }
            return res;
        }

    private:
        std::shared_ptr<odb::mysql::database> _db;
    };
}

--- FILE: Common/dms.hpp ---
内容:
// 封装一个DMS客户端类：
//   1. 构造时候，传入访问密钥相关信息
//   2. 向外提供调用接口（手机号，验证码）---用于向平台发送请求
#pragma once
#include <cstdlib>
#include <iostream>
#include <memory>
#include <alibabacloud/core/AlibabaCloud.h>
#include <alibabacloud/core/CommonRequest.h>
#include <alibabacloud/core/CommonClient.h>
#include <alibabacloud/core/CommonResponse.h>

#include "logger.hpp"

namespace chen_im {

class DMSClient
{
private:
    std::unique_ptr<AlibabaCloud::CommonClient> _client;
    const std::string _access_key_id;     // 阿里云的密钥
    const std::string _access_key_secret; // 阿里云的密钥
public:
    DMSClient(const std::string &AccessKeyID, const std::string &AccessKeySecret) 
    {
        AlibabaCloud::InitializeSdk();
        AlibabaCloud::ClientConfiguration configuration("cn-shanghai");
        // specify timeout when create client.
        configuration.setConnectTimeout(1500);
        configuration.setReadTimeout(4000);

        AlibabaCloud::Credentials credential(AccessKeyID, AccessKeySecret);

        _client = std::make_unique<AlibabaCloud::CommonClient>(credential, configuration);
    }

    // 向指定手机号发送验证码
    bool send(const std::string &phone, const std::string &code)
    {
        AlibabaCloud::CommonRequest request(AlibabaCloud::CommonRequest::RequestPattern::RpcPattern);
        request.setHttpMethod(AlibabaCloud::HttpRequest::Method::Post);
        request.setDomain("dysmsapi.aliyuncs.com");
        request.setVersion("2017-05-25");
        request.setQueryParameter("Action", "SendSms");
        request.setQueryParameter("SignName", "微服务项目");
        request.setQueryParameter("TemplateCode", "SMS_472720179");
        request.setQueryParameter("PhoneNumbers", phone);
        request.setQueryParameter("TemplateParam", "{\"code\":\"" + code + "\"}");

        auto response = _client->commonResponse(request);
        if (response.isSuccess())
        {
            LOG_DEBUG("短信验证码发送成功！");
            LOG_DEBUG("返回结果: {}", response.result().payload().c_str());
            return true;
        }
        else
        {
            LOG_ERROR("短信验证码发送失败: {}", response.error().errorMessage().c_str());
            LOG_ERROR("request id: {}", response.error().requestId().c_str());
            return false;
        }
    }

    ~DMSClient() 
    {
        AlibabaCloud::ShutdownSdk();
    }
};

}

--- FILE: Common/mysql_user.hpp ---
内容:
// 对用户表的增删查改
#pragma once
#include <string>
#include <memory>  // std::auto_ptr
#include <cstdlib> // std::exit
#include <iostream>

#include <odb/database.hxx>
#include <odb/mysql/database.hxx>
#include <gflags/gflags.h>

#include "mysql_odb_factory.hpp"
#include "user-odb.hxx"
#include "logger.hpp"

// 用户注册
// 用户登录
// 手机号注册
// 手机号登录
// 获取用户信息：
//    通过昵称获取用户信息
//    通过手机号获取用户信息
//    通过用户ID获取用户信息
//    通过多个用户ID获取多个用户信息

// 修改用户信息：
//    设置头像
//    设置昵称
//    设置签名
//    设置绑定手机号

namespace chen_im {

class UserTable
{
private:
    std::shared_ptr<odb::mysql::database> _db; // odb的客户端，内有连接池，用来发起事务
public:
    UserTable(const std::shared_ptr<odb::mysql::database> &db)
        :_db(db)
    {}
    ~UserTable() {}

    // 向mysql中新增用户
    bool insert(const std::shared_ptr<User> &user)
    {
        try {        
            odb::mysql::transaction t(_db->begin());
            _db->persist(*user);
            t.commit();
        } catch(const std::exception &e) {
            LOG_ERROR("向mysql新增用户数据失败！原因：{}", e.what());
            return false;
        }
        return true;
    }

    /// @brief 向mysql中更新用户数据
    /// @param user 需要先查询出user对象，再传入它的智能指针
    bool update(const std::shared_ptr<User> &user)
    {
        try {        
            odb::mysql::transaction t(_db->begin());
            _db->update(*user);
            t.commit();
        } catch(const std::exception &e) {
            LOG_ERROR("向mysql更新用户数据失败！原因：{}", e.what());
            return false;
        }
        return true;
    }

    // 根据昵称查询用户信息
    std::shared_ptr<User> select_by_nickname(const std::string &nickname)
    {
        std::shared_ptr<User> ret;
        try {        
            odb::mysql::transaction t(_db->begin());
            typedef odb::query<User> query;
            typedef odb::result<User> result;

            // 查询
            ret.reset(_db->query_one<User>(query::nickname == nickname));

            t.commit();
        } catch(const std::exception &e) {
            LOG_ERROR("根据昵称查询mysql用户数据失败！原因：{}", e.what());
        }

        return ret;
    }

    // 根据手机号查询用户信息
    std::shared_ptr<User> select_by_phone(const std::string &phone)
    {
        std::shared_ptr<User> ret;
        try {        
            odb::mysql::transaction t(_db->begin());
            typedef odb::query<User> query;
            typedef odb::result<User> result;

            // 查询
            ret.reset(_db->query_one<User>(query::phone == phone));

            t.commit();
        } catch(const std::exception &e) {
            LOG_ERROR("根据手机号查询mysql用户数据失败！原因：{}", e.what());
        }

        return ret;
    }

    // 根据用户id查询用户信息
    std::shared_ptr<User> select_by_uid(const std::string &uid)
    {
        std::shared_ptr<User> ret;
        try {        
            odb::mysql::transaction t(_db->begin());
            typedef odb::query<User> query;
            typedef odb::result<User> result;

            // 查询
            ret.reset(_db->query_one<User>(query::user_id == uid));

            t.commit();
        } catch(const std::exception &e) {
            LOG_ERROR("根据用户ID查询mysql用户数据失败！原因：{}", e.what());
        }

        return ret;
    }

    // 根据一组用户id查询一组用户
    std::vector<User> select_by_multi_uid(std::vector<std::string> &uid_array)
    {
        if (uid_array.empty()) {
            return {};
        }
        std::vector<User> ret;
        try {        
            odb::mysql::transaction t(_db->begin());
            typedef odb::query<User> query;
            typedef odb::result<User> result;

            // 使用范围查询，并传入起始和结束迭代器
            query q;
            q = query::user_id.in_range(uid_array.begin(), uid_array.end());

            // 查询
            result query_result(_db->query<User>(q));

            for (result::iterator i = query_result.begin(); i != query_result.end(); i++) {
                ret.push_back(*i);
            }

            t.commit();
        } catch(const std::exception &e) {
            LOG_ERROR("根据批量用户ID查询批量用户数据失败！原因：{}", e.what());
        }

        return ret;
    }

};

}

--- FILE: APIs/notify.proto ---
内容:
// 此文件只定义服务器通过websocket向客户端发送的通知消息
syntax = "proto3";
package chen_im;
import "base.proto";

option cc_generic_services = true;

enum NotifyType {
    FRIEND_ADD_APPLY_NOTIFY = 0;
    FRIEND_ADD_PROCESS_NOTIFY = 1;
    CHAT_SESSION_CREATE_NOTIFY = 2;
    CHAT_MESSAGE_NOTIFY = 3;
    FRIEND_REMOVE_NOTIFY = 4;
}

message NotifyFriendAddApply {
    UserInfo user_info = 1;  //申请人信息
}
message NotifyFriendAddProcess { 
    bool agree = 1;// 告诉申请人这次好友申请是否被对方同意
    UserInfo user_info = 2;  //处理人信息
}
message NotifyFriendRemove {
    string user_id = 1; //删除自己的用户ID
}
message NotifyNewChatSession {
    ChatSessionInfo chat_session_info = 1; //新建会话信息
}
message NotifyNewMessage {
    MessageInfo message_info = 1; //新消息
}


message NotifyMessage {
    string notify_event_id = 1;//通知事件操作id（有则填无则忽略）
    NotifyType notify_type = 2;//通知事件类型
    oneof notify_remarks {      //事件备注信息
        NotifyFriendAddApply friend_add_apply = 3;
        NotifyFriendAddProcess friend_process_result = 4;
        NotifyFriendRemove friend_remove = 7;
        NotifyNewChatSession new_chat_session_info = 5;//会话信息
        NotifyNewMessage new_message_info = 6;//消息信息
    }
}

--- FILE: APIs/friend.proto ---
内容:
/*
    好友操作服务器的子服务注册信息： /service/friend/instance_id
        服务名称：/service/friend
        实例ID: instance_id     每个能够提供用户操作服务的子服务器唯一ID
    当服务发现的时候，通过 /service/friend 进行服务发现，就可以发现所有的能够提供用户操作的实例信息了
*/
syntax = "proto3";
package chen_im;
import "base.proto";

option cc_generic_services = true;


//--------------------------------------
//好友列表获取
message GetFriendListReq {
    string request_id = 1;
     string user_id = 2;
     string session_id = 3;
}
message GetFriendListRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated UserInfo friend_list = 4;
}

//--------------------------------------
//好友删除
message FriendRemoveReq {
    string request_id = 1;
     string user_id = 2;
     string session_id = 3;
    string peer_id = 4;
}
message FriendRemoveRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
}
//--------------------------------------
//添加好友--发送好友申请
message FriendAddReq {
    string request_id = 1;
     string session_id = 2;
     string user_id = 3;      //申请人id
    string respondent_id = 4; //被申请人id
}
message FriendAddRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    string notify_event_id = 4;//通知事件id
}
//--------------------------------------
//好友申请的处理
message FriendAddProcessReq {
    string request_id = 1;
    string notify_event_id = 2; //通知事件id
    bool agree = 3;             //是否同意好友申请
    string apply_user_id = 4;   //申请人的用户id
     string session_id = 5;
     string user_id = 6;
}
//   +++++++++++++++++++++++++++++++++
message FriendAddProcessRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
     string new_session_id = 4; // 同意后会创建会话，向网关返回新创建的会话信息，用于通知双方会话的建立，这个字段客户端不需要关注
}
//--------------------------------------
//获取待处理的，申请自己好友的信息列表
message GetPendingFriendEventListReq {
    string request_id = 1;
     string session_id = 2;
     string user_id = 3;
}

message FriendEvent {
    string event_id = 1;
    UserInfo sender = 3;
}
message GetPendingFriendEventListRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated FriendEvent event = 4;
}

//--------------------------------------
//好友搜索
message FriendSearchReq {
    string request_id = 1;
    string search_key = 2;//就是名称模糊匹配关键字
     string session_id = 3;
     string user_id = 4;
}
message FriendSearchRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated UserInfo user_info = 4;
}

//--------------------------------------
//会话列表获取
message GetChatSessionListReq {
    string request_id = 1;
     string session_id = 2;
     string user_id = 3;
}
message GetChatSessionListRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated ChatSessionInfo chat_session_info_list = 4;
}
//--------------------------------------
//创建会话
message ChatSessionCreateReq {
    string request_id = 1;
     string session_id = 2;
     string user_id = 3;
    string chat_session_name = 4;
    //需要注意的是，这个列表中也必须包含创建者自己的用户ID
    repeated string member_id_list = 5;
}
message ChatSessionCreateRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    //这个字段属于后台之间的数据，给前端回复的时候不需要这个字段，会话信息通过通知进行发送
     ChatSessionInfo chat_session_info = 4; 
}
//--------------------------------------
//获取会话成员列表
message GetChatSessionMemberReq {
    string request_id = 1;
     string session_id = 2;
     string user_id = 3;
    string chat_session_id = 4;
}
message GetChatSessionMemberRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated UserInfo member_info_list = 4;
}

service FriendService {
    rpc GetFriendList(GetFriendListReq) returns (GetFriendListRsp);                                     // http GET "/service/friend/get_friend_list"
    rpc FriendRemove(FriendRemoveReq) returns (FriendRemoveRsp);                                        // http GET "/service/friend/remove_friend"
    rpc FriendAdd(FriendAddReq) returns (FriendAddRsp);                                                 // http GET "/service/friend/add_friend_apply"
    rpc FriendAddProcess(FriendAddProcessReq) returns (FriendAddProcessRsp);                            // http GET "/service/friend/add_friend_process"
    rpc FriendSearch(FriendSearchReq) returns (FriendSearchRsp);                                        // http GET "/service/friend/search_friend"
    rpc GetChatSessionList(GetChatSessionListReq) returns (GetChatSessionListRsp);                      // http GET "/service/friend/get_chat_session_list"
    rpc ChatSessionCreate(ChatSessionCreateReq) returns (ChatSessionCreateRsp);                         // http GET "/service/friend/create_chat_session"
    rpc GetChatSessionMember(GetChatSessionMemberReq) returns (GetChatSessionMemberRsp);                // http GET "/service/friend/get_chat_session_member"
    rpc GetPendingFriendEventList(GetPendingFriendEventListReq) returns (GetPendingFriendEventListRsp); // http GET "/service/friend/get_pending_friend_events"
}

--- FILE: APIs/message_storage.proto ---
内容:
/*
    消息存储服务器的子服务注册信息： /service/message_storage/instance_id
        服务名称：/service/message_storage
        实例ID: instance_id     每个能够提供用户操作服务的子服务器唯一ID
    当服务发现的时候，通过 /service/message_storage 进行服务发现，就可以发现所有的能够提供用户操作的实例信息了
*/
syntax = "proto3";
package chen_im;
import "base.proto";

option cc_generic_services = true;

message GetHistoryMsgReq {
    string request_id = 1;
    string chat_session_id = 2;
    int64 start_time = 3;
    int64 over_time = 4;
     string user_id = 5;
     string session_id = 6;
}
message GetHistoryMsgRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated MessageInfo msg_list = 4;
}

message GetRecentMsgReq {
    string request_id = 1;
    string chat_session_id = 2;
    int64 msg_count = 3;
     int64 cur_time = 4;//用于扩展获取指定时间前的n条消息
     string user_id = 5;
     string session_id = 6;
}
message GetRecentMsgRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated MessageInfo msg_list = 4;
}

message MsgSearchReq {
    string request_id = 1;
     string user_id = 2;
     string session_id = 3;
    string chat_session_id = 4;
    string search_key = 5;
}
message MsgSearchRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated MessageInfo msg_list = 4;
}

service MsgStorageService {
    rpc GetHistoryMsg(GetHistoryMsgReq) returns (GetHistoryMsgRsp); // http GET "/service/message_storage/get_history"
    rpc GetRecentMsg(GetRecentMsgReq) returns (GetRecentMsgRsp);    // http GET "/service/message_storage/get_recent"
    rpc MsgSearch(MsgSearchReq) returns (MsgSearchRsp);             // http GET "/service/message_storage/search_history"
}

--- FILE: APIs/speech_recognition.proto ---
内容:
/*
    语音识别服务器的子服务注册信息： /service/speech/instance_id
        服务名称：/service/speech
        实例ID: instance_id     每个能够提供用户操作服务的子服务器唯一ID
    当服务发现的时候，通过 /service/speech 进行服务发现，就可以发现所有的能够提供用户操作的实例信息了
*/
syntax = "proto3";
package chen_im;

option cc_generic_services = true;

message SpeechRecognitionReq {
    string request_id = 1;
    bytes speech_content = 2;
    string user_id = 3;
    string session_id = 4;
}

message SpeechRecognitionRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    string recognition_result = 4;
}

service SpeechService {
    rpc SpeechRecognition(SpeechRecognitionReq) returns (SpeechRecognitionRsp); // http GET "/service/speech/recognition"
}

--- FILE: APIs/Makefile ---
内容:
# 定义变量
PROTOC = protoc
PROTO_DIR = ./
BUILD_DIR = api_builds
PROTO_FILES := $(wildcard $(PROTO_DIR)/*.proto)
CPP_FILES := $(PROTO_FILES:$(PROTO_DIR)/%.proto=$(BUILD_DIR)/%.pb.cc)
H_FILES := $(PROTO_FILES:$(PROTO_DIR)/%.proto=$(BUILD_DIR)/%.pb.h)

# 创建api_builds目录
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# 规则：编译所有proto文件
all: $(CPP_FILES) $(H_FILES)

# 规则：生成.pb.cc和.pb.h文件，并处理依赖关系
$(BUILD_DIR)/%.pb.cc: $(PROTO_DIR)/%.proto | $(BUILD_DIR)
	$(PROTOC) --cpp_out=$(BUILD_DIR) $<

$(BUILD_DIR)/%.pb.h: $(BUILD_DIR)/%.pb.cc

# 清理生成的文件
clean:
	rm -rf $(BUILD_DIR)


--- FILE: APIs/file.proto ---
内容:
/*
    文件操作服务器的子服务注册信息： /service/file/instance_id
        服务名称：/service/file
        实例ID: instance_id     每个能够提供用户操作服务的子服务器唯一ID
    当服务发现的时候，通过 /service/file 进行服务发现，就可以发现所有的能够提供用户操作的实例信息了
*/
syntax = "proto3";
package chen_im;
import "base.proto";

option cc_generic_services = true;


message GetSingleFileReq {
    string request_id = 1;
    string file_id = 2;
     string user_id = 3;
     string session_id = 4;
}
message GetSingleFileRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    FileDownloadData file_data = 4;
}

message GetMultiFileReq {
    string request_id = 1;
     string user_id = 2;
     string session_id = 3;
    repeated string file_id_list = 4;
}
message GetMultiFileRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    map<string, FileDownloadData> file_data = 4;//文件ID与文件数据的映射的map
}

message PutSingleFileReq {
    string request_id = 1;
     string user_id = 2;
     string session_id = 3;
    FileUploadData file_data = 4;
}

message PutSingleFileRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3;
    FileMessageInfo file_info = 4;
}

message PutMultiFileReq {
    string request_id = 1;
     string user_id = 2;
     string session_id = 3;
    repeated FileUploadData file_data = 4;
}
message PutMultiFileRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    repeated FileMessageInfo file_info = 4;
}

service FileService {
    rpc GetSingleFile(GetSingleFileReq) returns (GetSingleFileRsp); // "/service/file/get_single_file"
    rpc GetMultiFile(GetMultiFileReq) returns (GetMultiFileRsp);    // "/service/file/get_multi_file"
    rpc PutSingleFile(PutSingleFileReq) returns (PutSingleFileRsp); // "/service/file/put_single_file"
    rpc PutMultiFile(PutMultiFileReq) returns (PutMultiFileRsp);    // "/service/file/put_multi_file"
}


--- FILE: APIs/base.proto ---
内容:
syntax = "proto3";
package chen_im;
option cc_generic_services = true;

//用户信息结构
message UserInfo {
    string user_id = 1;//用户ID
    string nickname = 2;//昵称
    string description = 3;//个人签名/描述
    string phone = 4; //绑定手机号
    bytes  avatar = 5;//头像照片，文件内容使用二进制
}

//聊天会话信息
message ChatSessionInfo {
    //群聊会话不需要设置，单聊会话设置为对方用户ID
    string single_chat_friend_id = 1;
    string chat_session_id = 2; //会话ID
    string chat_session_name = 3;//会话名称 
    //会话上一条消息，新建的会话没有最新消息
    MessageInfo prev_message = 4;
    //会话头像 --群聊会话不需要，直接由前端固定渲染，单聊就是对方的头像
    bytes avatar = 5;
}

//消息类型
enum MessageType {
    STRING = 0;
    IMAGE = 1;
    FILE = 2;
    SPEECH = 3;
}
message StringMessageInfo {
    string content = 1;//文字聊天内容
}
message ImageMessageInfo {
    //图片文件id,客户端发送的时候不用设置，由transmit服务器进行设置后交给storage的时候设置
    string file_id = 1;
    //图片数据，在ES中存储消息的时候只要id不要文件数据, 服务端转发的时候需要原样转发
    bytes image_content = 2;
}
message FileMessageInfo {
    string file_id = 1;       //文件id,客户端发送的时候不用设置
    int64 file_size = 2;      //文件大小
    string file_name = 3;     //文件名称
    bytes file_contents = 4;  //文件数据，在ES中存储消息的时候只要存id、size、name，不要文件content, 子服务之间转发的时候也不需要填充

}
message SpeechMessageInfo {
    //语音文件id,客户端发送的时候不用设置
    string file_id = 1;
    //文件数据，在ES中存储消息的时候只要id不要文件数据, 服务端转发的时候也不需要填充
    bytes file_contents = 2;
}
message MessageContent {
    MessageType message_type = 1; //消息类型
    oneof msg_content {
        StringMessageInfo string_message = 2;//文字消息
        FileMessageInfo file_message = 3;//文件消息
        SpeechMessageInfo speech_message = 4;//语音消息
        ImageMessageInfo image_message = 5;//图片消息
    };
}
//消息结构
message MessageInfo {
    string message_id = 1;//消息ID
    string chat_session_id = 2;//消息所属聊天会话ID
    int64 timestamp = 3;//消息产生时间
    UserInfo sender = 4;//消息发送者信息
    MessageContent message = 5;
}

message FileDownloadData {
    string file_id = 1;
    bytes file_content = 2;
}

message FileUploadData {
    string file_name = 1;   //文件名称
    int64 file_size = 2;    //文件大小
    bytes file_content = 3; //文件数据
}

--- FILE: APIs/user.proto ---
内容:
syntax = "proto3";
package chen_im;
import "base.proto";
option cc_generic_services = true;

//----------------------------
//用户名注册   
message UserRegisterReq {
    string request_id = 1;
    string nickname = 2;
    string password = 3;
    string verify_code_id = 4; //目前客户端实现了本地验证，该字段没用了
    string verify_code = 5;//目前客户端实现了本地验证，该字段没用了
}
message UserRegisterRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3;
}
//----------------------------
//用户名登录 
message UserLoginReq {
    string request_id = 1;
    string nickname = 2;
    string password = 3;
    string verify_code_id = 4;
    string verify_code = 5;
}
message UserLoginRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3;
    string login_session_id = 4;
}
//----------------------------
//手机号验证码获取
message PhoneVerifyCodeReq {
    string request_id = 1;
    string phone_number = 2;
}
message PhoneVerifyCodeRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3;
    string verify_code_id = 4;
}
//----------------------------
//手机号注册
message PhoneRegisterReq {
    string request_id = 1;
    string phone_number = 2;
    string verify_code_id = 3;
    string verify_code = 4;
}
message PhoneRegisterRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3;
}
//----------------------------
//手机号登录
message PhoneLoginReq {
    string request_id = 1;
    string phone_number = 2;
    string verify_code_id = 3;
    string verify_code = 4;
}
message PhoneLoginRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    string login_session_id = 4;
}
//个人信息获取-这个只用于获取当前登录用户的信息
//  客户端传递的时候只需要填充session_id即可
//其他个人/好友信息的获取在好友操作中完成
message GetUserInfoReq {
    string request_id = 1;
    string user_id = 2;    // 这个字段是网关进行身份鉴权之后填入的字段
    string session_id = 3; // 进行客户端身份识别的关键字段
}
message GetUserInfoRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    UserInfo user_info = 4;
}
//内部接口
message GetMultiUserInfoReq {
    string request_id = 1;
    repeated string users_id = 2;
}
message GetMultiUserInfoRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    map<string, UserInfo> users_info = 4;
}
//----------------------------
//用户头像修改 
message SetUserAvatarReq {
    string request_id = 1;
    string user_id = 2;
    string session_id = 3;
    bytes avatar = 4;
}
message SetUserAvatarRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
}
//----------------------------
//用户昵称修改 
message SetUserNicknameReq {
    string request_id = 1;
    string user_id = 2;
    string session_id = 3;
    string nickname = 4;
}
message SetUserNicknameRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
}
//----------------------------
//用户签名修改 
message SetUserDescriptionReq {
    string request_id = 1;
    string user_id = 2;
    string session_id = 3;
    string description = 4;
}
message SetUserDescriptionRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
}
//----------------------------
//用户手机修改 
message SetUserPhoneNumberReq {
    string request_id = 1;
    string user_id = 2;
    string session_id = 3;
    string phone_number = 4;
    string phone_verify_code_id = 5;
    string phone_verify_code = 6;
}
message SetUserPhoneNumberRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
}

service UserService {
    rpc UserRegister(UserRegisterReq) returns (UserRegisterRsp);                   // http GET "/service/user/username_register"
    rpc UserLogin(UserLoginReq) returns (UserLoginRsp);                            // http GET "/service/user/username_login"
    rpc GetPhoneVerifyCode(PhoneVerifyCodeReq) returns (PhoneVerifyCodeRsp);       // http GET "/service/user/get_phone_verify_code"
    rpc PhoneRegister(PhoneRegisterReq) returns (PhoneRegisterRsp);                // http GET "/service/user/phone_register"
    rpc PhoneLogin(PhoneLoginReq) returns (PhoneLoginRsp);                         // http GET "/service/user/phone_login"
    rpc GetUserInfo(GetUserInfoReq) returns (GetUserInfoRsp);                      // http GET "/service/user/get_user_info"
    rpc GetMultiUserInfo(GetMultiUserInfoReq) returns (GetMultiUserInfoRsp);       // 内部接口  
    rpc SetUserAvatar(SetUserAvatarReq) returns (SetUserAvatarRsp);                // http GET "/service/user/set_avatar"
    rpc SetUserNickname(SetUserNicknameReq) returns (SetUserNicknameRsp);          // http GET "/service/user/set_nickname"
    rpc SetUserDescription(SetUserDescriptionReq) returns (SetUserDescriptionRsp); // http GET "/service/user/set_description"
    rpc SetUserPhoneNumber(SetUserPhoneNumberReq) returns (SetUserPhoneNumberRsp); // http GET "/service/user/set_phone"
}

--- FILE: APIs/message_transmit.proto ---
内容:
/*
    消息转发服务器的子服务注册信息： /service/message_transmit/instance_id
        服务名称：/service/message_transmit
        实例ID: instance_id     每个能够提供用户操作服务的子服务器唯一ID
    当服务发现的时候，通过 /service/message_transmit 进行服务发现，就可以发现所有的能够提供用户操作的实例信息了
*/
//消息转发服务器接口
syntax = "proto3";
package chen_im;
import "base.proto";

option cc_generic_services = true;

// 这个是由客户端发给网关，然后网关再原封不动发给消息转发子服务的结构体
message NewMessageReq {
    string request_id = 1;
    string user_id = 2;
    string session_id = 3;
    string chat_session_id = 4;
    MessageContent message = 5;
}
message NewMessageRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
}

// 这个用于内部的通信（消息转发子服务告知网关 这个消息应该发给谁）
message GetTransmitTargetRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3; 
    MessageInfo message = 4;
    repeated string target_id_list = 5;
}

service MsgTransmitService {
    rpc GetTransmitTarget(NewMessageReq) returns (GetTransmitTargetRsp); // 内部接口
}

--- FILE: APIs/gateway.proto ---
内容:
syntax = "proto3";
package chen_im;
option cc_generic_services = true;
/*
    消息推送使用websocket长连接进行
    websocket长连接转换请求：ws://host:ip/ws
    长连建立以后，需要客户端给服务器发送一个身份验证信息，且仅会在连接建立成功的时候发一次
    也就是说下面的两个message，一个客户端的登录过程中只会用到一次
*/
message ClientAuthenticationReq {
    string request_id = 1;
    string session_id = 2;
}
message ClientAuthenticationRsp {
    string request_id = 1;
    bool success = 2;
    string errmsg = 3;
}

//通信接口统一采用POST请求实现,正文采用protobuf协议进行组织
/*  
    HTTP HEADER：
    POST /service/xxxxx
    Content-Type: application/x-protobuf
    Content-Length: 123

    xxxxxx

    -------------------------------------------------------

    HTTP/1.1 200 OK 
    Content-Type: application/x-protobuf
    Content-Length: 123

    xxxxxxxxxx
*/


//在客户端与网关服务器的通信中，使用HTTP协议进行通信
//  通信时采用POST请求作为请求方法
//  通信时，正文采用protobuf作为正文协议格式，具体内容字段以前边各个文件中定义的字段格式为准
/*  以下是HTTP请求的功能与接口路径对应关系：
    SERVICE HTTP PATH:
    {
        获取随机验证码                  /service/user/get_random_verify_code
        获取短信验证码                  /service/user/get_phone_verify_code
        用户名密码注册                  /service/user/username_register
        用户名密码登录                  /service/user/username_login
        手机号码注册                    /service/user/phone_register
        手机号码登录                    /service/user/phone_login
        获取个人信息                    /service/user/get_user_info
        修改头像                        /service/user/set_avatar
        修改昵称                        /service/user/set_nickname
        修改签名                        /service/user/set_description
        修改绑定手机                    /service/user/set_phone

        获取好友列表                    /service/friend/get_friend_list
        获取好友信息                    /service/friend/get_friend_info
        发送好友申请                    /service/friend/add_friend_apply
        好友申请处理                    /service/friend/add_friend_process
        删除好友                        /service/friend/remove_friend
        搜索用户                        /service/friend/search_friend
        获取指定用户的消息会话列表       /service/friend/get_chat_session_list
        创建消息会话                    /service/friend/create_chat_session
        获取消息会话成员列表             /service/friend/get_chat_session_member
        获取待处理好友申请事件列表       /service/friend/get_pending_friend_events

        获取历史消息/离线消息列表        /service/message_storage/get_history
        获取最近N条消息列表             /service/message_storage/get_recent
        搜索历史消息                    /service/message_storage/search_history
        
        发送消息                        /service/message_transmit/new_message

        获取单个文件数据                /service/file/get_single_file
        获取多个文件数据                /service/file/get_multi_file
        发送单个文件                    /service/file/put_single_file
        发送多个文件                    /service/file/put_multi_file

        语音转文字                     /service/speech/recognition
    }
    
*/


--- FILE: 3.User_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 1. 添加cmake版本说明
cmake_minimum_required(VERSION 3.1.3)

# 设置C++标准为17
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 2. 声明工程名称
project(user_server)

set(target "user_server")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# 3. 检测并生成Protobuf框架代码
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files base.proto user.proto file.proto)

set(proto_srcs "")
foreach(proto_file ${proto_files})
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file})
    string(REPLACE ".proto" ".pb.h" proto_hh ${proto_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc
            ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成Protobuf框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 3. 检测并生成ODB框架代码
set(odb_path ${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
set(odb_files user.hxx)

set(odb_srcs "")
foreach(odb_file ${odb_files})
    string(REPLACE ".hxx" "-odb.hxx" odb_hxx ${odb_file})
    string(REPLACE ".hxx" "-odb.cxx" odb_cxx ${odb_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${odb_cxx})
        add_custom_command(
            PRE_BUILD
            COMMAND odb
            ARGS -d mysql --std c++17 --generate-query --generate-schema --profile boost/date-time ${odb_path}/${odb_file}
            DEPENDS ${odb_path}/${odb_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
            COMMENT "生成ODB框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
        )
    endif()
    list(APPEND odb_srcs ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)

# 5. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs} ${odb_srcs})

# 6. 设置需要连接的库
target_link_libraries(${target}
    gflags
    pthread
    spdlog
    brpc
    ssl
    crypto
    protobuf
    leveldb
    etcd-cpp-api
    cpprest
    curl
    odb-mysql
    odb
    odb-boost
    /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
    alibabacloud-sdk-core
    cpr
    elasticlient
    hiredis
    redis++
    gtest
    dl  # 将 libdl 放在最后
)


# 新增三个可执行文件：es_test、mysql_test、redis_test
add_executable(es_test ${CMAKE_CURRENT_SOURCE_DIR}/test/es_test/main.cc)
target_link_libraries(es_test -lgflags -ljsoncpp -lspdlog -lelasticlient /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19 -ldl)

add_executable(mysql_test
    ${CMAKE_CURRENT_SOURCE_DIR}/test/mysql_test/main.cc
    ../ODB/odb_builds/user-odb.cxx  # Include this generated file
)
target_link_libraries(mysql_test -lodb-mysql -lodb -lodb-boost -pthread -lgtest -lgflags -lspdlog -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl -ldl)


# 用户客户端
set(test_client "user_client")
add_executable(${test_client} ${CMAKE_CURRENT_SOURCE_DIR}/test/user_client.cc ${proto_srcs})
target_link_libraries(${test_client} -pthread -lgtest -lgflags -lspdlog -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19 -ldl)

# 设置头文件默认搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB/odb_builds)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
include_directories(${CMAKE_CURRENT_SOURCEDIR}/../../Third-party)

# 8. 设置安装路径
INSTALL(TARGETS ${target} ${test_client} es_test mysql_test RUNTIME DESTINATION bin)


# # 1. 添加cmake版本说明
# cmake_minimum_required(VERSION 3.1.3)
# # 2. 声明工程名称
# project(user_server)

# set(target "user_server")

# set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# # 3. 生成Protobuf框架代码
# set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
# set(proto_files base.proto user.proto file.proto)
# set(proto_srcs "")

# foreach(proto_file ${proto_files})
#     string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file})
#     string(REPLACE ".proto" ".pb.h" proto_hh  ${proto_file})
    
#     add_custom_command(
#         OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc} ${CMAKE_CURRENT_BINARY_DIR}/${proto_hh}
#         COMMAND protoc
#         ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
#         DEPENDS ${proto_path}/${proto_file}
#         COMMENT "生成Protobuf框架代码文件: ${proto_cc}"
#     )
    
#     list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
# endforeach()

# # 4. 生成ODB框架代码
# set(odb_path ${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
# set(odb_files user.hxx)
# set(odb_srcs "")

# foreach(odb_file ${odb_files})
#     string(REPLACE ".hxx" "-odb.hxx" odb_hxx ${odb_file})
#     string(REPLACE ".hxx" "-odb.cxx" odb_cxx ${odb_file})
    
#     add_custom_command(
#         OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
#         COMMAND odb
#         ARGS -d mysql --std c++11 --generate-query --generate-schema --profile boost/date-time ${odb_path}/${odb_file}
#         DEPENDS ${odb_path}/${odb_file}
#         COMMENT "生成ODB框架代码文件: ${odb_cxx}"
#     )
    
#     list(APPEND odb_srcs ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
# endforeach()

# # 5. 获取源码目录下的所有源码文件
# set(src_files "")
# aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)

# # 6. 声明目标及依赖
# add_executable(${target} ${src_files} ${proto_srcs} ${odb_srcs})

# # 7. 设置需要连接的库
# target_link_libraries(${target} -lgflags -lspdlog -lfmt -lbrpc -lssl -lcrypto 
#     -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl -lodb-mysql -lodb -lodb-boost
#     /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19 -lalibabacloud-sdk-core -lcpr 
#     -lelasticlient -lhiredis -lredis++
# )

# # 8. 设置头文件默认搜索路径
# include_directories(${CMAKE_CURRENT_BINARY_DIR})
# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB/odb_builds)
# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
# include_directories(${CMAKE_CURRENT_SOURCEDIR}/../../Third-party)

# # 9. 设置测试目标
# set(test_client "user_client")
# aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/test test_files)
# add_executable(${test_client} ${test_files} ${proto_srcs})
# target_link_libraries(${test_client} -pthread -lgtest -lgflags -lspdlog -lfmt -lbrpc 
#     -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl 
#     /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
# )

# # 10. 设置安装路径
# INSTALL(TARGETS ${target} ${test_client} RUNTIME DESTINATION bin)


--- FILE: 3.User_Server/user_server.conf ---
内容:
-run_mode          = false                          # 程序的运行模式，false-调试； true-发布；
-log_file          = /im/logs/user_server.log       # 发布模式下，用于指定日志的输出文件
-log_level         = 0                              # 发布模式下，用于指定日志输出等级
-registry_host     = http://127.0.0.1:2379          # 服务注册中心地址
-instance_name     = /user_service/instance1        # 当前实例名称
-access_host       = 127.0.0.1:10003                # 当前实例的外部访问地址
-listen_port       = 10003                          # Rpc服务器监听端口
-rpc_timeout       = -1                             # Rpc调用超时时间
-rpc_threads       = 1                              # Rpc的IO线程数量
-base_service      = /service                       # 服务监控根目录
-file_service      = /service/file_service          # 文件管理子服务名称
-es_host           = http://127.0.0.1:9200/         # ES搜索引擎服务器URL
-mysql_host        = 127.0.0.1                      # Mysql服务器访问地址
-mysql_user        = root                           # Mysql服务器访问用户名
-mysql_pswd        = Cydia4384!                     # Mysql服务器访问密码
-mysql_db          = root_im                        # Mysql默认库名称
-mysql_cset        = utf8                           # Mysql客户端字符集
-mysql_access_port = 0                              # Mysql服务器访问端口
-mysql_pool_count  = 4                              # Mysql连接池最大连接数量
-redis_host        = 127.0.0.1                      # Redis服务器访问地址
-redis_port        = 6379                           # Redis服务器访问端口
-redis_db          = 0                              # Redis默认库号
-redis_keep_alive  = true                           # Redis长连接保活选项
-dms_key_id        = LTAI5tPyns6grPpbGLD6dcC4       # 短信平台密钥ID
-dms_key_secret    = EmXUY8Pt14skrCcmhmVBerMAdDiLJS # 短信平台密钥

--- FILE: 3.User_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/user_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./user_server.conf /im/conf

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/user_server -flagfile=/im/conf/user_server.conf

ENV LD_LIBRARY_PATH=/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH
RUN ln -s /lib/x86_64-linux-gnu/libcurl.so.4 /lib/x86_64-linux-gnu/libcurl.so



--- FILE: 3.User_Server/user.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

USE `chen_im`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL,
  `nickname` varchar(64) NULL,
  `description` TEXT NULL,
  `password` varchar(64) NULL,
  `phone` varchar(64) NULL,
  `avatar_id` varchar(64) NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `user_id_i`
  ON `user` (`user_id`);

CREATE UNIQUE INDEX `nickname_i`
  ON `user` (`nickname`);

CREATE UNIQUE INDEX `phone_i`
  ON `user` (`phone`);



--- FILE: 3.User_Server/test/user_client.cc ---
内容:
#include "etcd.hpp"
#include "rpc_service_manager.hpp"
#include "utility.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <thread>
#include "user.pb.h"
#include "base.pb.h"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(user_service, "/service/user_service", "服务监控根目录");

std::shared_ptr<chen_im::ServiceManager> _user_channels;

chen_im::UserInfo user_info;

std::string login_ssid;
std::string new_nickname = "小猪佩奇";

TEST(User_Subservice_Tests, User_Register_Test) {
    auto channel = _user_channels->get(FLAGS_user_service);//获取通信信道
    ASSERT_TRUE(channel);
    user_info.set_nickname("猪妈妈");

    chen_im::UserRegisterReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.set_nickname(user_info.nickname());
    req.set_password("123456");
    chen_im::UserRegisterRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());
    stub.UserRegister(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

TEST(User_Subservice_Tests, User_Login_Test)
{
    auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
    ASSERT_TRUE(channel);

    chen_im::UserLoginReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.set_nickname("猪妈妈");
    req.set_password("123456");
    chen_im::UserLoginRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());

    stub.UserLogin(&cntl, &req, &rsp, nullptr);
    
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    login_ssid = rsp.login_session_id();
}

// TEST(User_Subservice_Tests, User_Avatar_Setting_Test)
// {
//     auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
//     ASSERT_TRUE(channel);

//     chen_im::SetUserAvatarReq req;
//     req.set_request_id(chen_im::generate_uuid());
//     req.set_user_id(user_info.user_id());
//     req.set_session_id(login_ssid);
//     req.set_avatar(user_info.avatar());
//     chen_im::SetUserAvatarRsp rsp;
//     brpc::Controller cntl;
//     chen_im::UserService_Stub stub(channel.get());
//     stub.SetUserAvatar(&cntl, &req, &rsp, nullptr);
//     ASSERT_FALSE(cntl.Failed());
//     ASSERT_TRUE(rsp.success());
// }
// TEST(User_Subservice_Tests, User_Description_Setting_Test)
// {
//     auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
//     ASSERT_TRUE(channel);

//     chen_im::SetUserDescriptionReq req;
//     req.set_request_id(chen_im::generate_uuid());
//     req.set_user_id(user_info.user_id());
//     req.set_session_id(login_ssid);
//     req.set_description(user_info.description());
//     chen_im::SetUserDescriptionRsp rsp;
//     brpc::Controller cntl;
//     chen_im::UserService_Stub stub(channel.get());
//     stub.SetUserDescription(&cntl, &req, &rsp, nullptr);
//     ASSERT_FALSE(cntl.Failed());
//     ASSERT_TRUE(rsp.success());
// }
// TEST(User_Subservice_Tests, User_Nickname_Setting_Test)
// {
//     auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
//     ASSERT_TRUE(channel);

//     chen_im::SetUserNicknameReq req;
//     req.set_request_id(chen_im::generate_uuid());
//     req.set_user_id(user_info.user_id());
//     req.set_session_id(login_ssid);
//     req.set_nickname(new_nickname);
//     chen_im::SetUserNicknameRsp rsp;
//     brpc::Controller cntl;
//     chen_im::UserService_Stub stub(channel.get());
//     stub.SetUserNickname(&cntl, &req, &rsp, nullptr);
//     ASSERT_FALSE(cntl.Failed());
//     ASSERT_TRUE(rsp.success());
// }

TEST(User_Subservice_Tests, User_Info_Retrieval_Test)
{
    auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
    ASSERT_TRUE(channel);

    chen_im::GetUserInfoReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(user_info.user_id());
    req.set_session_id(login_ssid);
    chen_im::GetUserInfoRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());
    stub.GetUserInfo(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    ASSERT_EQ(user_info.user_id(), rsp.user_info().user_id());
    ASSERT_EQ(new_nickname, rsp.user_info().nickname());
    ASSERT_EQ(user_info.description(), rsp.user_info().description());
    ASSERT_EQ("", rsp.user_info().phone());
    ASSERT_EQ(user_info.avatar(), rsp.user_info().avatar());
}

void set_user_avatar(const std::string &uid, const std::string &avatar)
{
    auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
    ASSERT_TRUE(channel);
    chen_im::SetUserAvatarReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid);
    req.set_session_id(login_ssid);
    req.set_avatar(avatar);
    chen_im::SetUserAvatarRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());
    stub.SetUserAvatar(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

TEST(User_Subservice_Tests, Batch_User_Info_Retrieval_Test)
{
    set_user_avatar("UserID1", "Peppa Pig's Avatar Data");
    set_user_avatar("UserID2", "George Pig's Avatar Data");
    auto channel = _user_channels->get(FLAGS_user_service); // Obtain communication channel
    ASSERT_TRUE(channel);

    chen_im::GetMultiUserInfoReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.add_users_id("UserID1");
    req.add_users_id("UserID2");
    req.add_users_id("34cc-e65243b7-0000");
    chen_im::GetMultiUserInfoRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());
    stub.GetMultiUserInfo(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    auto users_map = rsp.mutable_users_info();
    chen_im::UserInfo fuser = (*users_map)["34cc-e65243b7-0000"];
    ASSERT_EQ(fuser.user_id(), "34cc-e65243b7-0000");
    ASSERT_EQ(fuser.nickname(), "Daddy Pig");
    ASSERT_EQ(fuser.description(), "");
    ASSERT_EQ(fuser.phone(), "");
    ASSERT_EQ(fuser.avatar(), "");

    chen_im::UserInfo puser = (*users_map)["UserID1"];
    ASSERT_EQ(puser.user_id(), "UserID1");
    ASSERT_EQ(puser.nickname(), "Peppa Pig");
    ASSERT_EQ(puser.description(), "This is a little pig");
    ASSERT_EQ(puser.phone(), "Phone Number 1");
    ASSERT_EQ(puser.avatar(), "Peppa Pig's Avatar Data");

    chen_im::UserInfo quser = (*users_map)["UserID2"];
    ASSERT_EQ(quser.user_id(), "UserID2");
    ASSERT_EQ(quser.nickname(), "George Pig");
    ASSERT_EQ(quser.description(), "This is a little baby pig");
    ASSERT_EQ(quser.phone(), "Phone Number 2");
    ASSERT_EQ(quser.avatar(), "George Pig's Avatar Data");
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    // 1. 先构造Rpc信道管理对象
    _user_channels = std::make_shared<chen_im::ServiceManager>();
    _user_channels->concern(FLAGS_user_service);
    auto put_cb = std::bind(&chen_im::ServiceManager::when_service_online, _user_channels.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&chen_im::ServiceManager::when_service_offline, _user_channels.get(), std::placeholders::_1, std::placeholders::_2);

    // 2. 构造服务发现对象
    std::shared_ptr<chen_im::Discovery> dclient = std::make_shared<chen_im::Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);

    user_info.set_nickname("test_user");
    user_info.set_user_id("34cc-e65243b7-0000");
    user_info.set_description("这是一个美丽的猪妈妈");
    user_info.set_phone("15929917272");
    user_info.set_avatar("猪妈妈头像数据");
    testing::InitGoogleTest(&argc, argv);
    LOG_DEBUG("开始测试！");
    return RUN_ALL_TESTS();
}

--- FILE: 3.User_Server/test/es_test/main.cc ---
内容:
#include "../../../Common/elasticsearch_user.hpp"
#include <gflags/gflags.h>

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");


DEFINE_string(es_host, "http://127.0.0.1:9200/", "es服务器URL");

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    auto es_client = chen_im::ESClientFactory::create({FLAGS_es_host});

    auto es_user_index = std::make_shared<chen_im::ESUser>(es_client);
    es_user_index->create_index();
    es_user_index->append_user("用户ID1", "手机号1", "小猪佩奇", "这是一只小猪", "小猪头像1");
    es_user_index->append_user("用户ID2", "手机号2", "小猪乔治", "这是一只小小猪", "小猪头像2");
    
    auto res = es_user_index->search("小猪", {"用户ID1"});

    for (auto &u : res) {
        std::cout << "-----------------" << std::endl;
        std::cout << u.user_id() << std::endl;
        std::cout << u.phone() << std::endl;
        std::cout << u.nickname() << std::endl;
        std::cout << u.description() << std::endl;
        std::cout << u.avatar_id() << std::endl;
    }
    return 0;
}

--- FILE: 3.User_Server/test/es_test/Makefile ---
内容:
es_test:main.cc
	g++ -o $@ $^ -std=c++17 -lgflags -ljsoncpp -lspdlog -lelasticlient

--- FILE: 3.User_Server/test/mysql_test/main.cc ---
内容:
#include "mysql_odb_factory.hpp"
#include "mysql_user.hpp"
#include "user-odb.hxx"
#include <gflags/gflags.h>


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

// Mysql
DEFINE_string(mysql_host, "127.0.0.1", "这是MySQL的服务地址");
DEFINE_int32(mysql_port, 3306, "这是MySQL的服务端口");
DEFINE_string(db, "TestODB", "使用的数据库名称");
DEFINE_string(user, "chen", "MySQL用户名");
DEFINE_string(passwd, "Cydia4384!", "MySQL用户密码");
DEFINE_string(charset, "utf8", "字符集");
DEFINE_int32(max_pool, 3, "MySQL连接池的最大连接数");

void insert(chen_im::UserTable &user) {
    auto user1 = std::make_shared<User>("uid1", "昵称1", "123456");
    user.insert(user1);
    
    auto user2 = std::make_shared<User>("uid2", "15566667777");
    user.insert(user2);
}

void update_by_id(chen_im::UserTable &user_tb) {
    auto user = user_tb.select_by_uid("uid1");
    user->description("一个风一样的男人...");
    user_tb.update(user);
}

void update_by_phone(chen_im::UserTable &user_tb) {
    auto user = user_tb.select_by_phone("15566667777");
    user->password("22223333");
    user_tb.update(user);
}

void update_by_nickname(chen_im::UserTable &user_tb) {
    auto user = user_tb.select_by_nickname("uid2");
    user->nickname("昵称2");
    user_tb.update(user);
}

void select_users(chen_im::UserTable &user_tb) {
    std::vector<std::string> id_list = {"uid1", "uid2"};
    auto res = user_tb.select_by_multi_uid(id_list);
    for (auto user : res) {
        std::cout << user.nickname() << std::endl;
    }
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    auto db = chen_im::ODBFactory::create(
        "chen", "Cydia4384!", "chen_im", 
        "127.0.0.1", 3306, "utf8", 3
    );
    
    chen_im::UserTable user(db);

    // insert(user);
    // update_by_id(user);
    // update_by_phone(user);
    // update_by_nickname(user);
    select_users(user);
    return 0;
}

--- FILE: 3.User_Server/test/mysql_test/user.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

CREATE DATABASE IF NOT EXISTS `chen_im`;
USE `chen_im`;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL,
  `nickname` varchar(64) NULL,
  `description` TEXT NULL,
  `password` varchar(64) NULL,
  `phone` varchar(64) NULL,
  `avatar_id` varchar(64) NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `user_id_i`
  ON `user` (`user_id`);

CREATE UNIQUE INDEX `nickname_i`
  ON `user` (`nickname`);

CREATE UNIQUE INDEX `phone_i`
  ON `user` (`phone`);



--- FILE: 3.User_Server/test/redis_test/main.cc ---
内容:
#include "../../../Common/redis_CRUD.hpp"
#include <gflags/gflags.h>
#include <thread>


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");


DEFINE_string(ip, "127.0.0.1", "这是服务器的IP地址，格式：127.0.0.1");
DEFINE_int32(port, 6379, "这是服务器的端口, 格式: 8080");
DEFINE_int32(db, 0, "库的编号：默认0号");
DEFINE_bool(keep_alive, true, "是否进行长连接保活");

void session_test(const std::shared_ptr<sw::redis::Redis> &client) {
    chen_im::Session ss(client);
    ss.append("会话ID1", "用户ID1");
    ss.append("会话ID2", "用户ID2");
    ss.append("会话ID3", "用户ID3");
    ss.append("会话ID4", "用户ID4");

    ss.remove("会话ID2");
    ss.remove("会话ID3");

    auto res1 = ss.get_uid("会话ID1");
    if (res1) std::cout << *res1 << std::endl;
    auto res2 = ss.get_uid("会话ID2");
    if (res2) std::cout << *res2 << std::endl;
    auto res3 = ss.get_uid("会话ID3");
    if (res3) std::cout << *res3 << std::endl;
    auto res4 = ss.get_uid("会话ID4");
    if (res4) std::cout << *res4 << std::endl;
}

void status_test(const std::shared_ptr<sw::redis::Redis> &client) {
    chen_im::Status status(client);
    status.append("用户ID1");
    status.append("用户ID2");
    status.append("用户ID3");
    
    status.remove("用户ID2");

    if (status.exists("用户ID1")) std::cout << "用户1在线！" << std::endl;
    if (status.exists("用户ID2")) std::cout << "用户2在线！" << std::endl;
    if (status.exists("用户ID3")) std::cout << "用户3在线！" << std::endl;
}

void code_test(const std::shared_ptr<sw::redis::Redis> &client) {
    chen_im::Codes codes(client);
    codes.append("验证码ID1", "验证码1");
    codes.append("验证码ID2", "验证码2");
    codes.append("验证码ID3", "验证码3");
    
    codes.remove("验证码ID2");

    auto y1 = codes.code("验证码ID1");
    auto y2 = codes.code("验证码ID2");
    auto y3 = codes.code("验证码ID3");
    if (y1) std::cout << *y1 << std::endl;
    if (y2) std::cout << *y2 << std::endl;
    if (y3) std::cout << *y3 << std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(4));
    auto y4 = codes.code("验证码ID1");
    auto y5 = codes.code("验证码ID2");
    auto y6 = codes.code("验证码ID3");
    if (!y4) std::cout << "验证码ID1不存在" << std::endl;
    if (!y5) std::cout << "验证码ID2不存在" << std::endl;
    if (!y6) std::cout << "验证码ID3不存在" << std::endl;
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    //chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    auto client = chen_im::RedisClientFactory::create(FLAGS_ip, FLAGS_port, FLAGS_db, FLAGS_keep_alive);

    //session_test(client);
    //status_test(client);
    code_test(client);
    return 0;
}


--- FILE: 3.User_Server/test/redis_test/Makefile ---
内容:
redis_test : main.cc
	g++ -std=c++17 $^ -o $@ -lhiredis -lredis++ -lgflags 

--- FILE: 3.User_Server/test/redis_test/redis_test ---
内容:
【无法读取文件内容，可能是二进制文件或编码问题：'utf-8' codec can't decode byte 0xe0 in position 24: invalid continuation byte】

--- FILE: 3.User_Server/source/user_server.hpp ---
内容:
// 实现语音识别子服务
#include <brpc/server.h>
#include <butil/logging.h>

#include "elasticsearch_user.hpp"    // es数据管理客户端封装
#include "redis_CRUD.hpp"      // redis数据管理客户端封装
#include "mysql_user.hpp" // mysql数据管理客户端封装
#include "etcd.hpp"            // 服务注册模块封装
#include "logger.hpp"          // 日志模块封装
#include "utility.hpp"         // 基础工具接口
#include "dms.hpp"             // 短信平台SDK模块封装
#include "rpc_service_manager.hpp"         // 信道管理模块封装

#include "user.hxx"
#include "user-odb.hxx"

#include "user.pb.h" // protobuf框架代码
#include "base.pb.h" // protobuf框架代码
#include "file.pb.h" // protobuf框架代码

namespace chen_im
{
    class UserServiceImpl : public chen_im::UserService
    {     
    private:
        std::shared_ptr<ESUser>    _es_user;
        std::shared_ptr<UserTable> _mysql_user_table;
        std::shared_ptr<Session>   _redis_session;
        std::shared_ptr<Status>    _redis_status;
        std::shared_ptr<Codes>     _redis_codes;

        // 这边是rpc调用客户端相关对象
        std::string                     _file_service_name;
        std::shared_ptr<ServiceManager> _service_manager;
        std::shared_ptr<DMSClient>      _dms_client;

    public:
        UserServiceImpl(const shared_ptr<DMSClient> &dms_client,
                        const std::shared_ptr<elasticlient::Client> &es_client,
                        const std::shared_ptr<odb::mysql::database> &mysql_client,
                        const std::shared_ptr<sw::redis::Redis> &redis_client,
                        const std::shared_ptr<ServiceManager> &channel_manager,
                        const std::string &file_service_name)
            :_es_user(std::make_shared<ESUser>(es_client))
            , _mysql_user_table(std::make_shared<UserTable>(mysql_client))
            , _redis_session(std::make_shared<Session>(redis_client))
            ,  _redis_status(std::make_shared<Status>(redis_client))
            , _redis_codes(std::make_shared<Codes>(redis_client))
            , _file_service_name(file_service_name)
            , _service_manager(channel_manager)
            , _dms_client(dms_client)
        {
            _es_user->create_index();
        }

        ~UserServiceImpl() {}

        // 检查昵称是否合法
        bool nickname_check(const std::string &nickname)
        {
            return nickname.size() < 22;
        }

        // 检查密码是否合法：
        // 1. 6<长度<15 
        // 2. 字母、数字、下划线、横杠
        bool password_check(const std::string &password)
        {
            if (password.size() < 6 || password.size() > 15)
            {
                LOG_ERROR("密码长度不合法：{}-{}", password, password.size());
                return false;
            }
            for (int i = 0; i < password.size(); i++)
            {
                if (!((password[i] > 'a' && password[i] < 'z') ||
                      (password[i] > 'A' && password[i] < 'Z') ||
                      (password[i] > '0' && password[i] < '9') ||
                      password[i] == '_' || password[i] == '-'))
                {
                    LOG_ERROR("密码字符不合法：{}", password);
                    return false;
                }
            }
            return true;
        }

        // 通过昵称+密码注册新用户
        // request：请求id、昵称、密码
        // response：请求id、是否成功、错误信息
        virtual void UserRegister(::google::protobuf::RpcController *controller,
                                  const ::chen_im::UserRegisterReq *request,
                                  ::chen_im::UserRegisterRsp *response,
                                  ::google::protobuf::Closure *done) override
        {
            LOG_DEBUG("收到用户注册请求！");
            brpc::ClosureGuard rpc_guard(done); // 把Closure指针管理起来，Closure在释放的时候会调用Run();
            // 定义一个错误处理函数，当出错的时候主动调用它
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };

            // 1. 从请求中取出昵称和密码
            std::string nickname = request->nickname();
            std::string password = request->password();

            // 2. 检查昵称是否合法（只能包含字母，数字，连字符-，下划线_，长度限制 3~15 之间）
            bool ret = nickname_check(nickname);
            if (ret == false) {
                LOG_ERROR("注册请求失败，用户名长度不合法！request_id: {}", request->request_id());
                return err_response(request->request_id(), "用户名长度不合法！");
            }

            // 3. 检查密码是否合法（只能包含字母，数字，长度限制 6~15 之间）
            ret = password_check(password);
            if (ret == false) {
                LOG_ERROR("注册请求失败，密码格式不合法！request_id: {}", request->request_id());
                return err_response(request->request_id(), "密码格式不合法！");
            }

            // 4. 根据昵称在数据库进行判断是否昵称已存在
            auto user = _mysql_user_table->select_by_nickname(nickname);
            if (user) {
                LOG_ERROR("注册请求失败，该用户名被占用：{}, request_id: {}", request->request_id(), nickname);
                return err_response(request->request_id(), "用户名被占用!");
            }

            // 5. 向数据库新增数据
            std::string uid = generate_uuid();
            user = std::make_shared<User>(uid, nickname, password);
            ret = _mysql_user_table->insert(user);
            if (ret == false) {
                LOG_ERROR("向Mysql数据库新增数据失败！request_id: {}", request->request_id());
                return err_response(request->request_id(), "Mysql数据库新增数据失败!");
            }

            // 6. 向 ES 服务器中新增用户信息
            ret = _es_user->append_user(uid, "", nickname, "", "");
            if (ret == false) {
                LOG_ERROR("向ES搜索引擎新增数据失败！request_id: {}", request->request_id());
                return err_response(request->request_id(), "ES搜索引擎新增数据失败！");
            }

            // 7. 组织响应，进行成功与否的响应即可。
            response->set_request_id(request->request_id());
            response->set_success(true);
        }

        // 通过昵称+密码登录
        // request：请求id、昵称、密码
        // response：请求id、是否成功、错误信息
        virtual void UserLogin(::google::protobuf::RpcController *controller,
                               const ::chen_im::UserLoginReq *request,
                               ::chen_im::UserLoginRsp *response,
                               ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到用户登录请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };

            // 1. 从请求中取出昵称和密码
            std::string nickname = request->nickname();
            std::string password = request->password();

            // 2. 通过昵称获取用户信息，进行密码是否一致的判断
            auto user = _mysql_user_table->select_by_nickname(nickname);
            if (!user || password != user->password()) {
                LOG_ERROR("用户名或密码错误，递交的昵称：{}，密码{}，request_id：{}！", nickname, password, request->request_id());
                return err_response(request->request_id(), "用户名或密码错误!");
            }

            // 3. 根据 redis 中的登录标记信息是否存在判断用户是否已经登录。
            bool ret = _redis_status->exists(user->user_id());
            if (ret == true) {
                LOG_ERROR("{} - 用户已在其他地方登录 - {}！", request->request_id(), nickname);
                return err_response(request->request_id(), "用户已在其他地方登录!");
            }

            // 4. 构造会话 ID，生成会话键值对，向 redis 中添加会话信息以及登录标记信息
            std::string ssid = generate_uuid();
            _redis_session->append(ssid, user->user_id());

            // 5. 添加用户登录信息
            _redis_status->append(user->user_id());

            // 5. 组织响应，返回生成的会话 ID
            response->set_request_id(request->request_id());
            response->set_login_session_id(ssid);
            response->set_success(true);
        }

        // 验证手机号的合规性
        bool phone_check(const std::string &phone)
        {
            if (phone.size() != 11)
                return false;
            if (phone[0] != '1')
                return false;
            if (phone[1] < '3' || phone[1] > '9')
                return false;
            for (int i = 2; i < 11; i++)
            {
                if (phone[i] < '0' || phone[i] > '9')
                    return false;
            }
            return true;
        }

        // 给用户发送一个验证码，在redis中存放 <code_id, code>
        virtual void GetPhoneVerifyCode(::google::protobuf::RpcController *controller,
                                        const ::chen_im::PhoneVerifyCodeReq *request,
                                        ::chen_im::PhoneVerifyCodeRsp *response,
                                        ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到短信验证码获取请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中取出手机号码
            std::string phone = request->phone_number();

            // 2. 验证手机号码格式是否正确（必须以 1 开始，第二位 3~9 之间，后边 9 个数字字符）
            bool ret = phone_check(phone);
            if (ret == false) {
                LOG_ERROR("手机号码格式错误！手机号：{}，request_id：{}", phone, request->request_id());
                return err_response(request->request_id(), "手机号码格式错误!");
            }

            // 3. 生成 4 位随机验证码
            std::string code_id = generate_uuid();
            std::string code = generate_verification_code();

            // 4. 基于短信平台 SDK 发送验证码
            ret = _dms_client->send(phone, code);
            if (ret == false) {
                LOG_ERROR("向{}发送短信验证码失败，request_id: {}！", phone, request->request_id());
                return err_response(request->request_id(), "短信验证码发送失败!");
            }

            // 5. 构造验证码 ID，添加到 redis 验证码映射键值索引中
            _redis_codes->append(code_id, code);

            // 6. 组织响应，返回生成的验证码 ID
            response->set_request_id(request->request_id());
            response->set_success(true);
            response->set_verify_code_id(code_id);
            LOG_DEBUG("获取短信验证码处理完成！");
        }

        virtual void PhoneRegister(::google::protobuf::RpcController *controller,
                                   const ::chen_im::PhoneRegisterReq *request,
                                   ::chen_im::PhoneRegisterRsp *response,
                                   ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到手机号注册请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };

            // 1. 从请求中取出手机号码和验证码,验证码ID
            std::string phone = request->phone_number();
            std::string code_id = request->verify_code_id();
            std::string code = request->verify_code();

            // 2. 检查注册手机号码是否合法
            bool ret = phone_check(phone);
            if (ret == false) {
                LOG_ERROR("手机号码格式错误：{}，request_id: {}！", phone, request->request_id());
                return err_response(request->request_id(), "手机号码格式错误!");
            }

            // 3. 从 redis 数据库中进行验证码 ID-验证码一致性匹配
            auto real_verification_code = _redis_codes->code(code_id);
            if (real_verification_code != code) {
                LOG_ERROR("验证码不匹配: code_id：{}，code：{}，request_id: {}, ", code_id, code, request->request_id());
                return err_response(request->request_id(), "验证码错误!");
            }

            // 4. 通过数据库查询判断手机号是否已经注册过
            auto user = _mysql_user_table->select_by_phone(phone);
            if (user) {
                LOG_ERROR("{} 该手机号已注册过用户！request_id: {}", phone, request->request_id());
                return err_response(request->request_id(), "该手机号已注册过用户!");
            }

            // 5. 向数据库新增用户信息
            std::string uid = generate_uuid();
            user = std::make_shared<User>(uid, phone);
            ret = _mysql_user_table->insert(user);
            if (ret == false) {
                LOG_ERROR("向数据库添加用户信息失败, phone: {}, request_id: {}！", phone, request->request_id());
                return err_response(request->request_id(), "向数据库添加用户信息失败!");
            }

            // 6. 向 ES 服务器中新增用户信息
            ret = _es_user->append_user(uid, phone, uid, "", "");
            if (ret == false)
            {
                LOG_ERROR("ES搜索引擎新增数据失败！request_id: {}", request->request_id());
                return err_response(request->request_id(), "ES搜索引擎新增数据失败！");
            }

            // 7. 组织响应，进行成功与否的响应即可。
            response->set_request_id(request->request_id());
            response->set_success(true);
        }

        // 手机号+验证码登录
        virtual void PhoneLogin(::google::protobuf::RpcController *controller,
                                const ::chen_im::PhoneLoginReq *request,
                                ::chen_im::PhoneLoginRsp *response,
                                ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到手机号登录请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };

            // 1. 从请求中取出手机号码和验证码 ID，以及验证码。
            std::string phone = request->phone_number();
            std::string code_id = request->verify_code_id();
            std::string code = request->verify_code();

            // 2. 检查注册手机号码是否合法
            bool ret = phone_check(phone);
            if (ret == false) {
                LOG_ERROR("手机号{}格式错误！request_id：{}", phone, request->request_id());
                return err_response(request->request_id(), "手机号码格式错误!");
            }

            // 3. 根据手机号从数据数据进行用户信息查询，判断用用户是否存在
            auto user = _mysql_user_table->select_by_phone(phone);
            if (!user) {
                LOG_ERROR("手机号{}未注册！request_id：{}！", phone, request->request_id());
                return err_response(request->request_id(), "该手机号未注册用户!");
            }

            // 4. 从 redis 数据库中进行验证码 ID-验证码一致性匹配
            auto generate_verification_code = _redis_codes->code(code_id);
            if (generate_verification_code != code) {
                LOG_ERROR("验证码错误{}-{}，request_id: {}！", code_id, code, request->request_id());
                return err_response(request->request_id(), "验证码错误!");
            }
            _redis_codes->remove(code_id);

            // 5. 根据 redis 中的登录标记信息是否存在判断用户是否已经登录。
            ret = _redis_status->exists(user->user_id());
            if (ret == true) {
                LOG_ERROR("用户{}已在其他地方登录, request_id: {}！", phone, request->request_id());
                return err_response(request->request_id(), "用户已在其他地方登录!");
            }

            // 6. 构造会话 ID，生成会话键值对，向 redis 中添加会话信息以及登录标记信息
            std::string ssid = generate_uuid();
            _redis_session->append(ssid, user->user_id());

            // 7. 添加用户登录信息
            _redis_status->append(user->user_id());

            // 8. 组织响应，返回生成的会话 ID
            response->set_request_id(request->request_id());
            response->set_login_session_id(ssid);
            response->set_success(true);
        }

        // 获取用户信息，这是用户登录之后才会进行的操作
        virtual void GetUserInfo(::google::protobuf::RpcController *controller,
                                 const ::chen_im::GetUserInfoReq *request,
                                 ::chen_im::GetUserInfoRsp *response,
                                 ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到获取单个用户信息请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中取出用户 ID
            std::string uid = request->user_id();

            // 2. 通过用户 ID，从数据库中查询用户信息
            auto user = _mysql_user_table->select_by_uid(uid);
            if (!user) {
                LOG_ERROR("未找到用户信息{}, request_id: {}", uid, request->request_id());
                return err_response(request->request_id(), "未找到用户信息!");
            }

            // 3. 根据用户信息中的头像 ID，从文件服务器获取头像文件数据，组织完整用户信息
            UserInfo *user_info = response->mutable_user_info();
            user_info->set_user_id(user->user_id());
            user_info->set_nickname(user->nickname());
            user_info->set_description(user->description());
            user_info->set_phone(user->phone());

            if (!user->avatar_id().empty()) {
                // 从信道管理对象中，获取到连接了文件管理子服务的channel
                auto channel = _service_manager->get(_file_service_name);
                if (!channel)
                {
                    LOG_ERROR("{} - 未找到文件管理子服务节点 - {} - {}！",
                              request->request_id(), _file_service_name, uid);
                    return err_response(request->request_id(), "未找到文件管理子服务节点!");
                }

                // 进行文件子服务的rpc请求，进行头像文件下载
                chen_im::FileService_Stub stub(channel.get());
                chen_im::GetSingleFileReq req;
                chen_im::GetSingleFileRsp rsp;
                req.set_request_id(request->request_id());
                req.set_file_id(user->avatar_id());
                brpc::Controller cntl;
                stub.GetSingleFile(&cntl, &req, &rsp, nullptr);
                if (cntl.Failed() == true || rsp.success() == false)
                {
                    LOG_ERROR("{} - 文件子服务调用失败：{}！", request->request_id(), cntl.ErrorText());
                    return err_response(request->request_id(), "文件子服务调用失败!");
                }
                user_info->set_avatar(rsp.file_data().file_content());
            }

            // 4. 组织响应，返回用户信息
            response->set_request_id(request->request_id());
            response->set_success(true);
        }

        // 获取一组用户信息，这是用户登录之后才会进行的操作
        virtual void GetMultiUserInfo(::google::protobuf::RpcController *controller,
                                      const chen_im::GetMultiUserInfoReq *request,
                                      chen_im::GetMultiUserInfoRsp *response,
                                      ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到批量用户信息获取请求！");
            brpc::ClosureGuard rpc_guard(done);
            // 1. 定义错误回调
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 2. 从请求中取出用户ID --- 列表
            std::vector<std::string> uid_lists;
            for (int i = 0; i < request->users_id_size(); i++)
            {
                uid_lists.push_back(request->users_id(i));
            }
            // 3. 从数据库进行批量用户信息查询
            auto users = _mysql_user_table->select_by_multi_uid(uid_lists);
            if (users.size() != request->users_id_size())
            {
                LOG_ERROR("{} - 从数据库查找的用户信息数量不一致 {}-{}！",
                          request->request_id(), request->users_id_size(), users.size());
                return err_response(request->request_id(), "从数据库查找的用户信息数量不一致!");
            }
            // 4. 批量从文件管理子服务进行文件下载
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("{} - 未找到文件管理子服务节点 - {}！", request->request_id(), _file_service_name);
                return err_response(request->request_id(), "未找到文件管理子服务节点!");
            }
            chen_im::FileService_Stub stub(channel.get());
            chen_im::GetMultiFileReq req;
            chen_im::GetMultiFileRsp rsp;
            req.set_request_id(request->request_id());
            for (auto &user : users)
            {
                if (user.avatar_id().empty())
                    continue;
                req.add_file_id_list(user.avatar_id());
            }
            brpc::Controller cntl;
            stub.GetMultiFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed() == true || rsp.success() == false)
            {
                LOG_ERROR("{} - 文件子服务调用失败：{} - {}！", request->request_id(),
                          _file_service_name, cntl.ErrorText());
                return err_response(request->request_id(), "文件子服务调用失败!");
            }
            // 5. 组织响应（）
            for (auto &user : users)
            {
                auto user_map = response->mutable_users_info(); // 本次请求要响应的用户信息map
                auto file_map = rsp.mutable_file_data();        // 这是批量文件请求响应中的map
                UserInfo user_info;
                user_info.set_user_id(user.user_id());
                user_info.set_nickname(user.nickname());
                user_info.set_description(user.description());
                user_info.set_phone(user.phone());
                user_info.set_avatar((*file_map)[user.avatar_id()].file_content());
                (*user_map)[user_info.user_id()] = user_info;
            }
            response->set_request_id(request->request_id());
            response->set_success(true);
        }

        // 设置用户头像
        virtual void SetUserAvatar(::google::protobuf::RpcController *controller,
                                   const ::chen_im::SetUserAvatarReq *request,
                                   ::chen_im::SetUserAvatarRsp *response,
                                   ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到用户头像设置请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中取出用户 ID 与头像数据
            std::string uid = request->user_id();
            // 2. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在
            auto user = _mysql_user_table->select_by_uid(uid);
            if (!user)
            {
                LOG_ERROR("{} - 未找到用户信息 - {}！", request->request_id(), uid);
                return err_response(request->request_id(), "未找到用户信息!");
            }
            // 3. 上传头像文件到文件子服务，
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("{} - 未找到文件管理子服务节点 - {}！", request->request_id(), _file_service_name);
                return err_response(request->request_id(), "未找到文件管理子服务节点!");
            }
            chen_im::FileService_Stub stub(channel.get());
            chen_im::PutSingleFileReq req;
            chen_im::PutSingleFileRsp rsp;
            req.set_request_id(request->request_id());
            req.mutable_file_data()->set_file_name("");
            req.mutable_file_data()->set_file_size(request->avatar().size());
            req.mutable_file_data()->set_file_content(request->avatar());
            brpc::Controller cntl;
            stub.PutSingleFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed() == true || rsp.success() == false)
            {
                LOG_ERROR("{} - 文件子服务调用失败：{}！", request->request_id(), cntl.ErrorText());
                return err_response(request->request_id(), "文件子服务调用失败!");
            }
            std::string avatar_id = rsp.file_info().file_id();
            // 4. 将返回的头像文件 ID 更新到数据库中
            user->avatar_id(avatar_id);
            bool ret = _mysql_user_table->update(user);
            if (ret == false)
            {
                LOG_ERROR("{} - 更新数据库用户头像ID失败 ：{}！", request->request_id(), avatar_id);
                return err_response(request->request_id(), "更新数据库用户头像ID失败!");
            }
            // 5. 更新 ES 服务器中用户信息
            ret = _es_user->append_user(user->user_id(), user->phone(),
                                        user->nickname(), user->description(), user->avatar_id());
            if (ret == false)
            {
                LOG_ERROR("{} - 更新搜索引擎用户头像ID失败 ：{}！", request->request_id(), avatar_id);
                return err_response(request->request_id(), "更新搜索引擎用户头像ID失败!");
            }
            // 6. 组织响应，返回更新成功与否
            response->set_request_id(request->request_id());
            response->set_success(true);
        }

        // 设置用户昵称
        virtual void SetUserNickname(::google::protobuf::RpcController *controller,
                                     const ::chen_im::SetUserNicknameReq *request,
                                     ::chen_im::SetUserNicknameRsp *response,
                                     ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到用户昵称设置请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中取出用户 ID 与新的昵称
            std::string uid = request->user_id();
            std::string new_nickname = request->nickname();
            // 2. 判断昵称格式是否正确
            bool ret = nickname_check(new_nickname);
            if (ret == false)
            {
                LOG_ERROR("{} - 用户名长度不合法！", request->request_id());
                return err_response(request->request_id(), "用户名长度不合法！");
            }
            // 3. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在
            auto user = _mysql_user_table->select_by_uid(uid);
            if (!user)
            {
                LOG_ERROR("{} - 未找到用户信息 - {}！", request->request_id(), uid);
                return err_response(request->request_id(), "未找到用户信息!");
            }
            // 4. 将新的昵称更新到数据库中
            user->nickname(new_nickname);
            ret = _mysql_user_table->update(user);
            if (ret == false)
            {
                LOG_ERROR("{} - 更新数据库用户昵称失败 ：{}！", request->request_id(), new_nickname);
                return err_response(request->request_id(), "更新数据库用户昵称失败!");
            }
            // 5. 更新 ES 服务器中用户信息
            ret = _es_user->append_user(user->user_id(), user->phone(),
                                        user->nickname(), user->description(), user->avatar_id());
            if (ret == false)
            {
                LOG_ERROR("{} - 更新搜索引擎用户昵称失败 ：{}！", request->request_id(), new_nickname);
                return err_response(request->request_id(), "更新搜索引擎用户昵称失败!");
            }
            // 6. 组织响应，返回更新成功与否
            response->set_request_id(request->request_id());
            response->set_success(true);
        }
        
        // 设置用户签名
        virtual void SetUserDescription(::google::protobuf::RpcController *controller,
                                        const ::chen_im::SetUserDescriptionReq *request,
                                        ::chen_im::SetUserDescriptionRsp *response,
                                        ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到用户签名设置请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中取出用户 ID 与新的昵称
            std::string uid = request->user_id();
            std::string new_description = request->description();
            // 3. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在
            auto user = _mysql_user_table->select_by_uid(uid);
            if (!user)
            {
                LOG_ERROR("{} - 未找到用户信息 - {}！", request->request_id(), uid);
                return err_response(request->request_id(), "未找到用户信息!");
            }
            // 4. 将新的昵称更新到数据库中
            user->description(new_description);
            bool ret = _mysql_user_table->update(user);
            if (ret == false)
            {
                LOG_ERROR("{} - 更新数据库用户签名失败 ：{}！", request->request_id(), new_description);
                return err_response(request->request_id(), "更新数据库用户签名失败!");
            }
            // 5. 更新 ES 服务器中用户信息
            ret = _es_user->append_user(user->user_id(), user->phone(),
                                        user->nickname(), user->description(), user->avatar_id());
            if (ret == false)
            {
                LOG_ERROR("{} - 更新搜索引擎用户签名失败 ：{}！", request->request_id(), new_description);
                return err_response(request->request_id(), "更新搜索引擎用户签名失败!");
            }
            // 6. 组织响应，返回更新成功与否
            response->set_request_id(request->request_id());
            response->set_success(true);
        }
        
        // 设置用户手机号
        virtual void SetUserPhoneNumber(::google::protobuf::RpcController *controller,
                                        const ::chen_im::SetUserPhoneNumberReq *request,
                                        ::chen_im::SetUserPhoneNumberRsp *response,
                                        ::google::protobuf::Closure *done)
        {
            LOG_DEBUG("收到用户手机号设置请求！");
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中取出用户 ID 与新的昵称
            std::string uid = request->user_id();
            std::string new_phone = request->phone_number();
            std::string code = request->phone_verify_code();
            std::string code_id = request->phone_verify_code_id();
            // 2. 对验证码进行验证
            auto generate_verification_code = _redis_codes->code(code_id);
            if (generate_verification_code != code)
            {
                LOG_ERROR("{} - 验证码错误 - {}-{}！", request->request_id(), code_id, code);
                return err_response(request->request_id(), "验证码错误!");
            }
            // 3. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在
            auto user = _mysql_user_table->select_by_uid(uid);
            if (!user)
            {
                LOG_ERROR("{} - 未找到用户信息 - {}！", request->request_id(), uid);
                return err_response(request->request_id(), "未找到用户信息!");
            }
            // 4. 将新的昵称更新到数据库中
            user->phone(new_phone);
            bool ret = _mysql_user_table->update(user);
            if (ret == false)
            {
                LOG_ERROR("{} - 更新数据库用户手机号失败 ：{}！", request->request_id(), new_phone);
                return err_response(request->request_id(), "更新数据库用户手机号失败!");
            }
            // 5. 更新 ES 服务器中用户信息
            ret = _es_user->append_user(user->user_id(), user->phone(),
                                        user->nickname(), user->description(), user->avatar_id());
            if (ret == false)
            {
                LOG_ERROR("{} - 更新搜索引擎用户手机号失败 ：{}！", request->request_id(), new_phone);
                return err_response(request->request_id(), "更新搜索引擎用户手机号失败!");
            }
            // 6. 组织响应，返回更新成功与否
            response->set_request_id(request->request_id());
            response->set_success(true);
        }
    };

    class UserServer
    {
    private:
        std::shared_ptr<Discovery>            _service_discovery_client;  // 需要调用文件子服务，所以要发现文件子服务
        std::shared_ptr<Registry>             _service_registry_client;   // 自己作为用户服务，要向注册中心注册自己

        std::shared_ptr<elasticlient::Client> _es_client;           // 搜索引擎客户端
        std::shared_ptr<odb::mysql::database> _mysql_client;        // mysql客户端
        std::shared_ptr<sw::redis::Redis>     _redis_client;        // redis客户端
        std::shared_ptr<brpc::Server>         _rpc_server;          // 因为自己提供用户相关的rpc调用接口，所以自己时一个brpc服务器
    public:
        using ptr = std::shared_ptr<UserServer>;
        UserServer(const std::shared_ptr<Discovery> service_discoverer,
                   const std::shared_ptr<Registry> &reg_client,
                   const std::shared_ptr<elasticlient::Client> &es_client,
                   const std::shared_ptr<odb::mysql::database> &mysql_client,
                   std::shared_ptr<sw::redis::Redis> &redis_client,
                   const std::shared_ptr<brpc::Server> &server) 
            :_service_discovery_client(service_discoverer)
            , _service_registry_client(reg_client)
            , _es_client(es_client)
            , _mysql_client(mysql_client)
            , _redis_client(redis_client)
            , _rpc_server(server) 
        {}

        ~UserServer() {}
        // 启动RPC服务器，一直运行直到
        void start()
        {
            _rpc_server->RunUntilAskedToQuit();
        }

    };

    class UserServerFactory
    {
    private:
        std::shared_ptr<Discovery>            _service_discoverer;     //   
        std::shared_ptr<Registry>             _registry_client;        //     
        
        std::shared_ptr<elasticlient::Client> _es_client;              //     
        std::shared_ptr<odb::mysql::database> _mysql_client;           //        
        std::shared_ptr<sw::redis::Redis>     _redis_client;           //        
        
        std::string                           _file_service_name;      //             
        std::shared_ptr<ServiceManager>       _service_manager;        //       
       
        std::shared_ptr<DMSClient>            _dms_client;             //      
        std::shared_ptr<brpc::Server>         _rpc_server;             //      
    public:
        // 构造es客户端对象
        void make_es_object(const std::vector<std::string> host_list)
        {
            _es_client = ESClientFactory::create(host_list);
        }

        void make_dms_object(const std::string &access_key_id,
                             const std::string &access_key_secret)
        {
            _dms_client = std::make_shared<DMSClient>(access_key_id, access_key_secret);
        }

        // 构造mysql客户端对象
        void make_mysql_object(
            const std::string &user,
            const std::string &pswd,
            const std::string &host,
            const std::string &db,
            const std::string &char_set,
            int port,
            int conn_pool_count)
        {
            _mysql_client = ODBFactory::create(user, pswd, db, host, port, char_set, conn_pool_count);
        }
        // 构造redis客户端对象
        void make_redis_object(const std::string &host,
                               int port,
                               int db,
                               bool keep_alive)
        {
            _redis_client = RedisClientFactory::create(host, port, db, keep_alive);
        }

        // 用于构造服务发现客户端&信道管理对象
        void make_discovery_object(const std::string &reg_host,
                                   const std::string &base_service_name,
                                   const std::string &file_service_name)
        {
            _file_service_name = file_service_name;
            _service_manager = std::make_shared<ServiceManager>();
            _service_manager->concern(file_service_name);
            LOG_DEBUG("将文件子服务 {} 设置为“关心”", file_service_name);
            auto put_cb = std::bind(&ServiceManager::when_service_online, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            auto del_cb = std::bind(&ServiceManager::when_service_offline, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            _service_discoverer = std::make_shared<Discovery>(reg_host, base_service_name, put_cb, del_cb);
        }

        // 用于构造服务注册客户端对象
        void make_registry_object(const std::string &reg_host,
                                  const std::string &service_name,
                                  const std::string &access_host)
        {
            _registry_client = std::make_shared<Registry>(reg_host);
            _registry_client->registry(service_name, access_host);
            _service_manager->concern(service_name);
        }
        void make_rpc_server(uint16_t port, int32_t timeout, uint8_t num_threads)
        {
            if (!_es_client)
            {
                LOG_ERROR("还未初始化ES搜索引擎模块！");
                abort();
            }
            if (!_mysql_client)
            {
                LOG_ERROR("还未初始化Mysql数据库模块！");
                abort();
            }
            if (!_redis_client)
            {
                LOG_ERROR("还未初始化Redis数据库模块！");
                abort();
            }
            if (!_service_manager)
            {
                LOG_ERROR("还未初始化信道管理模块！");
                abort();
            }
            if (!_dms_client)
            {
                LOG_ERROR("还未初始化短信平台模块！");
                abort();
            }
            _rpc_server = std::make_shared<brpc::Server>();

            UserServiceImpl *user_service = new UserServiceImpl(_dms_client, _es_client,
                                                                _mysql_client, _redis_client,
                                                                _service_manager, _file_service_name);
            int ret = _rpc_server->AddService(user_service,
                                              brpc::ServiceOwnership::SERVER_OWNS_SERVICE);
            if (ret == -1) {
                LOG_ERROR("添加Rpc服务失败！");
                abort();
            }
            brpc::ServerOptions options;
            options.idle_timeout_sec = timeout;
            options.num_threads = num_threads;
            ret = _rpc_server->Start(port, &options);
            if (ret == -1)
            {
                LOG_ERROR("服务启动失败！");
                abort();
            }
        }
        // 构造RPC服务器对象
        UserServer::ptr build()
        {
            if (!_service_discoverer)
            {
                LOG_ERROR("还未初始化服务发现模块！");
                abort();
            }
            if (!_registry_client)
            {
                LOG_ERROR("还未初始化服务注册模块！");
                abort();
            }
            if (!_rpc_server)
            {
                LOG_ERROR("还未初始化RPC服务器模块！");
                abort();
            }
            UserServer::ptr server = std::make_shared<UserServer>(
                _service_discoverer, _registry_client,
                _es_client, _mysql_client, _redis_client, _rpc_server);
            return server;
        }
    };
}

--- FILE: 3.User_Server/source/user_server.cc ---
内容:
//主要实现语音识别子服务的服务器的搭建
#include "user_server.hpp"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(registry_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(instance_name, "/user_service/instance1", "当前实例名称");
DEFINE_string(access_host, "127.0.0.1:10003", "当前实例的外部访问地址");

DEFINE_int32(listen_port, 10003, "Rpc服务器监听端口");
DEFINE_int32(rpc_timeout, -1, "Rpc调用超时时间");
DEFINE_int32(rpc_threads, 1, "Rpc的IO线程数量");


DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(file_service, "/service/file_service", "文件管理子服务名称");

DEFINE_string(es_host, "http://127.0.0.1:9200/", "ES搜索引擎服务器URL");

DEFINE_string(mysql_host, "127.0.0.1", "Mysql服务器访问地址");
DEFINE_string(mysql_user, "chen", "Mysql服务器访问用户名");
DEFINE_string(mysql_pswd, "Cydia4384!", "Mysql服务器访问密码");
DEFINE_string(mysql_db, "chen_im", "Mysql默认库名称");
DEFINE_string(mysql_cset, "utf8", "Mysql客户端字符集");
DEFINE_int32(mysql_access_port, 0, "Mysql服务器访问端口");
DEFINE_int32(mysql_pool_count, 4, "Mysql连接池最大连接数量");


DEFINE_string(redis_host, "127.0.0.1", "Redis服务器访问地址");
DEFINE_int32(redis_port, 6379, "Redis服务器访问端口");
DEFINE_int32(redis_db, 0, "Redis默认库号");
DEFINE_bool(redis_keep_alive, true, "Redis长连接保活选项");


DEFINE_string(dms_key_id, "LTAI5t6g1JUbGQR8UQTRuJ2J", "短信平台密钥ID");
DEFINE_string(dms_key_secret, "0wNotLkLPyv581BHDTAFZoeCbZrgit", "短信平台密钥");

// LTAI5t6g1JUbGQR8UQTRuJ2J
// 0wNotLkLPyv581BHDTAFZoeCbZrgit

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    chen_im::UserServerFactory usb;
    usb.make_dms_object(FLAGS_dms_key_id, FLAGS_dms_key_secret);
    usb.make_es_object({FLAGS_es_host});
    usb.make_mysql_object(FLAGS_mysql_user, FLAGS_mysql_pswd, FLAGS_mysql_host, 
        FLAGS_mysql_db, FLAGS_mysql_cset, FLAGS_mysql_access_port, FLAGS_mysql_pool_count);
    usb.make_redis_object(FLAGS_redis_host, FLAGS_redis_port, FLAGS_redis_db, FLAGS_redis_keep_alive);
    usb.make_discovery_object(FLAGS_registry_host, FLAGS_base_service, FLAGS_file_service);
    usb.make_rpc_server(FLAGS_listen_port, FLAGS_rpc_timeout, FLAGS_rpc_threads);
    usb.make_registry_object(FLAGS_registry_host, FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);
    auto server = usb.build();
    server->start();
    return 0;
}

--- FILE: 4.Message_Transmit_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 1. 添加cmake版本说明
cmake_minimum_required(VERSION 3.1.3)
# 2. 声明工程名称
project(transmite_server)
set(CMAKE_CXX_STANDARD 17)

set(target "message_transmit_server")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# 3. 检测并生成ODB框架代码
#   1. 添加所需的proto映射代码文件名称
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files base.proto user.proto message_transmit.proto)
#   2. 检测框架代码文件是否已经生成
set(proto_hxx "")
set(proto_cxx "")
set(proto_srcs "")
foreach(proto_file ${proto_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file})
    string(REPLACE ".proto" ".pb.h" proto_hh  ${proto_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc
            ARGS --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成Protobuf框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 3. 检测并生成ODB框架代码
#   1. 添加所需的odb映射代码文件名称
set(odb_path ${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
set(odb_files chat_session_member.hxx)
#   2. 检测框架代码文件是否已经生成
set(odb_hxx "")
set(odb_cxx "")
set(odb_srcs "")
foreach(odb_file ${odb_files})
#   3. 如果没有生成，则预定义生成指令 -- 用于在构建项目之间先生成框架代码
    string(REPLACE ".hxx" "-odb.hxx" odb_hxx ${odb_file})
    string(REPLACE ".hxx" "-odb.cxx" odb_cxx ${odb_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}${odb_cxx})
        add_custom_command(
            PRE_BUILD
            COMMAND odb
            ARGS -d mysql --std c++11 --generate-query --generate-schema --profile boost/date-time ${odb_path}/${odb_file}
            DEPENDS ${odb_path}/${odb_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
            COMMENT "生成ODB框架代码文件:" ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
        )
    endif()
#   4. 将所有生成的框架源码文件名称保存起来 student-odb.cxx classes-odb.cxx
    list(APPEND odb_srcs ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
endforeach()

# 4. 获取源码目录下的所有源码文件
set(src_files "")
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/source src_files)
# 5. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs} ${odb_srcs})
# 7. 设置需要连接的库
target_link_libraries(${target} -lgflags 
    -lspdlog -lfmt -lbrpc -lssl -lcrypto 
    -lprotobuf -lleveldb -letcd-cpp-api 
    -lcpprest -lcurl -lodb-mysql -lodb -lodb-boost
    -lamqpcpp -lev -lpthread
    -ldl)


set(trans_user_client "trans_user_client")
set(trans_user_files ${CMAKE_CURRENT_SOURCE_DIR}/test/user_client.cc)
add_executable(${trans_user_client} ${trans_user_files} ${proto_srcs})
target_link_libraries(${trans_user_client} -pthread -lgtest -lgflags -lspdlog -lfmt -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19 -lpthread -ldl)

set(transmite_client "transmite_client")
set(transmite_files ${CMAKE_CURRENT_SOURCE_DIR}/test/transmite_client.cc)
add_executable(${transmite_client} ${transmite_files} ${proto_srcs})
target_link_libraries(${transmite_client} -pthread -lgtest -lgflags -lspdlog -lfmt -lbrpc -lssl -lcrypto -lprotobuf -lleveldb -letcd-cpp-api -lcpprest -lcurl /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19 -lpthread -ldl)


# 6. 设置头文件默认搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Third-party)

#8. 设置安装路径
INSTALL(TARGETS ${target} ${trans_user_client} ${transmite_client} RUNTIME DESTINATION bin)

--- FILE: 4.Message_Transmit_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/message_transmit_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./message_transmit_server.conf /im/conf

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/message_transmit_server -flagfile=/im/conf/message_transmit_server.conf

--- FILE: 4.Message_Transmit_Server/message_transmit_server.conf ---
内容:
-run_mode            = false                              # 程序的运行模式，false-调试； true-发布；
-log_file            = /im/logs/message_transmit_server.log    # 发布模式下，用于指定日志的输出文件
-log_level           = 0                                  # 发布模式下，用于指定日志输出等级
-registry_host       = http://127.0.0.1:2379              # 服务注册中心地址
-instance_name       = /message_transmit_service/instance # 当前实例名称
-access_host         = 127.0.0.1:10004                    # 当前实例的外部访问地址
-listen_port         = 10004                              # Rpc服务器监听端口
-rpc_timeout         = -1                                 # Rpc调用超时时间
-rpc_threads         = 1                                  # Rpc的IO线程数量
-base_service        = /service                           # 服务监控根目录
-user_service        = /service/user_service              # 用户管理子服务名称
-mysql_host          = 127.0.0.1                          # Mysql服务器访问地址
-mysql_user          = root                               # Mysql服务器访问用户名
-mysql_pswd          = Cydia4384!                         # Mysql服务器访问密码
-mysql_db            = root_im                            # Mysql默认库名称
-mysql_cset          = utf8                               # Mysql客户端字符集
-mysql_access_port   = 0                                  # Mysql服务器访问端口
-mysql_pool_count    = 4                                  # Mysql连接池最大连接数量
-mq_user             = root                               # 消息队列服务器访问用户名
-mq_pswd             = czhuowen                           # 消息队列服务器访问密码
-mq_host             = 127.0.0.1:5672                     # 消息队列服务器访问地址
-mq_msg_exchange     = msg_exchange                       # 持久化消息的发布交换机名称
-mq_msg_queue        = msg_queue                          # 持久化消息的发布队列名称
-mq_msg_binding_key  = msg_queue                          # 持久化消息的发布队列名称

--- FILE: 4.Message_Transmit_Server/chat_session_member.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

USE `chen_im`;

DROP TABLE IF EXISTS `chat_session_member`;

CREATE TABLE `chat_session_member` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `chat_session_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE INDEX `session_id_i`
  ON `chat_session_member` (`session_id`);



--- FILE: 4.Message_Transmit_Server/test/transmite_client.cc ---
内容:
//speech_server的测试客户端实现
//1. 进行服务发现--发现speech_server的服务器节点地址信息并实例化的通信信道
//2. 读取语音文件数据
//3. 发起语音识别RPC调用

#include "etcd.hpp"
#include "rpc_service_manager.hpp"
#include "utility.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <thread>
#include "message_transmit.pb.h"


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(message_transmit_service, "/service/message_transmit_service", "服务监控根目录");

chen_im::ServiceManager::ptr sm;

void string_message(const std::string &uid, const std::string &sid, const std::string &msg) {
    auto channel = sm->get(FLAGS_message_transmit_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgTransmitService_Stub stub(channel.get());
    chen_im::NewMessageReq req;
    chen_im::GetTransmitTargetRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid);
    req.set_chat_session_id(sid);
    req.mutable_message()->set_message_type(chen_im::MessageType::STRING);
    req.mutable_message()->mutable_string_message()->set_content(msg);
    brpc::Controller cntl;
    stub.GetTransmitTarget(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}
void image_message(const std::string &uid, const std::string &sid, const std::string &msg) {
    auto channel = sm->get(FLAGS_message_transmit_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgTransmitService_Stub stub(channel.get());
    chen_im::NewMessageReq req;
    chen_im::GetTransmitTargetRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid);
    req.set_chat_session_id(sid);
    req.mutable_message()->set_message_type(chen_im::MessageType::IMAGE);
    req.mutable_message()->mutable_image_message()->set_image_content(msg);
    brpc::Controller cntl;
    stub.GetTransmitTarget(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

void speech_message(const std::string &uid, const std::string &sid, const std::string &msg) {
    auto channel = sm->get(FLAGS_message_transmit_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgTransmitService_Stub stub(channel.get());
    chen_im::NewMessageReq req;
    chen_im::GetTransmitTargetRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid);
    req.set_chat_session_id(sid);
    req.mutable_message()->set_message_type(chen_im::MessageType::SPEECH);
    req.mutable_message()->mutable_speech_message()->set_file_contents(msg);
    brpc::Controller cntl;
    stub.GetTransmitTarget(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

void file_message(const std::string &uid, const std::string &sid, 
    const std::string &filename, const std::string &content) {
    auto channel = sm->get(FLAGS_message_transmit_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgTransmitService_Stub stub(channel.get());
    chen_im::NewMessageReq req;
    chen_im::GetTransmitTargetRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid);
    req.set_chat_session_id(sid);
    req.mutable_message()->set_message_type(chen_im::MessageType::FILE);
    req.mutable_message()->mutable_file_message()->set_file_contents(content);
    req.mutable_message()->mutable_file_message()->set_file_name(filename);
    req.mutable_message()->mutable_file_message()->set_file_size(content.size());
    brpc::Controller cntl;
    stub.GetTransmitTarget(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

TEST(case1, test1)
{
    //1. 先构造Rpc信道管理对象
    sm = std::make_shared<chen_im::ServiceManager>();
    sm->concern(FLAGS_message_transmit_service);
    sm->concern("/service/user_service");
    auto put_cb = std::bind(&chen_im::ServiceManager::when_service_online, sm.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&chen_im::ServiceManager::when_service_offline, sm.get(), std::placeholders::_1, std::placeholders::_2);
    
    //2. 构造服务发现对象
    chen_im::Discovery::ptr dclient = std::make_shared<chen_im::Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    
    //3. 通过Rpc信道管理对象，获取提供Echo服务的信道
    string_message("uid1", "会话ID1", "吃饭了吗？");
    string_message("uid1", "会话ID1", "吃的盖浇饭！！");
    image_message("uid2", "会话ID1", "可爱表情图片数据");
    speech_message("uid2", "会话ID1", "动听猪叫声数据");
    file_message("uid1", "uid2", "猪爸爸的文件名称", "猪爸爸的文件数据");
    std::cout << "finished....." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(600));
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    testing::InitGoogleTest();
    RUN_ALL_TESTS();


    return 0;
}

--- FILE: 4.Message_Transmit_Server/test/user_client.cc ---
内容:
#include "etcd.hpp"
#include "rpc_service_manager.hpp"
#include "utility.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <thread>
#include "user.pb.h"
#include "base.pb.h"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(user_service, "/service/user_service", "服务监控根目录");

chen_im::ServiceManager::ptr user_channels;
void reg_user(const std::string &nickname, const std::string &pswd) {
    auto channel = user_channels->get(FLAGS_user_service);//获取通信信道
    ASSERT_TRUE(channel);

    chen_im::UserRegisterReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.set_nickname(nickname);
    req.set_password(pswd);

    chen_im::UserRegisterRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());
    stub.UserRegister(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

void set_user_avatar(const std::string &uid, const std::string &avatar) {
    auto channel = user_channels->get(FLAGS_user_service);//获取通信信道
    ASSERT_TRUE(channel);
    chen_im::SetUserAvatarReq req;
    req.set_request_id(chen_im::generate_uuid());
    req.set_user_id(uid);
    req.set_session_id("测试登录会话ID");
    req.set_avatar(avatar);
    chen_im::SetUserAvatarRsp rsp;
    brpc::Controller cntl;
    chen_im::UserService_Stub stub(channel.get());
    stub.SetUserAvatar(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    user_channels = std::make_shared<chen_im::ServiceManager>();

    user_channels->concern(FLAGS_user_service);
    auto put_cb = std::bind(&chen_im::ServiceManager::when_service_online, user_channels.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&chen_im::ServiceManager::when_service_offline, user_channels.get(), std::placeholders::_1, std::placeholders::_2);
    
    //2. 构造服务发现对象
    chen_im::Discovery::ptr dclient = std::make_shared<chen_im::Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    
    reg_user("小猪佩奇", "123456");
    reg_user("小猪乔治", "123456");
    std::string uid1, uid2;
    std::cout << "输入佩奇用户ID：";
    std::fflush(stdout);
    std::cin >> uid1;
    std::cout << "输入乔治用户ID：";
    std::fflush(stdout);
    std::cin >> uid2;
    set_user_avatar("731f-50086884-0000", "猪爸爸头像数据");
    set_user_avatar("c4dc-68239a9a-0001", "猪妈妈头像数据");
    return 0;
}

--- FILE: 4.Message_Transmit_Server/test/mysql_test/main.cc ---
内容:
#include "../../../common/data_mysql.hpp"
// #include "../../../odb/chat_session_member.hxx"
// #include "chat_session_member-odb.hxx"
#include <gflags/gflags.h>


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

void append_test(chen_im::ChatSessionMemeberTable &tb) {
    chen_im::ChatSessionMember csm1("会话ID1", "用户ID1");
    tb.append(csm1);
    chen_im::ChatSessionMember csm2("会话ID1", "用户ID2");
    tb.append(csm2);
    chen_im::ChatSessionMember csm3("会话ID2", "用户ID3");
    tb.append(csm3);
}

void multi_append_test(chen_im::ChatSessionMemeberTable &tb) {
    chen_im::ChatSessionMember csm1("会话ID3", "用户ID1");
    chen_im::ChatSessionMember csm2("会话ID3", "用户ID2");
    chen_im::ChatSessionMember csm3("会话ID3", "用户ID3");
    std::vector<chen_im::ChatSessionMember> list = {csm1, csm2, csm3};
    tb.append(list);
}

void remove_test(chen_im::ChatSessionMemeberTable &tb) {
    chen_im::ChatSessionMember csm3("会话ID2", "用户ID3");
    tb.remove(csm3);
}

void ss_members(chen_im::ChatSessionMemeberTable &tb) {
    auto res = tb.members("会话ID1");
    for (auto &id : res) {
        std::cout << id << std::endl;
    }
}
void remove_all(chen_im::ChatSessionMemeberTable &tb) {
    tb.remove("会话ID3");
}


int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    auto db = chen_im::ODBFactory::create("root", "123456", "127.0.0.1", "chen_im", "utf8", 0, 1);
    
    chen_im::ChatSessionMemeberTable csmt(db);
    //append_test(csmt);
    // multi_append_test(csmt);
    // remove_test(csmt);
    // ss_members(csmt);
    remove_all(csmt);
    return 0;
}

--- FILE: 4.Message_Transmit_Server/test/mysql_test/chat_session_member.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */
USE chen_im;

DROP TABLE IF EXISTS `chat_session_member`;

CREATE TABLE `chat_session_member` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `session_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL)
 ENGINE=InnoDB;

CREATE INDEX `session_id_i`
  ON `chat_session_member` (`session_id`);



--- FILE: 4.Message_Transmit_Server/test/mysql_test/Makefile ---
内容:
main : main.cc chat_session_member-odb.cxx user-odb.cxx
	c++ -std=c++17 $^ -o $@ -I../../../odb/ -I./  -lodb-mysql -lodb -lodb-boost -lfmt -lspdlog -lgflags
%.cxx:
	odb -d mysql --std c++11 --generate-query --generate-schema --profile boost/date-time ../../../odb/*.hxx

--- FILE: 4.Message_Transmit_Server/test/mysql_test/user.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */
USE chen_im;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL,
  `nickname` varchar(64) NULL,
  `description` TEXT NULL,
  `password` varchar(64) NULL,
  `phone` varchar(64) NULL,
  `avatar_id` varchar(64) NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `user_id_i`
  ON `user` (`user_id`);

CREATE UNIQUE INDEX `nickname_i`
  ON `user` (`nickname`);

CREATE UNIQUE INDEX `phone_i`
  ON `user` (`phone`);



--- FILE: 4.Message_Transmit_Server/source/message_transmit_server.hpp ---
内容:
#pragma once
#include <brpc/server.h>
#include <butil/logging.h>
#include <time.h>
#include <unistd.h>
#include <fstream>


#include "etcd.hpp"   // 服务注册模块封装
#include "logger.hpp" // 日志模块封装
#include "rabbitmq.hpp"
#include "rpc_service_manager.hpp"
#include "utility.hpp"
#include "mysql_chat_session_member.hpp"

#include "base.pb.h"             // protobuf框架代码
#include "user.pb.h"             // protobuf框架代码
#include "message_transmit.pb.h" // protobuf框架代码

namespace chen_im
{
    class TransmiteServiceImpl : public chen_im::MsgTransmitService
    {
    private:
        // 用户子服务调用相关信息
        std::string _user_service_name;
        ServiceManager::ptr _service_manager;

        // 聊天会话成员表的操作句柄
        ChatSessionMemeberTable::ptr _mysql_session_member_table;

        // 消息队列客户端句柄
        std::string _exchange_name;
        std::string _routing_key;
        MQClient::ptr _mq_client;
    public:
        TransmiteServiceImpl(const std::string &user_service_name,
                             const ServiceManager::ptr &channels,
                             const std::shared_ptr<odb::mysql::database> &mysql_client,
                             const std::string &exchange_name,
                             const std::string &routing_key,
                             const MQClient::ptr &mq_client)
            : _user_service_name(user_service_name),
              _service_manager(channels),
              _mysql_session_member_table(std::make_shared<ChatSessionMemeberTable>(mysql_client)),
              _exchange_name(exchange_name),
              _routing_key(routing_key),
              _mq_client(mq_client) 
        {}
        ~TransmiteServiceImpl() {}

        // 获取消息的转发目标，实际上是根据发来的用户id，和chat_session_id来
        // 向MySQL获取用户所在的聊天会话下的所有成员id
        void GetTransmitTarget(google::protobuf::RpcController *controller,
                               const ::chen_im::NewMessageReq *request,
                               ::chen_im::GetTransmitTargetRsp *response,
                               ::google::protobuf::Closure *done) override
        {
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 从请求中获取关键信息：用户ID，所属会话ID，消息内容
            std::string request_id = request->request_id();
            std::string uid = request->user_id();
            std::string chat_ssid = request->chat_session_id();
            const MessageContent &content = request->message();

            // 2. 进行消息组织：从用户子服务获取发送者的信息，所属会话，消息内容，产生时间，消息ID
            // 因为请求体中只提供了用户ID，所以调用用户子服务获取消息发送者的完整信息
            auto channel = _service_manager->get(_user_service_name);
            if (!channel) {
                LOG_ERROR("没有可供访问的用户子服务 {} 的节点！", _user_service_name);
                return err_response(request_id, "没有可供访问的用户子服务节点！");
            }

            UserService_Stub stub(channel.get());
            GetUserInfoReq req;
            GetUserInfoRsp rsp;
            req.set_request_id(request_id);
            req.set_user_id(uid);
            brpc::Controller cntl;
            stub.GetUserInfo(&cntl, &req, &rsp, nullptr); // 调用
            if (cntl.Failed() == true || rsp.success() == false) {
                LOG_ERROR("用户子服务调用失败，原因：{}，request_id: {}！", cntl.ErrorText(), request->request_id());
                return err_response(request->request_id(), "用户子服务调用失败!");
            }
            MessageInfo message_info;
            message_info.set_message_id(generate_uuid());
            message_info.set_chat_session_id(chat_ssid);
            message_info.set_timestamp(::time(nullptr));
            message_info.mutable_sender()->CopyFrom(rsp.user_info());
            message_info.mutable_message()->CopyFrom(content);

            // 3. 获取消息转发的用户列表（本质是查询这个聊天会话下除了自己以外的所有成员）
            auto target_list = _mysql_session_member_table->get_members(chat_ssid);
            
            // 4. 将封装完毕的消息，发布到消息队列，待消息存储子服务进行消息持久化
            std::string message_info_serialized;
            message_info.SerializeToString(&message_info_serialized);
            bool ret = _mq_client->publish_message(_exchange_name, message_info_serialized, _routing_key);
            if (ret == false) {
                LOG_ERROR("向消息队列发布消息失败失败，原因：{}，request_id: {}！", cntl.ErrorText(), request->request_id());
                return err_response(request->request_id(), "无法向消息队列发布一条聊天消息!");
            } else {
                LOG_DEBUG("向消息队列发布消息成功，将message_info写入文件buglog.bin");
                std::ofstream bug("./buglog_producer.bin", std::ios::binary);
                bug << message_info_serialized;
                bug.flush();
                bug.close();
            }

            // 5. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            response->mutable_message()->CopyFrom(message_info);
            for (const auto &id : target_list) {
                response->add_target_id_list(id);
            }
        }
    };

    class TransmiteServer
    {
    public:
        using ptr = std::shared_ptr<TransmiteServer>;
        TransmiteServer(
            const std::shared_ptr<odb::mysql::database> &mysql_client,
            const Discovery::ptr discovery_client,
            const Registry::ptr &registry_client,
            const std::shared_ptr<brpc::Server> &server) : _service_discoverer(discovery_client),
                                                           _registry_client(registry_client),
                                                           _mysql_client(mysql_client),
                                                           _rpc_server(server) {}
        ~TransmiteServer() {}
        // 搭建RPC服务器，并启动服务器
        void start()
        {
            _rpc_server->RunUntilAskedToQuit();
        }

    private:
        Discovery::ptr _service_discoverer;                  // 服务发现客户端
        Registry::ptr _registry_client;                      // 服务注册客户端
        std::shared_ptr<odb::mysql::database> _mysql_client; // mysql数据库客户端
        std::shared_ptr<brpc::Server> _rpc_server;
    };

    class TransmiteServerFactory
    {
    public:
        // 构造mysql客户端对象
        void make_mysql_object(
            const std::string &user,
            const std::string &pswd,
            const std::string &host,
            const std::string &db,
            const std::string &cset,
            int port,
            int conn_pool_count)
        {
            _mysql_client = ODBFactory::create(user, pswd, db, host, port, cset, conn_pool_count);
        }
        // 用于构造服务发现客户端&信道管理对象
        void make_discovery_object(const std::string &reg_host,
                                   const std::string &base_service_name,
                                   const std::string &user_service_name)
        {
            _user_service_name = user_service_name;
            _service_manager = std::make_shared<ServiceManager>();
            _service_manager->concern(user_service_name);
            _service_manager->concern("/service/message_transmit_service"); // bug
            LOG_DEBUG("设置用户子服务为需关心的子服务：{}", user_service_name);
            auto put_cb = std::bind(&ServiceManager::when_service_online, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            auto del_cb = std::bind(&ServiceManager::when_service_offline, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            _service_discoverer = std::make_shared<Discovery>(reg_host, base_service_name, put_cb, del_cb);
        }
        // 用于构造服务注册客户端对象
        void make_registry_object(const std::string &reg_host,
                                  const std::string &service_name,
                                  const std::string &access_host)
        {
            _registry_client = std::make_shared<Registry>(reg_host);
            _registry_client->registry(service_name, access_host);
        }
        // 用于构造rabbitmq客户端对象
        void make_mq_object(const std::string &user,
                            const std::string &passwd,
                            const std::string &host,
                            const std::string &exchange_name,
                            const std::string &queue_name,
                            const std::string &binding_key)
        {
            _routing_key = binding_key;
            _exchange_name = exchange_name;
            _mq_client = std::make_shared<MQClient>(user, passwd, host);
            _mq_client->declear_all_components(exchange_name, queue_name, binding_key);
        }
        // 构造RPC服务器对象
        void make_rpc_server(uint16_t port, int32_t timeout, uint8_t num_threads)
        {
            if (!_mq_client)
            {
                LOG_ERROR("还未初始化消息队列客户端模块！");
                abort();
            }
            if (!_service_manager)
            {
                LOG_ERROR("还未初始化信道管理模块！");
                abort();
            }
            if (!_mysql_client)
            {
                LOG_ERROR("还未初始化Mysql数据库模块！");
                abort();
            }

            _rpc_server = std::make_shared<brpc::Server>();

            TransmiteServiceImpl *message_transmit_service = new TransmiteServiceImpl(
                _user_service_name, _service_manager, _mysql_client, _exchange_name, _routing_key, _mq_client);

            int ret = _rpc_server->AddService(message_transmit_service,
                                              brpc::ServiceOwnership::SERVER_OWNS_SERVICE);
            if (ret == -1)
            {
                LOG_ERROR("添加Rpc服务失败！");
                abort();
            }
            brpc::ServerOptions options;
            options.idle_timeout_sec = timeout;
            options.num_threads = num_threads;
            ret = _rpc_server->Start(port, &options);
            if (ret == -1)
            {
                LOG_ERROR("服务启动失败！");
                abort();
            }
        }
        TransmiteServer::ptr build()
        {
            if (!_service_discoverer)
            {
                LOG_ERROR("还未初始化服务发现模块！");
                abort();
            }
            if (!_registry_client)
            {
                LOG_ERROR("还未初始化服务注册模块！");
                abort();
            }
            if (!_rpc_server)
            {
                LOG_ERROR("还未初始化RPC服务器模块！");
                abort();
            }
            TransmiteServer::ptr server = std::make_shared<TransmiteServer>(
                _mysql_client, _service_discoverer, _registry_client, _rpc_server);
            return server;
        }

    private:
        std::string _user_service_name;
        ServiceManager::ptr _service_manager; // Discovery的初识化依赖它，TransmiteServiceImpl也需要它，因为要调用别的rpc服务
        Discovery::ptr _service_discoverer;

        std::string _routing_key;
        std::string _exchange_name;
        MQClient::ptr _mq_client;

        Registry::ptr _registry_client;                      // 服务注册客户端
        std::shared_ptr<odb::mysql::database> _mysql_client; // mysql数据库客户端
        std::shared_ptr<brpc::Server> _rpc_server;           // rpc服务器
    };
}

--- FILE: 4.Message_Transmit_Server/source/message_transmit_server.cc ---
内容:
//主要实现语音识别子服务的服务器的搭建
#include "message_transmit_server.hpp"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(registry_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(instance_name, "/message_transmit_service/instance", "当前实例名称");
DEFINE_string(access_host, "127.0.0.1:10004", "当前实例的外部访问地址");

DEFINE_int32(listen_port, 10004, "Rpc服务器监听端口");
DEFINE_int32(rpc_timeout, -1, "Rpc调用超时时间");
DEFINE_int32(rpc_threads, 1, "Rpc的IO线程数量");

DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(user_service, "/service/user_service", "用户管理子服务名称");

DEFINE_string(mysql_host, "127.0.0.1", "Mysql服务器访问地址");
DEFINE_string(mysql_user, "chen", "Mysql服务器访问用户名");
DEFINE_string(mysql_pswd, "Cydia4384!", "Mysql服务器访问密码");
DEFINE_string(mysql_db, "chen_im", "Mysql默认库名称");
DEFINE_string(mysql_cset, "utf8", "Mysql客户端字符集");
DEFINE_int32(mysql_access_port, 0, "Mysql服务器访问端口");
DEFINE_int32(mysql_pool_count, 4, "Mysql连接池最大连接数量");

DEFINE_string(mq_user, "chen", "消息队列服务器访问用户名");
DEFINE_string(mq_pswd, "czhuowen", "消息队列服务器访问密码");
DEFINE_string(mq_host, "127.0.0.1:5672", "消息队列服务器访问地址");
DEFINE_string(mq_msg_exchange, "msg_exchange", "持久化消息的发布交换机名称");
DEFINE_string(mq_msg_queue, "msg_queue", "持久化消息的发布队列名称");
DEFINE_string(mq_msg_binding_key, "msg_queue", "持久化消息的发布队列名称");


int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    chen_im::TransmiteServerFactory tsb;
    tsb.make_mq_object(FLAGS_mq_user, FLAGS_mq_pswd, FLAGS_mq_host,
        FLAGS_mq_msg_exchange, FLAGS_mq_msg_queue, FLAGS_mq_msg_binding_key);
    tsb.make_mysql_object(FLAGS_mysql_user, FLAGS_mysql_pswd, FLAGS_mysql_host, 
        FLAGS_mysql_db, FLAGS_mysql_cset, FLAGS_mysql_access_port, FLAGS_mysql_pool_count);
    tsb.make_discovery_object(FLAGS_registry_host, FLAGS_base_service, FLAGS_user_service);
    tsb.make_rpc_server(FLAGS_listen_port, FLAGS_rpc_timeout, FLAGS_rpc_threads);
    tsb.make_registry_object(FLAGS_registry_host, FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);
    auto server = tsb.build();
    server->start();
    return 0;
}

--- FILE: ODB/relation.hxx ---
内容:
#pragma once
#include <string>
#include <cstddef>
#include <odb/nullable.hxx>
#include <odb/core.hxx>

namespace chen_im
{
#pragma db object table("relation")
    class Relation
    {        
        friend class odb::access;
    public:
        Relation() {}
        Relation(const std::string &uid, const std::string &pid) : _user_id(uid), _peer_id(pid) {}

        std::string user_id() const { return _user_id; }
        void user_id(std::string &uid) { _user_id = uid; }

        std::string peer_id() const { return _peer_id; }
        void peer_id(std::string &uid) { _peer_id = uid; }

    private:
#pragma db id auto
        unsigned long _id;
#pragma db type("varchar(64)") index
        std::string _user_id; // 用户id
#pragma db type("varchar(64)")
        std::string _peer_id; // 该用户的好友的id
    };
    // odb -d mysql --std c++11 --generate-query --generate-schema --profile boost/date-time person.hxx
}

--- FILE: ODB/chat_session_member.hxx ---
内容:
// 聊天会话id 映射到 用户id
#pragma once
#include <string>
#include <cstddef>
#include <odb/core.hxx>

namespace chen_im
{
#pragma db object table("chat_session_member")
    class ChatSessionMember
    {
    public:
        ChatSessionMember() {}
        ChatSessionMember(const std::string &ssid, const std::string &uid) 
            : _chat_session_id(ssid), _user_id(uid) {}
        ~ChatSessionMember() {}

        std::string chat_session_id() const { return _chat_session_id; }
        void chat_session_id(std::string &ssid) { _chat_session_id = ssid; }

        std::string user_id() const { return _user_id; }
        void user_id(std::string &uid) { _user_id = uid; }

    private:
        friend class odb::access;
#pragma db id auto
        unsigned long _id;
#pragma db type("varchar(64)") index
        std::string _chat_session_id;
#pragma db type("varchar(64)")
        std::string _user_id;
    };
}



--- FILE: ODB/user.hxx ---
内容:
#pragma once
#include <string>
#include <cstddef> // std::size_t
#include <boost/date_time/posix_time/posix_time.hpp>
#include <odb/nullable.hxx>
#include <odb/core.hxx>

/* 在 C++ 中，要使用 ODB 将类声明为持久化类，
需要包含 ODB 的核心头文件，并使用 #pragma db object 指令 #pragma db object
指示 ODB 编译器将 person 类视为一个持久化类。 */

typedef boost::posix_time::ptime ptime;

#pragma db object table("user")
class User
{
    friend class odb::access;

private:
#pragma db id auto
    unsigned long _id;
#pragma db type("varchar(64)") index unique
    std::string _user_id;
#pragma db type("varchar(64)") index unique
    odb::nullable<std::string> _nickname;    // 用户昵称-不一定存在
    odb::nullable<std::string> _description; // 用户签名 - 不一定存在
#pragma db type("varchar(64)")
    odb::nullable<std::string> _password;    // 用户密码 - 不一定存在
#pragma db type("varchar(64)") index unique
    odb::nullable<std::string> _phone;       // 用户手机号 - 不一定存在
#pragma db type("varchar(64)")
    odb::nullable<std::string> _avatar_id;   // 用户头像文件ID - 不一定存在

public:
    // 用户名+密码注册
    User(const std::string &uid, const std::string &nickname, const std::string &password) : _user_id(uid), _nickname(nickname), _password(password) {}

    // 手机号+密码注册
    User(const std::string &uid, const std::string &phone) : _user_id(uid), _nickname(uid), _phone(phone) {}

    void user_id(const std::string &val)
    {
        _user_id = val;
    }
    std::string user_id() { return _user_id; }

    std::string nickname()
    {
        if (_nickname)
            return *_nickname;
        return std::string();
    }
    void nickname(const std::string &val) { _nickname = val; }

    std::string description()
    {
        if (!_description)
            return std::string();
        return *_description;
    }
    void description(const std::string &val) { _description = val; }

    std::string password()
    {
        if (!_password)
            return std::string();
        return *_password;
    }
    void password(const std::string &val) { _password = val; }

    std::string phone()
    {
        if (!_phone)
            return std::string();
        return *_phone;
    }
    void phone(const std::string &val) { _phone = val; }

    std::string avatar_id()
    {
        if (!_avatar_id)
            return std::string();
        return *_avatar_id;
    }
    void avatar_id(const std::string &val) { _avatar_id = val; }

    User() {}
    ~User() {}
};

// odb -d mysql --std c++17 --generate-query --generate-schema --profile boost/date-time user.hxx

--- FILE: ODB/chat_session.hxx ---
内容:
#pragma once
#include <string>
#include <cstddef>
#include <odb/nullable.hxx>
#include <odb/core.hxx>
#include "chat_session_member.hxx"

namespace chen_im
{
    enum class ChatSessionType
    {
        SINGLE = 1,
        GROUP = 2
    };

#pragma db object table("chat_session")
    class ChatSession
    {
    public:
        ChatSession() {}
        ChatSession(const std::string &ssid,
                    const std::string &ssname, const ChatSessionType sstype) : _chat_session_id(ssid),
                                                                               _chat_session_name(ssname),
                                                                               _chat_session_type(sstype) {}

        std::string chat_session_id() const { return _chat_session_id; }
        void chat_session_id(std::string &ssid) { _chat_session_id = ssid; }

        std::string chat_session_name() const { return _chat_session_name; }
        void chat_session_name(std::string &ssname) { _chat_session_name = ssname; }

        ChatSessionType chat_session_type() const { return _chat_session_type; }
        void chat_session_type(ChatSessionType val) { _chat_session_type = val; }

    private:
        friend class odb::access;
#pragma db id auto
        unsigned long _id;
#pragma db type("varchar(64)") index unique
        std::string _chat_session_id;
#pragma db type("varchar(64)")
        std::string _chat_session_name;
#pragma db type("tinyint")
        ChatSessionType _chat_session_type; // 1-单聊； 2-群聊
    };


// 这里条件必须是指定条件：  css::chat_session_type==1 && csm1.user_id=uid && csm2.user_id != csm1.user_id
// object() 用来描述如何将 C++ 类与数据库表关联起来 这里 ChatSession 是 C++ 类，css 是别名
// == 也可以定义连接条件
#pragma db view object(ChatSession = css)                                                     \
                object(ChatSessionMember = csm1 : css::_chat_session_id == csm1::_chat_session_id) \
                object(ChatSessionMember = csm2 : css::_chat_session_id == csm2::_chat_session_id) \
                query((?))
    struct SingleChatSession
    {
#pragma db column(css::_chat_session_id)
        std::string chat_session_id;
#pragma db column(csm2::_user_id)
        std::string friend_id; // 单聊的名称就是对方的昵称
    };

// 这里条件必须是指定条件：  css::chat_session_type==2 && csm.user_id=uid
#pragma db view object(ChatSession = css)                                                   \
                object(ChatSessionMember = csm : css::_chat_session_id == csm::_chat_session_id) \
                query((?))
    struct GroupChatSession
    {
#pragma db column(css::_chat_session_id)
        std::string chat_session_id;
#pragma db column(css::_chat_session_name)
        std::string chat_session_name;
    };
}

--- FILE: ODB/Makefile ---
内容:
# Compiler and flags
ODB_COMPILER = odb
CXX_STANDARD = --std c++17
DATABASE = -d mysql
OPTIONS = --generate-query --generate-schema --profile boost/date-time
OUTPUT_DIR = odb_builds

# Find all .hxx files in the current directory
SRC_FILES = $(wildcard *.hxx)

# Create the output directory if it doesn't exist
$(OUTPUT_DIR):
	mkdir -p $(OUTPUT_DIR)

# Rule to generate ODB files and move them directly to the output directory
$(OUTPUT_DIR)/%: %.hxx | $(OUTPUT_DIR)
	$(ODB_COMPILER) $(DATABASE) $(CXX_STANDARD) $(OPTIONS) $<
	mv $*-odb.cxx $*-odb.hxx $*-odb.ixx $*.sql $(OUTPUT_DIR)/

# Target to generate ODB files for all .hxx files
generate: $(SRC_FILES:%.hxx=$(OUTPUT_DIR)/%)

.PHONY: clean
clean:
	rm -rf $(OUTPUT_DIR)


--- FILE: ODB/message.hxx ---
内容:
#pragma once
#include <string>
#include <cstddef>
#include <odb/nullable.hxx>
#include <odb/core.hxx>
#include <boost/date_time/posix_time/posix_time.hpp>

namespace chen_im
{
    // 某个人，在某个聊天会话中，发送的消息
#pragma db object table("message")
    class Message
    {
        friend class odb::access; // odb要访问private成员
    private:
#pragma db id auto
        unsigned long _id;     
#pragma db type("varchar(64)") index unique
        std::string _message_id;                // 用于唯一标识一条消息
#pragma db type("varchar(64)") index column("session_id")
        std::string _session_id;                // 所属聊天会话ID
#pragma db type("varchar(64)")
        std::string _user_id;                   // 发送者用户ID
        unsigned char _message_type;            // 消息类型 0-文本；1-图片；2-文件；3-语音
#pragma db type("TIMESTAMP")
        boost::posix_time::ptime _create_time;  // 消息的产生时间
        odb::nullable<std::string> _content;    // 文本消息内容--非文本消息可以忽略
#pragma db type("varchar(64)")
        odb::nullable<std::string> _file_id;    // 文件消息的文件ID -- 文本消息忽略
#pragma db type("varchar(128)")
        odb::nullable<std::string> _file_name;  // 文件消息的文件名称 -- 只针对文件消息有效
        odb::nullable<unsigned int> _file_size; // 文件消息的文件大小 -- 只针对文件消息有效
    
    public:
        Message() {}
        Message(const std::string &mid,
                const std::string &ssid,
                const std::string &uid,
                const unsigned char mtype,
                const boost::posix_time::ptime &ctime) 
            : _message_id(mid), 
            _session_id(ssid),
            _user_id(uid), 
            _message_type(mtype),
            _create_time(ctime)
        {}

        // 接口

        std::string message_id() const { return _message_id; }
        void message_id(const std::string &val) { _message_id = val; }

        std::string session_id() const { return _session_id; }
        void session_id(const std::string &val) { _session_id = val; }

        std::string user_id() const { return _user_id; }
        void user_id(const std::string &val) { _user_id = val; }

        unsigned char message_type() const { return _message_type; }
        void message_type(unsigned char val) { _message_type = val; }

        boost::posix_time::ptime create_time() const { return _create_time; }
        void create_time(const boost::posix_time::ptime &val) { _create_time = val; }

        std::string content() const
        {
            if (!_content)
                return std::string();
            return *_content;
        }
        void content(const std::string &val) { _content = val; }

        std::string file_id() const
        {
            if (!_file_id)
                return std::string();
            return *_file_id;
        }
        void file_id(const std::string &val) { _file_id = val; }

        std::string file_name() const
        {
            if (!_file_name)
                return std::string();
            return *_file_name;
        }
        void file_name(const std::string &val) { _file_name = val; }

        unsigned int file_size() const
        {
            if (!_file_size)
                return 0;
            return *_file_size;
        }
        void file_size(unsigned int val) { _file_size = val; }
    };
    // odb -d mysql --std c++11 --generate-query --generate-schema --profile boost/date-time person.hxx
}

--- FILE: ODB/friend_apply.hxx ---
内容:
#pragma once
#include <string>
#include <cstddef>
#include <odb/core.hxx>

namespace chen_im
{
#pragma db object table("friend_apply")
    class FriendApply
    {
    public:
        FriendApply() {}
        FriendApply(const std::string &eid,
                    const std::string &uid, const std::string &pid) : _user_id(uid), _peer_id(pid), _event_id(eid) {}

        std::string event_id() const { return _event_id; }
        void event_id(std::string &eid) { _event_id = eid; }

        std::string user_id() const { return _user_id; }
        void user_id(std::string &uid) { _user_id = uid; }

        std::string peer_id() const { return _peer_id; }
        void peer_id(std::string &uid) { _peer_id = uid; }

    private:
        friend class odb::access;
#pragma db id auto
        unsigned long _id;
#pragma db type("varchar(64)") index unique
        std::string _event_id;
#pragma db type("varchar(64)") index
        std::string _user_id;
#pragma db type("varchar(64)") index
        std::string _peer_id;
    };
}

--- FILE: 5.Message_Store_Server/message_store_server.conf ---
内容:
-run_mode           = false                              # 程序的运行模式，false-调试； true-发布；
-log_file           = /im/logs/message_store_server.log  # 发布模式下，用于指定日志的输出文件
-log_level          = 0                                  # 发布模式下，用于指定日志输出等级
-registry_host      = http://127.0.0.1:2379           # 服务注册中心地址
-instance_name      = /message_store_service/instance1 # 当前实例名称
-access_host        = 127.0.0.1:10005                  # 当前实例的外部访问地址
-listen_port        = 10005                              # Rpc服务器监听端口
-rpc_timeout        = -1                                 # Rpc调用超时时间
-rpc_threads        = 1                                  # Rpc的IO线程数量
-base_service       = /service                         # 服务监控根目录
-file_service       = /service/file_service            # 文件管理子服务名称
-user_service       = /service/user_service            # 用户管理子服务名称
-es_host            = http://127.0.0.1:9200/           # ES搜索引擎服务器URL
-mysql_host         = 127.0.0.1                        # Mysql服务器访问地址
-mysql_user         = root                             # Mysql服务器访问用户名
-mysql_pswd         = Cydia4384!                       # Mysql服务器访问密码
-mysql_db           = root_im                          # Mysql默认库名称
-mysql_cset         = utf8                             # Mysql客户端字符集
-mysql_access_port  = 0                                  # Mysql服务器访问端口
-mysql_pool_count   = 4                                  # Mysql连接池最大连接数量
-mq_user            = root                             # 消息队列服务器访问用户名
-mq_pswd            = czhuowen                         # 消息队列服务器访问密码
-mq_host            = 127.0.0.1:5672                   # 消息队列服务器访问地址
-mq_msg_exchange    = msg_exchange                     # 持久化消息的发布交换机名称
-mq_msg_queue       = msg_queue                        # 持久化消息的发布队列名称
-mq_msg_binding_key = msg_queue                        # 持久化消息的发布队列名称

--- FILE: 5.Message_Store_Server/message.sql ---
内容:
/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

USE `chen_im`;

DROP TABLE IF EXISTS `message`;

CREATE TABLE `message` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `message_id` varchar(64) NOT NULL,
  `session_id` varchar(64) NOT NULL,
  `user_id` varchar(64) NOT NULL,
  `message_type` TINYINT UNSIGNED NOT NULL,
  `create_time` TIMESTAMP NULL,
  `content` TEXT NULL,
  `file_id` varchar(64) NULL,
  `file_name` varchar(128) NULL,
  `file_size` INT UNSIGNED NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `message_id_i`
  ON `message` (`message_id`);

CREATE INDEX `session_id_i`
  ON `message` (`session_id`);



--- FILE: 5.Message_Store_Server/CMakeLists.txt ---
内容:
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# 设置 CMake 最小版本
cmake_minimum_required(VERSION 3.1.3)

# 声明工程名称
project(message_server)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

set(target "message_store_server")
set(test_client "message_store_client")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# 1. 设置 Protobuf 文件
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../APIs)
set(proto_files base.proto user.proto file.proto message_storage.proto)
set(proto_srcs "")

foreach(proto_file ${proto_files})
    string(REPLACE ".proto" ".pb.cc" proto_cc ${proto_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
        add_custom_command(
            PRE_BUILD
            COMMAND protoc --cpp_out=${CMAKE_CURRENT_BINARY_DIR} -I ${proto_path} ${proto_path}/${proto_file}
            DEPENDS ${proto_path}/${proto_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
            COMMENT "生成 Protobuf 框架代码文件: ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}"
        )
    endif()
    list(APPEND proto_srcs ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

# 2. 设置 ODB 文件
set(odb_path ${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
set(odb_files message.hxx)
set(odb_srcs "")

foreach(odb_file ${odb_files})
    string(REPLACE ".hxx" "-odb.hxx" odb_hxx ${odb_file})
    string(REPLACE ".hxx" "-odb.cxx" odb_cxx ${odb_file})
    if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
        add_custom_command(
            PRE_BUILD
            COMMAND odb -d mysql --std c++17 --generate-query --generate-schema --profile boost/date-time ${odb_path}/${odb_file}
            DEPENDS ${odb_path}/${odb_file}
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}
            COMMENT "生成 ODB 框架代码文件: ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx}"
        )
    endif()
    list(APPEND odb_srcs ${CMAKE_CURRENT_BINARY_DIR}/${odb_cxx})
endforeach()

# 3. 获取源码目录下的所有源码文件
file(GLOB src_files "${CMAKE_CURRENT_SOURCE_DIR}/source/*.cc")

# 4. 声明目标及依赖
add_executable(${target} ${src_files} ${proto_srcs} ${odb_srcs})

# 5. 查找 Boost 库，指定需要的模块
find_package(Boost REQUIRED COMPONENTS date_time)

# 6. 设置需要链接的库
target_link_libraries(${target}
    -lgflags 
    -lspdlog 
    -lfmt 
    -lbrpc 
    -lssl 
    -lcrypto 
    -lprotobuf 
    -lleveldb 
    -letcd-cpp-api 
    -lcpprest 
    -lcurl 
    -lodb-mysql 
    -lodb 
    -lodb-boost
    /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
    -lcpr 
    -lelasticlient 
    -lamqpcpp 
    -lev 
    -lpthread 
    Boost::date_time
    -lgtest
    -ldl
)

# 7. 处理测试客户端
file(GLOB test_files "${CMAKE_CURRENT_SOURCE_DIR}/test/*.cc")
add_executable(${test_client} ${test_files} ${proto_srcs} ${odb_srcs})

target_link_libraries(${test_client}
    -lgflags 
    -lspdlog 
    -lfmt 
    -lbrpc 
    -lssl 
    -lcrypto 
    -lprotobuf 
    -lleveldb 
    -letcd-cpp-api 
    -lcpprest 
    -lcurl 
    -lodb-mysql 
    -lodb 
    -lodb-boost
    /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
    -lcpr 
    -lelasticlient 
    -lamqpcpp 
    -lev 
    -lpthread 
    Boost::date_time
    -lgtest
    -ldl
)

# 8. 设置头文件搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Common)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../ODB)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Third-party)

# 9. 设置安装路径
INSTALL(TARGETS ${target} ${test_client} RUNTIME DESTINATION bin)


--- FILE: 5.Message_Store_Server/dockerfile ---
内容:
# 基础镜像
FROM ubuntu:20.04

# 工作路径
WORKDIR /im
RUN mkdir -p /im/logs
RUN mkdir -p /im/data
RUN mkdir -p /im/conf
RUN mkdir -p /im/bin

# 将可执行文件拷贝到镜像中
COPY ./build/message_store_server /im/bin

# 将配置文件拷贝到镜像中
COPY ./message_store_server.conf /im/conf

# 将可执行程序的依赖拷贝到docker容器中的lib目录中
COPY ./build/depends /lib/x86_64-linux-gnu/

# 容器启动时直接启动服务进程，带上配置文件
CMD /im/bin/message_store_server -flagfile=/im/conf/message_store_server.conf

--- FILE: 5.Message_Store_Server/test/message_store_client.cc ---
内容:
#include "etcd.hpp"
#include "elasticsearch_user.hpp"
#include "mysql_message.hpp"
#include "mysql_odb_factory.hpp"
#include "rpc_service_manager.hpp"
#include "utility.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <thread>
#include <boost/date_time/posix_time/posix_time.hpp>
#include "message_storage.pb.h"
#include "base.pb.h"
#include "user.pb.h"


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(etcd_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(message_store_service, "/service/message_store_service", "");

DEFINE_string(es_host, "http://127.0.0.1:9200/", "es服务器URL");

chen_im::ServiceManager::ptr sm;

void init_es()
{
    auto es_client = chen_im::ESClientFactory::create({FLAGS_es_host});

    auto es_msg = std::make_shared<chen_im::ESMessage>(es_client);
    es_msg->create_index();
    es_msg->append_message("用户ID1", "消息ID1", 1723025035, "会话ID1", "吃饭了吗？");
    es_msg->append_message("用户ID2", "消息ID2", 1723025035 - 100, "会话ID1", "吃的盖浇饭！");
    es_msg->append_message("用户ID3", "消息ID3", 1723025035, "会话ID2", "吃饭了吗？");
    es_msg->append_message("用户ID4", "消息ID4", 1723025035 - 100, "会话ID2", "吃的盖浇饭！");
    
    auto res = es_msg->search("盖浇", "会话ID1");
    for (auto &u : res) {
        std::cout << "-----------------" << std::endl;
        std::cout << u.user_id() << std::endl;
        std::cout << u.message_id() << std::endl;
        std::cout << u.session_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(u.create_time()) << std::endl;
        std::cout << u.content() << std::endl;
    }
}

void init_mysql()
{
    auto db = chen_im::ODBFactory::create("chen", "Cydia4384!", "chen_im", "127.0.0.1", 3306, "utf8", 4);
    chen_im::MessageTable tb(db);
    chen_im::Message m1("消息ID1", "会话ID1", "用户ID1", 0, boost::posix_time::time_from_string("2002-01-20 23:59:59.000"));
    tb.insert(m1);
    chen_im::Message m2("消息ID2", "会话ID1", "用户ID2", 0, boost::posix_time::time_from_string("2002-01-21 23:59:59.000"));
    tb.insert(m2);
    chen_im::Message m3("消息ID3", "会话ID1", "用户ID3", 0, boost::posix_time::time_from_string("2002-01-22 23:59:59.000"));
    tb.insert(m3);

    chen_im::Message m4("消息ID4", "会话ID2", "用户ID4", 0, boost::posix_time::time_from_string("2002-01-20 23:59:59.000"));
    tb.insert(m4);
    chen_im::Message m5("消息ID5", "会话ID2", "用户ID5", 0, boost::posix_time::time_from_string("2002-01-21 23:59:59.000"));
    tb.insert(m5);
}

// 测试GetHistoryMsg
void range_test(const std::string &ssid, 
    const boost::posix_time::ptime &stime,
    const boost::posix_time::ptime &etime) 
{
    auto channel = sm->get(FLAGS_message_store_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgStorageService_Stub stub(channel.get());
    chen_im::GetHistoryMsgReq req;
    chen_im::GetHistoryMsgRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_chat_session_id(ssid);
    req.set_start_time(boost::posix_time::to_time_t(stime));
    req.set_over_time(boost::posix_time::to_time_t(etime));
    brpc::Controller cntl;
    stub.GetHistoryMsg(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());

    for (int i = 0; i < rsp.msg_list_size(); i++) {
        std::cout << "-----------------------获取区间消息--------------------------\n";
        auto msg = rsp.msg_list(i);
        std::cout << msg.message_id() << std::endl;
        std::cout << msg.chat_session_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(boost::posix_time::from_time_t(msg.timestamp())) << std::endl;
        std::cout << msg.sender().user_id() << std::endl;
        std::cout << msg.sender().nickname() << std::endl;
        std::cout << msg.sender().avatar() << std::endl;
        if (msg.message().message_type() == chen_im::MessageType::STRING) {
            std::cout << "文本消息：" << msg.message().string_message().content() << std::endl;
        }else if (msg.message().message_type() == chen_im::MessageType::IMAGE) {
            std::cout << "图片消息：" << msg.message().image_message().image_content() << std::endl;
        }else if (msg.message().message_type() == chen_im::MessageType::SPEECH) {
            std::cout << "语音消息：" << msg.message().speech_message().file_contents().size() << std::endl;
        }else {
            std::cout << "类型错误！！\n";
        }
    }
}

// 测试GetRecentMsg
void recent_test(const std::string &ssid, int count) 
{
    auto channel = sm->get(FLAGS_message_store_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgStorageService_Stub stub(channel.get());
    chen_im::GetRecentMsgReq req;
    chen_im::GetRecentMsgRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_chat_session_id(ssid);
    req.set_msg_count(count);
    brpc::Controller cntl;
    stub.GetRecentMsg(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    for (int i = 0; i < rsp.msg_list_size(); i++) {
        std::cout << "----------------------获取最近消息---------------------------\n";
        auto msg = rsp.msg_list(i);
        std::cout << msg.message_id() << std::endl;
        std::cout << msg.chat_session_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(boost::posix_time::from_time_t(msg.timestamp())) << std::endl;
        std::cout << msg.sender().user_id() << std::endl;
        std::cout << msg.sender().nickname() << std::endl;
        std::cout << msg.sender().avatar() << std::endl;
        if (msg.message().message_type() == chen_im::MessageType::STRING) {
            std::cout << "文本消息：" << msg.message().string_message().content() << std::endl;
        }else if (msg.message().message_type() == chen_im::MessageType::IMAGE) {
            std::cout << "图片消息：" << msg.message().image_message().image_content() << std::endl;
        }else if (msg.message().message_type() == chen_im::MessageType::SPEECH) {
            std::cout << "语音消息：" << msg.message().speech_message().file_contents().size() << std::endl;
        }else {
            std::cout << "类型错误！！\n";
        }
    }
}

// MsgSearch
void search_test(const std::string &ssid, const std::string &key) 
{
    auto channel = sm->get(FLAGS_message_store_service);
    if (!channel) {
        std::cout << "获取通信信道失败！" << std::endl;
        return;
    }
    chen_im::MsgStorageService_Stub stub(channel.get());
    chen_im::MsgSearchReq req;
    chen_im::MsgSearchRsp rsp;
    req.set_request_id(chen_im::generate_uuid());
    req.set_chat_session_id(ssid);
    req.set_search_key(key);
    brpc::Controller cntl;
    stub.MsgSearch(&cntl, &req, &rsp, nullptr);
    ASSERT_FALSE(cntl.Failed());
    ASSERT_TRUE(rsp.success());
    for (int i = 0; i < rsp.msg_list_size(); i++) {
        std::cout << "----------------------关键字搜索消息---------------------------\n";
        auto msg = rsp.msg_list(i);
        std::cout << msg.message_id() << std::endl;
        std::cout << msg.chat_session_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(boost::posix_time::from_time_t(msg.timestamp())) << std::endl;
        std::cout << msg.sender().user_id() << std::endl;
        std::cout << msg.sender().nickname() << std::endl;
        std::cout << msg.sender().avatar() << std::endl;
        if (msg.message().message_type() == chen_im::MessageType::STRING) {
            std::cout << "文本消息：" << msg.message().string_message().content() << std::endl;
        }else if (msg.message().message_type() == chen_im::MessageType::IMAGE) {
            std::cout << "图片消息：" << msg.message().image_message().image_content() << std::endl;
        
        }else if (msg.message().message_type() == chen_im::MessageType::SPEECH) {
            std::cout << "语音消息：" << msg.message().speech_message().file_contents().size() << std::endl;
        }else {
            std::cout << "类型错误！！\n";
        }
    }
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    
    //1. 先构造Rpc信道管理对象
    sm = std::make_shared<chen_im::ServiceManager>();
    sm->concern(FLAGS_message_store_service);
    auto put_cb = std::bind(&chen_im::ServiceManager::when_service_online, sm.get(), std::placeholders::_1, std::placeholders::_2);
    auto del_cb = std::bind(&chen_im::ServiceManager::when_service_offline, sm.get(), std::placeholders::_1, std::placeholders::_2);
    //2. 构造服务发现对象
    chen_im::Discovery::ptr dclient = std::make_shared<chen_im::Discovery>(FLAGS_etcd_host, FLAGS_base_service, put_cb, del_cb);
    

    // init_es();
    // init_mysql();

    boost::posix_time::ptime stime(boost::posix_time::time_from_string("2000-08-02 00:00:00"));
    boost::posix_time::ptime etime(boost::posix_time::time_from_string("2025-08-09 00:00:00"));
    range_test("3125-570f056d-0003", stime, etime);
    recent_test("3125-570f056d-0003", 2);
    search_test("3125-570f056d-0003", "用户");

    std::this_thread::sleep_for(std::chrono::seconds(600));
    return 0;
}

--- FILE: 5.Message_Store_Server/test/es_test/main.cc ---
内容:
#include "../../../Common/elasticsearch_user.hpp"
#include <gflags/gflags.h>

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");


DEFINE_string(es_host, "http://127.0.0.1:9200/", "es服务器URL");

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    auto es_client = chen_im::ESClientFactory::create({FLAGS_es_host});

    auto es_msg = std::make_shared<chen_im::ESMessage>(es_client);
    es_msg->createIndex();
    es_msg->appendData("用户ID1", "消息ID1", 1723025035, "会话ID1", "吃饭了吗？");
    es_msg->appendData("用户ID2", "消息ID2", 1723025035 - 100, "会话ID1", "吃的盖浇饭！");
    es_msg->appendData("用户ID3", "消息ID3", 1723025035, "会话ID2", "吃饭了吗？");
    es_msg->appendData("用户ID4", "消息ID4", 1723025035 - 100, "会话ID2", "吃的盖浇饭！");
    
    auto res = es_msg->search("盖浇", "会话ID1");
    for (auto &u : res) {
        std::cout << "-----------------" << std::endl;
        std::cout << u.user_id() << std::endl;
        std::cout << u.message_id() << std::endl;
        std::cout << u.session_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(u.create_time()) << std::endl;
        std::cout << u.content() << std::endl;
    }
    return 0;
}

--- FILE: 5.Message_Store_Server/test/es_test/Makefile ---
内容:
main : main.cc
	c++ $^ -o $@  -I../../../odb/ -I./ -lfmt -lspdlog -lgflags -lcpr -lelasticlient /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19

--- FILE: 5.Message_Store_Server/test/bugtest/CMakeLists.txt ---
内容:
cmake_minimum_required(VERSION 3.1.3)

project(bugtest) # 解决protobuf内容经过消息队列后不能正确解析的问题 

set(CMAKE_CXX_STANDARD 17)


# 最终的可执行
set(receiver "receiver")
set(sender "sender")

# 源文件
file(GLOB main_src_files_receiver  "${CMAKE_CURRENT_SOURCE_DIR}/receiver.cpp")
file(GLOB main_src_files_sender  "${CMAKE_CURRENT_SOURCE_DIR}/sender.cpp")

# proto文件
set(proto_files base.proto)
set(proto_path ${CMAKE_CURRENT_SOURCE_DIR}/../../../APIs/)
set(proto_src "")

foreach(protofile ${proto_files})
    string(REPLACE ".proto" ".pb.cc" proto_cc ${protofile})
    add_custom_command(
        PRE_BUILD
        COMMAND protoc --cpp_out=${CMAKE_CURRENT_BINARY_DIR}/ -I ${proto_path} ${proto_path}/${protofile}
        DEPENDS ${proto_path}/${protofile}
        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc}
        Comment "生成proto文件：${proto_cc}"
    )
    list(APPEND proto_src ${CMAKE_CURRENT_BINARY_DIR}/${proto_cc})
endforeach()

add_executable(${receiver} ${main_src_files_receiver} ${proto_src}) # 目标可执行 源文件1 源文件2
add_executable(${sender} ${main_src_files_sender} ${proto_src}) # 目标可执行 源文件1 源文件2

# 5. 查找 Boost 库，指定需要的模块
find_package(Boost REQUIRED COMPONENTS date_time)

# 库
target_link_libraries(${receiver}
    -lgflags 
    -lspdlog 
    -lfmt 
    -lbrpc 
    -lssl 
    -lcrypto 
    -lprotobuf 
    -lleveldb 
    -letcd-cpp-api 
    -lcpprest 
    -lcurl 
    -lodb-mysql 
    -lodb 
    -lodb-boost
    /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
    -lcpr 
    -lelasticlient 
    -lamqpcpp 
    -lev 
    -lpthread 
    Boost::date_time
    -lgtest
    -ldl
)

target_link_libraries(${sender}
    -lgflags 
    -lspdlog 
    -lfmt 
    -lbrpc 
    -lssl 
    -lcrypto 
    -lprotobuf 
    -lleveldb 
    -letcd-cpp-api 
    -lcpprest 
    -lcurl 
    -lodb-mysql 
    -lodb 
    -lodb-boost
    /usr/lib/x86_64-linux-gnu/libjsoncpp.so.19
    -lcpr 
    -lelasticlient 
    -lamqpcpp 
    -lev 
    -lpthread 
    Boost::date_time
    -lgtest
    -ldl
)

# 头文件搜索路径
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../../../Common)


--- FILE: 5.Message_Store_Server/test/bugtest/receiver.cpp ---
内容:
#include "base.pb.h"

#include "rabbitmq.hpp"
#include "logger.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <time.h>

#include <iostream>

DEFINE_string(mq_user, "chen", "");
DEFINE_string(mq_passwd, "czhuowen", "");
DEFINE_string(mq_host, "127.0.0.1:5672", "");


// 需要解决protobuf内容经过消息队列后不能正确解析的问题

// 1. 初始化mqclient
// 2. 填充并序列化MessageInfo结构
// 3. publish——message
// 4. consume——message
// 5. 取出消息并反序列化


int main(int argc, char *argv[])
{
    chen_im::init_logger(false, "null", spdlog::level::level_enum::trace);
    gflags::ParseCommandLineFlags(&argc, &argv, true);

    // 1. 初始化mqclient
    chen_im::MQClient mq_client("chen", "czhuowen", "127.0.0.1:5672");
    mq_client.declear_all_components("bug_testing_1", "bug_queue", "routing_queue");

    std::cout << "收到消息的回调函数即将设置" << std::endl;
    mq_client.consume_message("bug_queue", "consume_tag", [](const char* receive_buff, size_t buff_size) {
        chen_im::MessageInfo recieve_msg_info;
        
        // 5. 取出消息并反序列化
        bool ret = recieve_msg_info.ParseFromString(std::string(receive_buff, buff_size));
        if(!ret) {
            LOG_ERROR("反序列化失败！");
        } else {
            LOG_INFO("消息反序列化成功！");
        }
        
        LOG_INFO("msg_info.message_id: {}", recieve_msg_info.message_id());
        LOG_INFO("msg_info.chat_session_id: {}", recieve_msg_info.chat_session_id());
        LOG_INFO("timestamp: {}", recieve_msg_info.timestamp());
        LOG_INFO("sender userid: {}", recieve_msg_info.sender().user_id());
        LOG_INFO("sender nickname: {}", recieve_msg_info.sender().nickname());
        LOG_INFO("sender description: {}", recieve_msg_info.sender().description());
        LOG_INFO("sender phone: {}", recieve_msg_info.sender().phone());
        LOG_INFO("sender avatar: {}", recieve_msg_info.sender().avatar());
        LOG_INFO("message content type: {}", (int)recieve_msg_info.message().message_type());
        LOG_INFO("message content string_message content: {}", recieve_msg_info.message().string_message().content());

    });

    std::cout << "回调函数设置成功！" << std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(500));
    return 0;
}

--- FILE: 5.Message_Store_Server/test/bugtest/sender.cpp ---
内容:
#include "base.pb.h"

#include "rabbitmq.hpp"
#include "logger.hpp"
#include <gflags/gflags.h>
#include <gtest/gtest.h>
#include <time.h>

#include <iostream>

DEFINE_string(mq_user, "chen", "");
DEFINE_string(mq_passwd, "czhuowen", "");
DEFINE_string(mq_host, "127.0.0.1:5672", "");

// 需要解决protobuf内容经过消息队列后不能正确解析的问题

// 1. 初始化mqclient
// 2. 填充并序列化MessageInfo结构
// 3. publish——message
// 4. consume——message
// 5. 取出消息并反序列化


int main(int argc, char *argv[])
{
    chen_im::init_logger(false, "null", spdlog::level::level_enum::trace);
    gflags::ParseCommandLineFlags(&argc, &argv, true);


    // 1. 初始化mqclient
    chen_im::MQClient mq_client("chen", "czhuowen", "127.0.0.1:5672");
    mq_client.declear_all_components("bug_testing_1", "bug_queue", "routing_key");

    // 2. 填充并序列化MessageInfo结构
    chen_im::MessageInfo msg_info;
    msg_info.set_message_id("message_11111");
    msg_info.set_chat_session_id("session_id_1234");
    msg_info.set_timestamp(time(nullptr));

    auto msg_info_sender = msg_info.mutable_sender();
         msg_info_sender->set_user_id("1234");
         msg_info_sender->set_nickname("name");
         msg_info_sender->set_description("hello world");
         msg_info_sender->set_phone("123455643523");
         msg_info_sender->set_avatar("this is an avatar");
    
    auto msg_info_message = msg_info.mutable_message();
         msg_info_message->set_message_type(chen_im::MessageType::STRING);
         auto msg_str_msg = msg_info_message->mutable_string_message();
         msg_str_msg->set_content("我是消息本体");

    std::string msg_info_serialized(msg_info.SerializeAsString());

    // 3. publish——message
    std::this_thread::sleep_for(std::chrono::seconds(1));

    try {
        bool ret = mq_client.publish_message("bug_testing_1", msg_info_serialized, "routing_key");  
        if(!ret) {
            LOG_ERROR("发送消息失败");
        } else {
            LOG_INFO("发送消息成功！");
        }
    } catch (const std::exception& e) {
        LOG_ERROR("消息解析过程中出现异常: {}", e.what());
    }

    std::this_thread::sleep_for(std::chrono::seconds(500));
    return 0;
}



--- FILE: 5.Message_Store_Server/test/mysql_test/main.cc ---
内容:
#include "mysql_message.hpp"
#include <gflags/gflags.h>


DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

void insert_test(chen_im::MessageTable &tb) {
    chen_im::Message m1("消息ID1", "会话ID1", "用户ID1", 0, boost::posix_time::time_from_string("2002-01-20 23:59:59.000"));
    tb.insert(m1);
    chen_im::Message m2("消息ID2", "会话ID1", "用户ID2", 0, boost::posix_time::time_from_string("2002-01-21 23:59:59.000"));
    tb.insert(m2);
    chen_im::Message m3("消息ID3", "会话ID1", "用户ID3", 0, boost::posix_time::time_from_string("2002-01-22 23:59:59.000"));
    tb.insert(m3);

    chen_im::Message m4("消息ID4", "会话ID2", "用户ID4", 0, boost::posix_time::time_from_string("2002-01-20 23:59:59.000"));
    tb.insert(m4);
    chen_im::Message m5("消息ID5", "会话ID2", "用户ID5", 0, boost::posix_time::time_from_string("2002-01-21 23:59:59.000"));
    tb.insert(m5);
}
void remove_test(chen_im::MessageTable &tb) {
    tb.remove("会话ID2");
}

void recent_test(chen_im::MessageTable &tb) {
    auto res = tb.recent("会话ID1", 2);
    auto begin = res.rbegin();
    auto end = res.rend();
    for (; begin != end; ++begin) {
        std::cout << begin->message_id() << std::endl;
        std::cout << begin->session_id() << std::endl;
        std::cout << begin->user_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(begin->create_time()) << std::endl;
    }
}

void range_test(chen_im::MessageTable &tb) {
    boost::posix_time::ptime stime(boost::posix_time::time_from_string("2002-01-20 23:59:59.000"));
    boost::posix_time::ptime etime(boost::posix_time::time_from_string("2002-01-21 23:59:59.000"));
    auto res = tb.range("会话ID1", stime, etime);
    for (const auto &m : res) {
        std::cout << m.message_id() << std::endl;
        std::cout << m.session_id() << std::endl;
        std::cout << m.user_id() << std::endl;
        std::cout << boost::posix_time::to_simple_string(m.create_time()) << std::endl;
    }
}

int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    auto db = chen_im::ODBFactory::create("root", "123456", "127.0.0.1", "chen_im", "utf8", 0, 1);
    chen_im::MessageTable tb(db);
    // insert_test(tb);
    // remove_test(tb);
    recent_test(tb);
    // range_test(tb);
    return 0;
}

--- FILE: 5.Message_Store_Server/test/mysql_test/Makefile ---
内容:
CFLAGS = -I/usr/include/mysql -I../../../odb/ -I../../../common -I./ 
main : main.cc message-odb.cxx
	g++ -std=c++17 $^ -o $@   -lodb-mysql $(CFLAGS) -lodb -lodb-boost -lfmt -lspdlog -lgflags

--- FILE: 5.Message_Store_Server/source/message_store_server.cc ---
内容:
//主要实现语音识别子服务的服务器的搭建
#include "message_store_server.hpp"

DEFINE_bool(run_mode, false, "程序的运行模式，false-调试； true-发布；");
DEFINE_string(log_file, "", "发布模式下，用于指定日志的输出文件");
DEFINE_int32(log_level, 0, "发布模式下，用于指定日志输出等级");

DEFINE_string(registry_host, "http://127.0.0.1:2379", "服务注册中心地址");
DEFINE_string(instance_name, "/message_store_service/instance1", "当前实例名称");
DEFINE_string(access_host, "127.0.0.1:10005", "当前实例的外部访问地址");

DEFINE_int32(listen_port, 10005, "Rpc服务器监听端口");
DEFINE_int32(rpc_timeout, -1, "Rpc调用超时时间");
DEFINE_int32(rpc_threads, 1, "Rpc的IO线程数量");


DEFINE_string(base_service, "/service", "服务监控根目录");
DEFINE_string(file_service, "/service/file_service", "文件管理子服务名称");
DEFINE_string(user_service, "/service/user_service", "用户管理子服务名称");

DEFINE_string(es_host, "http://127.0.0.1:9200/", "ES搜索引擎服务器URL");

DEFINE_string(mysql_host, "127.0.0.1", "Mysql服务器访问地址");
DEFINE_string(mysql_user, "chen", "Mysql服务器访问用户名");
DEFINE_string(mysql_pswd, "Cydia4384!", "Mysql服务器访问密码");
DEFINE_string(mysql_db, "chen_im", "Mysql默认库名称");
DEFINE_string(mysql_cset, "utf8", "Mysql客户端字符集");
DEFINE_int32(mysql_access_port, 0, "Mysql服务器访问端口");
DEFINE_int32(mysql_pool_count, 4, "Mysql连接池最大连接数量");

DEFINE_string(mq_user, "chen", "消息队列服务器访问用户名");
DEFINE_string(mq_pswd, "czhuowen", "消息队列服务器访问密码");
DEFINE_string(mq_host, "127.0.0.1:5672", "消息队列服务器访问地址");
DEFINE_string(mq_msg_exchange, "msg_exchange", "持久化消息的发布交换机名称");
DEFINE_string(mq_msg_queue, "msg_queue", "持久化消息的发布队列名称");
DEFINE_string(mq_msg_binding_key, "msg_queue", "持久化消息的发布队列名称");


int main(int argc, char *argv[])
{
    google::ParseCommandLineFlags(&argc, &argv, true);
    chen_im::init_logger(FLAGS_run_mode, FLAGS_log_file, FLAGS_log_level);

    chen_im::MessageServerFactory msb;
    msb.make_mq_object(FLAGS_mq_user, FLAGS_mq_pswd, FLAGS_mq_host,
        FLAGS_mq_msg_exchange, FLAGS_mq_msg_queue, FLAGS_mq_msg_binding_key);
    msb.make_es_object({FLAGS_es_host});
    msb.make_mysql_object(FLAGS_mysql_user, FLAGS_mysql_pswd, FLAGS_mysql_host, 
        FLAGS_mysql_db, FLAGS_mysql_cset, FLAGS_mysql_access_port, FLAGS_mysql_pool_count);
    msb.make_discovery_object(FLAGS_registry_host, FLAGS_base_service, FLAGS_file_service, FLAGS_user_service);
    msb.make_rpc_server(FLAGS_listen_port, FLAGS_rpc_timeout, FLAGS_rpc_threads);
    msb.make_registry_object(FLAGS_registry_host, FLAGS_base_service + FLAGS_instance_name, FLAGS_access_host);
    auto server = msb.build();
    server->start();
    return 0;
}

--- FILE: 5.Message_Store_Server/source/message_store_server.hpp ---
内容:
// 
#pragma once
#include <brpc/server.h>
#include <butil/logging.h>

#include "elasticsearch_user.hpp"   // es数据管理客户端封装
#include "mysql_message.hpp"        // mysql数据管理客户端封装
#include "etcd.hpp"                 // 服务注册模块封装
#include "logger.hpp"               // 日志模块封装
#include "utility.hpp"              // 基础工具接口
#include "rpc_service_manager.hpp"  // 信道管理模块封装
#include "rabbitmq.hpp"

#include "message_storage.pb.h" // protobuf框架代码
#include "base.pb.h"            // protobuf框架代码
#include "file.pb.h"            // protobuf框架代码
#include "user.pb.h"            // protobuf框架代码

namespace chen_im
{
    class MessageServiceImpl : public chen_im::MsgStorageService
    {    
    private:
        ESMessage::ptr _es_message;              // es的消息表
        MessageTable::ptr _mysql_message_table;  // mysql的user表

        // 下面是rpc调用客户端相关
        std::string _user_service_name;          // 用户子服务名称
        std::string _file_service_name;          // 文件子服务名称
        ServiceManager::ptr _service_manager;    // 服务管理对象

    public:
        MessageServiceImpl(const std::shared_ptr<elasticlient::Client> &es_client,
                           const std::shared_ptr<odb::mysql::database> &mysql_client,
                           const ServiceManager::ptr &channel_manager,
                           const std::string &file_service_name,
                           const std::string &user_service_name) 
            :_es_message(std::make_shared<ESMessage>(es_client)), 
            _mysql_message_table(std::make_shared<MessageTable>(mysql_client)), 
            _file_service_name(file_service_name), 
            _user_service_name(user_service_name), 
            _service_manager(channel_manager)
        {
            _es_message->create_index();
        }
        ~MessageServiceImpl() {}

        // 聊天会话的历史消息搜索功能，从“起始时间”到“结束时间”，查询mysql数据库
        virtual void GetHistoryMsg(::google::protobuf::RpcController *controller,
                                   const ::chen_im::GetHistoryMsgReq *request,
                                   ::chen_im::GetHistoryMsgRsp *response,
                                   ::google::protobuf::Closure *done) override
        {
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 提取请求中的关键要素：会话ID，起始时间，结束时间
            std::string request_id = request->request_id();
            std::string chat_ssid = request->chat_session_id();
            boost::posix_time::ptime stime = boost::posix_time::from_time_t(request->start_time());
            boost::posix_time::ptime etime = boost::posix_time::from_time_t(request->over_time());

            // 2. 在数据库中，查询指定chat_session_id下，指定时间段内的所有消息(发起mysql事务)
            std::vector<chen_im::Message> msg_lists = _mysql_message_table->range(chat_ssid, stime, etime);
            if (msg_lists.empty()) 
            {
                response->set_request_id(request_id);
                response->set_success(true);
                return;
            }

            // 从mysql中获取到的消息对象中，没有文件内容，只有文件id，因此要调用文件子服务把文件正真的内容塞进去
            // 3. 统计所有文件类型消息的文件ID，并从文件子服务进行批量文件下载
            std::unordered_set<std::string> file_id_lists;
            for (const auto &msg : msg_lists)
            {
                if (msg.file_id().empty()) // 如果文件id存在的话，说明该消息是文件消息
                    continue;
                LOG_DEBUG("需要从文件管理子服务下载的文件ID： {}", msg.file_id());
                file_id_lists.insert(msg.file_id());
            }
            std::unordered_map<std::string, std::string> file_data_lists;
            bool ret = _get_files(request_id, file_id_lists, &file_data_lists);
            if (ret == false)
            {
                LOG_ERROR("{} 批量文件数据下载失败！", request_id);
                return err_response(request_id, "批量文件数据下载失败!");
            }



            // 从mysql中获取到的消息对象中，没有用户信息，只有用户id，
            // 而响应体应当填充UserInfo字段，UserInfo是完整的用户信息，如下：

            // //消息结构
            // message MessageInfo {
            //     string message_id = 1;//消息ID
            //     string chat_session_id = 2;//消息所属聊天会话ID
            //     int64 timestamp = 3;//消息产生时间
            //     UserInfo sender = 4;//消息发送者信息
            //     MessageContent message = 5;
            // }

            // //用户信息结构
            // message UserInfo {
            //     string user_id = 1;//用户ID
            //     string nickname = 2;//昵称
            //     string description = 3;//个人签名/描述
            //     string phone = 4; //绑定手机号
            //     bytes  avatar = 5;//头像照片，文件内容使用二进制
            // }

            // 4. 统计所有消息的发送者用户ID，从用户子服务进行批量用户信息获取
            //（本质上是先把数据准备好，因为后面要把完整的一个个的用户信息填充到响应体里的）
            std::unordered_set<std::string> user_id_lists;
            for (const auto &msg : msg_lists)
            {
                user_id_lists.insert(msg.user_id());
            }
            std::unordered_map<std::string, UserInfo> user_lists;
            ret = _get_user_info(request_id, user_id_lists, &user_lists);
            if (ret == false)
            {
                LOG_ERROR("{} 批量用户数据获取失败！", request_id);
                return err_response(request_id, "批量用户数据获取失败!");
            }

            // 5. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &msg : msg_lists) // 逐个地把消息元信息 + 文件内容 + 用户信息
            {
                auto message_info = response->add_msg_list();
                message_info->set_message_id(msg.message_id());
                message_info->set_chat_session_id(msg.session_id());
                message_info->set_timestamp(boost::posix_time::to_time_t(msg.create_time()));
                message_info->mutable_sender()->CopyFrom(user_lists[msg.user_id()]); // 含义是：要填充sender字段，所以调用mutable_sender()，上面的user_lists已经获取了从id到UserInfo的映射，所以使用当前遍历到的msg中的userid作为key去拿到对应的UserInfo
                switch (msg.message_type())
                {
                case MessageType::STRING:
                    message_info->mutable_message()->set_message_type(MessageType::STRING);
                    message_info->mutable_message()->mutable_string_message()->set_content(msg.content());
                    break;
                case MessageType::IMAGE:
                    message_info->mutable_message()->set_message_type(MessageType::IMAGE);
                    message_info->mutable_message()->mutable_image_message()->set_file_id(msg.file_id());
                    message_info->mutable_message()->mutable_image_message()->set_image_content(file_data_lists[msg.file_id()]);
                    break;
                case MessageType::FILE:
                    message_info->mutable_message()->set_message_type(MessageType::FILE);
                    message_info->mutable_message()->mutable_file_message()->set_file_id(msg.file_id());
                    message_info->mutable_message()->mutable_file_message()->set_file_size(msg.file_size());
                    message_info->mutable_message()->mutable_file_message()->set_file_name(msg.file_name());
                    message_info->mutable_message()->mutable_file_message()->set_file_contents(file_data_lists[msg.file_id()]);
                    break;
                case MessageType::SPEECH:
                    message_info->mutable_message()->set_message_type(MessageType::SPEECH);
                    message_info->mutable_message()->mutable_speech_message()->set_file_id(msg.file_id());
                    message_info->mutable_message()->mutable_speech_message()->set_file_contents(file_data_lists[msg.file_id()]);
                    break;
                default:
                    LOG_ERROR("消息类型错误！！");
                    return;
                }
            }
            return;
        }

        // 获取最近消息，即聊天框里要显示的消息
        virtual void GetRecentMsg(::google::protobuf::RpcController *controller,
                                  const ::chen_im::GetRecentMsgReq *request,
                                  ::chen_im::GetRecentMsgRsp *response,
                                  ::google::protobuf::Closure *done) override
        {
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 1. 提取请求中的关键要素：请求ID，会话ID，要获取的消息数量
            std::string request_id = request->request_id();
            std::string chat_ssid = request->chat_session_id();
            int msg_count = request->msg_count();
            // 2. 从数据库，获取最近的消息元信息
            auto msg_lists = _mysql_message_table->recent(chat_ssid, msg_count);
            if (msg_lists.empty())
            {
                response->set_request_id(request_id);
                response->set_success(true);
                return;
            }
            // 3. 统计所有消息中文件类型消息的文件ID列表，从文件子服务下载文件
            std::unordered_set<std::string> file_id_lists;
            for (const auto &msg : msg_lists)
            {
                if (msg.file_id().empty())
                    continue;
                LOG_DEBUG("需要下载的文件ID: {}", msg.file_id());
                file_id_lists.insert(msg.file_id());
            }
            std::unordered_map<std::string, std::string> file_data_lists;
            bool ret = _get_files(request_id, file_id_lists, &file_data_lists);
            if (ret == false)
            {
                LOG_ERROR("{} 批量文件数据下载失败！", request_id);
                return err_response(request_id, "批量文件数据下载失败!");
            }
            // 4. 统计所有消息的发送者用户ID，从用户子服务进行批量用户信息获取
            std::unordered_set<std::string> user_id_lists;
            for (const auto &msg : msg_lists)
            {
                user_id_lists.insert(msg.user_id());
            }
            std::unordered_map<std::string, UserInfo> user_lists;
            ret = _get_user_info(request_id, user_id_lists, &user_lists);
            if (ret == false)
            {
                LOG_ERROR("{} 批量用户数据获取失败！", request_id);
                return err_response(request_id, "批量用户数据获取失败!");
            }
            // 5. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &msg : msg_lists)
            {
                auto message_info = response->add_msg_list();
                message_info->set_message_id(msg.message_id());
                message_info->set_chat_session_id(msg.session_id());
                message_info->set_timestamp(boost::posix_time::to_time_t(msg.create_time()));
                message_info->mutable_sender()->CopyFrom(user_lists[msg.user_id()]);
                switch (msg.message_type())
                {
                case MessageType::STRING:
                    message_info->mutable_message()->set_message_type(MessageType::STRING);
                    message_info->mutable_message()->mutable_string_message()->set_content(msg.content());
                    break;
                case MessageType::IMAGE:
                    message_info->mutable_message()->set_message_type(MessageType::IMAGE);
                    message_info->mutable_message()->mutable_image_message()->set_file_id(msg.file_id());
                    message_info->mutable_message()->mutable_image_message()->set_image_content(file_data_lists[msg.file_id()]);
                    break;
                case MessageType::FILE:
                    message_info->mutable_message()->set_message_type(MessageType::FILE);
                    message_info->mutable_message()->mutable_file_message()->set_file_id(msg.file_id());
                    message_info->mutable_message()->mutable_file_message()->set_file_size(msg.file_size());
                    message_info->mutable_message()->mutable_file_message()->set_file_name(msg.file_name());
                    message_info->mutable_message()->mutable_file_message()->set_file_contents(file_data_lists[msg.file_id()]);
                    break;
                case MessageType::SPEECH:
                    message_info->mutable_message()->set_message_type(MessageType::SPEECH);
                    message_info->mutable_message()->mutable_speech_message()->set_file_id(msg.file_id());
                    message_info->mutable_message()->mutable_speech_message()->set_file_contents(file_data_lists[msg.file_id()]);
                    break;
                default:
                    LOG_ERROR("消息类型错误！！");
                    return;
                }
            }
            return;
        }
        
        // 消息的关键字搜索
        virtual void MsgSearch(::google::protobuf::RpcController *controller,
                               const ::chen_im::MsgSearchReq *request,
                               ::chen_im::MsgSearchRsp *response,
                               ::google::protobuf::Closure *done) override
        {
            brpc::ClosureGuard rpc_guard(done);
            auto err_response = [this, response](const std::string &request_id,
                                                 const std::string &errmsg) -> void
            {
                response->set_request_id(request_id);
                response->set_success(false);
                response->set_errmsg(errmsg);
                return;
            };
            // 关键字的消息搜索只针对文本消息，所以得到消息元数据 + 用户信息后，就可以组织响应体了
            // 1. 从请求中提取关键要素：请求ID，会话ID, 关键字
            std::string request_id = request->request_id();
            std::string chat_ssid = request->chat_session_id();
            std::string keyword = request->search_key();
            // 2. 从ES搜索引擎中进行关键字消息搜索，得到消息列表
            auto msg_lists = _es_message->search(keyword, chat_ssid);
            if (msg_lists.empty())
            {
                response->set_request_id(request_id);
                response->set_success(true);
                return;
            }
            // 3. 组织所有消息的用户ID，从用户子服务获取用户信息
            std::unordered_set<std::string> user_id_lists;
            for (const auto &msg : msg_lists)
            {
                user_id_lists.insert(msg.user_id());
            }
            std::unordered_map<std::string, UserInfo> user_lists;
            bool ret = _get_user_info(request_id, user_id_lists, &user_lists);
            if (ret == false)
            {
                LOG_ERROR("{} 批量用户数据获取失败！", request_id);
                return err_response(request_id, "批量用户数据获取失败!");
            }
            // 4. 组织响应
            response->set_request_id(request_id);
            response->set_success(true);
            for (const auto &msg : msg_lists)
            {
                auto message_info = response->add_msg_list();
                message_info->set_message_id(msg.message_id());
                message_info->set_chat_session_id(msg.session_id());
                message_info->set_timestamp(boost::posix_time::to_time_t(msg.create_time()));
                message_info->mutable_sender()->CopyFrom(user_lists[msg.user_id()]);
                message_info->mutable_message()->set_message_type(MessageType::STRING);
                message_info->mutable_message()->mutable_string_message()->set_content(msg.content());
            }
            return;
        }
        
        // 消息队列的消费者收到消息时的回调函数，这里涉及到了mysql与es的双写！！！
        void when_get_an_message(const char *body, size_t sz)
        {
            LOG_DEBUG("收到新消息，进行存储处理！");

            bool ret;
            
            // 1. 取出序列化的消息内容，进行反序列化
            chen_im::MessageInfo message;

            ret = message.ParseFromArray(body, sz);



            // std::string pure_message(body, sz);
            // // 找到最后一个非\0的位置
            // size_t pos = pure_message.find("�");

            // // 如果找到，截取该位置之后的所有内容，否则表示字符串全是\0
            // if (pos != std::string::npos) {
            //     pure_message.erase(pos); // 保留到最后一个非\0的位置
            // }

            // // 1. 取出序列化的消息内容，进行反序列化
            // chen_im::MessageInfo message;
            // try {
            //     ret = message.ParseFromString(pure_message);
            //     if (!ret) {
            //         LOG_ERROR("消息解析失败！pure_message: {}", pure_message);

            //         std::string file_name = "./buglog_consumer_" + std::to_string(time(nullptr)) + ".bin";
            //         std::ofstream bug(file_name, std::ios::binary | std::ios::app);
            //         bug.write(body, sz); // 写入二进制数据
            //         bug.close(); // 关闭文件流
            //         return;
            //     }
            // } catch (const std::exception& e) {
            //     LOG_ERROR("消息解析过程中出现异常: {}", e.what());
            //     return;
            // }


            // 2. 根据不同的消息类型进行不同的处理
            std::string file_id, file_name, content;
            int64_t file_size;
            switch (message.message().message_type())
            {
            //  2.1 如果是一个文本类型消息，取元信息存储到ES中
            case MessageType::STRING:
                content = message.message().string_message().content();
                ret = _es_message->append_message(
                    message.sender().user_id(),
                    message.message_id(),
                    message.timestamp(),
                    message.chat_session_id(),
                    content);
                if (ret == false)
                {
                    LOG_ERROR("文本消息向存储引擎进行存储失败！");
                    return;
                }
                break;
            //  2.2 如果是一个图片/语音/文件消息，则取出数据存储到文件子服务中，并获取文件ID
            case MessageType::IMAGE:
            {
                const auto &msg = message.message().image_message();
                ret = _PutFile("", msg.image_content(), msg.image_content().size(), file_id);
                if (ret == false)
                {
                    LOG_ERROR("上传图片到文件子服务失败！");
                    return;
                }
            }
            break;
            case MessageType::FILE:
            {
                const auto &msg = message.message().file_message();
                file_name = msg.file_name();
                file_size = msg.file_size();
                ret = _PutFile(file_name, msg.file_contents(), file_size, file_id);
                if (ret == false)
                {
                    LOG_ERROR("上传文件到文件子服务失败！");
                    return;
                }
            }
            break;
            case MessageType::SPEECH:
            {
                const auto &msg = message.message().speech_message();
                ret = _PutFile("", msg.file_contents(), msg.file_contents().size(), file_id);
                if (ret == false)
                {
                    LOG_ERROR("上传语音到文件子服务失败！");
                    return;
                }
            }
            break;
            default:
                LOG_ERROR("消息类型错误！");
                return;
            }
            // 3. 提取消息的元信息，存储到mysql数据库中
            chen_im::Message msg(message.message_id(),
                                 message.chat_session_id(),
                                 message.sender().user_id(),
                                 message.message().message_type(),
                                 boost::posix_time::from_time_t(message.timestamp()));
            msg.content(content);
            msg.file_id(file_id);
            msg.file_name(file_name);
            msg.file_size(file_size);
            ret = _mysql_message_table->insert(msg);
            if (ret == false)
            {
                LOG_ERROR("向数据库插入新消息失败！");
                return;
            }
        }

    private:

        /// @brief 根据一批用户id，获取<用户id, 用户信息>
        /// @param request_id 请求id
        /// @param user_id_lists 输入型参数，一批用户id
        /// @param user_lists 输出型参数，一批<用户id, 用户信息>
        /// @return 是否成功
        bool _get_user_info(const std::string &request_id,
                      const std::unordered_set<std::string> &user_id_lists,
                      std::unordered_map<std::string, UserInfo> *user_lists)
        {
            auto channel = _service_manager->get(_user_service_name);
            if (!channel)
            {
                LOG_ERROR("没有可供访问的用户子服务 {} 的节点！", _user_service_name);
                return false;
            }

            // 准备调用用户子服务
            UserService_Stub stub(channel.get());
            GetMultiUserInfoReq req;
            GetMultiUserInfoRsp rsp;
            req.set_request_id(request_id);
            for (const auto &id : user_id_lists)
            {
                req.add_users_id(id);
            }
            brpc::Controller cntl;
            stub.GetMultiUserInfo(&cntl, &req, &rsp, nullptr); // 真正调用
            if (cntl.Failed() == true || rsp.success() == false) {
                LOG_ERROR("用户子服务调用失败：{}！", cntl.ErrorText());
                return false;
            }
            const auto &umap = rsp.users_info();
            for (auto it = umap.begin(); it != umap.end(); ++it)
            {
                user_lists->insert(std::make_pair(it->first, it->second));
            }
            return true;
        }

        /// @brief 根据一批文件id获取<文件id, 文件内容>
        /// @param request_id 
        /// @param file_id_lists 输入型参数，表示所有想要获取的文件id
        /// @param file_data_lists 输出型参数，一批<文件id, 文件内容>的键值对
        /// @return 是否成功
        bool _get_files(const std::string &request_id,
                      const std::unordered_set<std::string> &file_id_lists,
                      std::unordered_map<std::string, std::string> *file_data_lists)
        {
            auto service_manager = _service_manager->get(_file_service_name);
            if (!service_manager)
            {
                LOG_ERROR("没有提供文件子服务 {} 的节点！", _file_service_name);
                return false;
            }

            // 准备调用文件子服务
            FileService_Stub stub(service_manager.get());
            GetMultiFileReq req;
            GetMultiFileRsp rsp;
            req.set_request_id(request_id);
            for (const auto &fid : file_id_lists) {
                req.add_file_id_list(fid);
            }
            brpc::Controller cntl;
            stub.GetMultiFile(&cntl, &req, &rsp, nullptr); // 真正的调用
            if (cntl.Failed() == true || rsp.success() == false) {
                LOG_ERROR("文件子服务调用失败，原因：{}！", cntl.ErrorText());
                return false;
            }
            const google::protobuf::Map<std::string, chen_im::FileDownloadData> &file_map = rsp.file_data();
            for (auto it = file_map.begin(); it != file_map.end(); ++it)
            {
                file_data_lists->insert(std::make_pair(it->first, it->second.file_content()));
            }
            return true;
        }


        /// @brief 文件的上传至文件管理子服务
        /// @param filename 文件名
        /// @param body 文件内容
        /// @param fsize 文件大小
        /// @param file_id 文件id
        /// @return 
        bool _PutFile(const std::string &filename,
                      const std::string &body,
                      const int64_t fsize,
                      std::string &file_id)
        {
            
            auto channel = _service_manager->get(_file_service_name);
            if (!channel)
            {
                LOG_ERROR("没有可供访问的文件子服务 {} 的节点！", _file_service_name);
                return false;
            }
            FileService_Stub stub(channel.get());
            PutSingleFileReq req;
            PutSingleFileRsp rsp;
            req.mutable_file_data()->set_file_name(filename);
            req.mutable_file_data()->set_file_size(fsize);
            req.mutable_file_data()->set_file_content(body);
            brpc::Controller cntl;
            stub.PutSingleFile(&cntl, &req, &rsp, nullptr);
            if (cntl.Failed() == true || rsp.success() == false)
            {
                LOG_ERROR("文件子服务调用失败，原因：{}！", cntl.ErrorText());
                return false;
            }
            file_id = rsp.file_info().file_id();
            return true;
        }
    };

    class MessageServer
    {
    private:
        Discovery::ptr _service_discoverer;
        Registry::ptr _registry_client;
        MQClient::ptr _mq_client;
        std::shared_ptr<elasticlient::Client> _es_client;
        std::shared_ptr<odb::mysql::database> _mysql_client;
        std::shared_ptr<brpc::Server> _rpc_server;

    public:
        using ptr = std::shared_ptr<MessageServer>;
        MessageServer(const MQClient::ptr &mq_client,
                      const Discovery::ptr service_discoverer,
                      const Registry::ptr &reg_client,
                      const std::shared_ptr<elasticlient::Client> &es_client,
                      const std::shared_ptr<odb::mysql::database> &mysql_client,
                      const std::shared_ptr<brpc::Server> &server) 
            : _mq_client(mq_client),
            _service_discoverer(service_discoverer),
            _registry_client(reg_client),
            _es_client(es_client),
            _mysql_client(mysql_client),
            _rpc_server(server) 
        {}
        
        ~MessageServer() {}
        // 搭建RPC服务器，并启动服务器
        void start()
        {
            _rpc_server->RunUntilAskedToQuit();
        }
    };

    class MessageServerFactory
    {
    private:
        Registry::ptr _registry_client;

        std::shared_ptr<elasticlient::Client> _es_client;
        std::shared_ptr<odb::mysql::database> _mysql_client;

        std::string _user_service_name;
        std::string _file_service_name;
        ServiceManager::ptr _service_manager;
        Discovery::ptr _service_discoverer;

        std::string _exchange_name;
        std::string _queue_name;
        MQClient::ptr _mq_client;
        std::shared_ptr<brpc::Server> _rpc_server;

    public:
        // 构造es客户端对象
        void make_es_object(const std::vector<std::string> host_list)
        {
            _es_client = ESClientFactory::create(host_list);
        }
        // 构造mysql客户端对象
        void make_mysql_object(
            const std::string &user,
            const std::string &pswd,
            const std::string &host,
            const std::string &db,
            const std::string &cset,
            int port,
            int conn_pool_count)
        {
            _mysql_client = ODBFactory::create(user, pswd, db, host, port, cset, conn_pool_count);
        }
        // 用于构造服务发现客户端&信道管理对象
        void make_discovery_object(const std::string &reg_host,
                                   const std::string &base_service_name,
                                   const std::string &file_service_name,
                                   const std::string &user_service_name)
        {
            _user_service_name = user_service_name;
            _file_service_name = file_service_name;
            _service_manager = std::make_shared<ServiceManager>();
            _service_manager->concern(file_service_name);
            _service_manager->concern(user_service_name);
            LOG_DEBUG("设置文件子服务为需添加管理的子服务：{}", file_service_name);
            auto put_cb = std::bind(&ServiceManager::when_service_online, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            auto del_cb = std::bind(&ServiceManager::when_service_offline, _service_manager.get(), std::placeholders::_1, std::placeholders::_2);
            _service_discoverer = std::make_shared<Discovery>(reg_host, base_service_name, put_cb, del_cb);
        }
        // 用于构造服务注册客户端对象
        void make_registry_object(const std::string &reg_host,
                                  const std::string &service_name,
                                  const std::string &access_host)
        {
            _registry_client = std::make_shared<Registry>(reg_host);
            _registry_client->registry(service_name, access_host);
        }
        // 用于构造消息队列客户端对象
        void make_mq_object(const std::string &user,
                            const std::string &passwd,
                            const std::string &host,
                            const std::string &exchange_name,
                            const std::string &queue_name,
                            const std::string &binding_key)
        {
            _exchange_name = exchange_name;
            _queue_name = queue_name;
            _mq_client = std::make_shared<MQClient>(user, passwd, host);
            _mq_client->declear_all_components(exchange_name, queue_name, binding_key);
        }
        void make_rpc_server(uint16_t port, int32_t timeout, uint8_t num_threads)
        {
            if (!_es_client)
            {
                LOG_ERROR("还未初始化ES搜索引擎模块！");
                abort();
            }
            if (!_mysql_client)
            {
                LOG_ERROR("还未初始化Mysql数据库模块！");
                abort();
            }
            if (!_service_manager)
            {
                LOG_ERROR("还未初始化信道管理模块！");
                abort();
            }
            _rpc_server = std::make_shared<brpc::Server>();

            MessageServiceImpl *msg_service = new MessageServiceImpl(_es_client,
                                                                     _mysql_client, _service_manager, _file_service_name, _user_service_name);
            int ret = _rpc_server->AddService(msg_service,
                                              brpc::ServiceOwnership::SERVER_OWNS_SERVICE);
            if (ret == -1)
            {
                LOG_ERROR("添加Rpc服务失败！");
                abort();
            }
            brpc::ServerOptions options;
            options.idle_timeout_sec = timeout;
            options.num_threads = num_threads;
            ret = _rpc_server->Start(port, &options);
            if (ret == -1)
            {
                LOG_ERROR("rpc服务启动失败！");
                abort();
            }

            std::function<void(const char*, size_t)> callback = std::bind(&MessageServiceImpl::when_get_an_message, msg_service,
                                      std::placeholders::_1, std::placeholders::_2);
            if(!callback) {
                LOG_WARN("callback是无效的！！！");
            }
            
            // 当brpc服务器启动后再设置消息队列客户端的回调函数
            _mq_client->consume_message(_queue_name, "msg_queue", callback);
        }
        // 构造RPC服务器对象
        MessageServer::ptr build()
        {
            if (!_service_discoverer)
            {
                LOG_ERROR("还未初始化服务发现模块！");
                abort();
            }
            if (!_registry_client)
            {
                LOG_ERROR("还未初始化服务注册模块！");
                abort();
            }
            if (!_rpc_server)
            {
                LOG_ERROR("还未初始化RPC服务器模块！");
                abort();
            }

            MessageServer::ptr server = std::make_shared<MessageServer>(
                _mq_client, _service_discoverer, _registry_client,
                _es_client, _mysql_client, _rpc_server);
            return server;
        }
    };
}

