--- FILE: ./index.html ---
å†…å®¹:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue Chat Room</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

--- FILE: ./.eslintrc.js ---
å†…å®¹:
module.exports = {
    root: true,
    env: {
      node: true,
      'vue/setup-compiler-macros': true
    },
    extends: [
      'plugin:vue/vue3-essential',
      'eslint:recommended'
    ],
    parserOptions: {
      parser: '@babel/eslint-parser'
    },
    rules: {
      'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
      'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off'
    }
  }

--- FILE: ./vite.config.js ---
å†…å®¹:
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  base: '/', // æ·»åŠ è¿™è¡Œ
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
  server: {
    host: '0.0.0.0',
    port: 8080,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  preview: {
    port: 4173,
    host: '0.0.0.0'
  }
})

--- FILE: ./all_extracted_code.txt ---
å†…å®¹:




--- FILE: ./.prettierrc ---
å†…å®¹:
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100
}

--- FILE: ./run.md ---
å†…å®¹:
npm run build
npm run serve

--- FILE: ./0_extract_content.py ---
å†…å®¹:
import os

def is_image_dir(path):
    return os.path.basename(os.path.normpath(path)) == "image"

def process_source_file(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"ã€æ— æ³•è¯»å–æ–‡ä»¶å†…å®¹ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶æˆ–ç¼–ç é—®é¢˜ï¼š{e}ã€‘"

def main():
    output_filename = "all_extracted_code.txt"
    with open(output_filename, 'w', encoding='utf-8') as out_file:
        # ä»å½“å‰ç›®å½•å¼€å§‹é€’å½’éå†
        for root, dirs, files in os.walk('.'):
            # æ’é™¤åä¸º build çš„ç›®å½•
            if 'node_modules' in dirs:
                dirs.remove('node_modules')
            if 'dist' in dirs:
                dirs.remove('dist')
            if 'font' in dirs:
                dirs.remove('font')

            relative_root = os.path.relpath(root, '.')
            # åˆ¤æ–­å½“å‰ç›®å½•æ˜¯å¦ä¸º image ç›®å½•
            if is_image_dir(root):
                for filename in files:
                    rel_path = os.path.join(relative_root, filename)
                    out_file.write(f"--- IMAGE FILE: {rel_path} ---\n")
                    out_file.write(f"æ–‡ä»¶å: {filename}\n\n")
            else:
                for filename in files:
                    rel_path = os.path.join(relative_root, filename)
                    out_file.write(f"--- FILE: {rel_path} ---\n")
                    content = process_source_file(os.path.join(root, filename))
                    out_file.write("å†…å®¹:\n")
                    out_file.write(content + "\n\n")

if __name__ == '__main__':
    main()


--- FILE: ./package.json ---
å†…å®¹:
{
    "name": "vue-chat-room",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "serve": "vite preview --host 0.0.0.0",
        "lint": "eslint --ext .js,.vue src"
    },
    "dependencies": {
        "axios": "^0.21.1",
        "date-fns": "^2.23.0",
        "element-plus": "^2.2.0",
        "pinia": "^2.0.14",
        "protobufjs": "^6.11.2",
        "vue": "^3.2.31",
        "vue-router": "^4.0.12"
    },
    "devDependencies": {
        "@babel/core": "^7.14.6",
        "@babel/eslint-parser": "^7.14.7",
        "@vitejs/plugin-vue": "^2.2.0",
        "eslint": "^7.32.0",
        "eslint-plugin-vue": "^8.0.3",
        "sass": "^1.32.7",
        "vite": "^2.8.0"
    }
}

--- FILE: src/App.vue ---
å†…å®¹:
<template>
  <div class="app-container">
    <router-view />
  </div>
</template>

<style>
body {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
}

.app-container {
  height: 100vh;
  width: 100%;
}
</style>


--- FILE: src/main.js ---
å†…å®¹:
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

const app = createApp(App)

app.use(createPinia())
app.use(router)
app.use(ElementPlus)

app.mount('#app')


--- FILE: src/components/user/UserProfileDialog.vue ---
å†…å®¹:
<template>
    <v-dialog v-model="dialog" max-width="290">
        <v-card>
            <v-card-title>
                <span class="headline">Session Detail</span>
            </v-card-title>
            <v-card-text>
                <v-text-field v-model="sessionName" label="Session Name"></v-text-field>
                <v-text-field v-model="sessionDescription" label="Session Description"></v-text-field>
            </v-card-text>
            <v-card-actions>
                <v-spacer></v-spacer>
                <v-btn color="blue darken-1" text @click="dialog = false">Cancel</v-btn>
                <v-btn color="blue darken-1" text @click="updateSession">Update</v-btn>
            </v-card-actions>
        </v-card>
    </v-dialog>
</template>

--- FILE: src/components/friend/AddFriendDialog.vue ---
å†…å®¹:
<template>
    <v-dialog v-model="dialog" max-width="290">
        <v-card>
            <v-card-title>
                <span class="headline">Add Friend</span>
            </v-card-title>
            <v-card-text>
                <v-text-field v-model="friendUsername" label="Friend Username"></v-text-field>
            </v-card-text>
            <v-card-actions>
                <v-spacer></v-spacer>
                <v-btn color="blue darken-1" text @click="dialog = false">Cancel</v-btn>
                <v-btn color="blue darken-1" text @click="addFriend">Add</v-btn>
            </v-card-actions>
        </v-card>
    </v-dialog>
</template>

--- FILE: src/components/friend/CreateGroupDialog.vue ---
å†…å®¹:
<template>  
    <div>
        <h1>User Profile</h1>
        <p>Username: {{ user.username }}</p>
        <p>Email: {{ user.email }}</p>
        <p>First Name: {{ user.first_name }}</p>
        <p>Last Name: {{ user.last_name }}</p>
        <p>Friends:</p>
        <div v-for="friend in user.friends" :key="friend.id">
            <p>{{ friend.username }}</p>
        </div>
    </div>
</template>

--- FILE: src/components/friend/FriendList.vue ---
å†…å®¹:
<template>
    <div class="friend-list">
      <div class="search-bar">
        <el-input 
          v-model="searchText" 
          placeholder="æœç´¢å¥½å‹" 
          prefix-icon="el-icon-search"
          clearable
        ></el-input>
      </div>
      
      <!-- å¥½å‹è¯·æ±‚é€šçŸ¥ -->
      <div v-if="pendingRequests.length > 0" class="friend-requests" @click="openFriendRequests">
        <i class="el-icon-bell"></i>
        <span>å¥½å‹è¯·æ±‚ ({{ pendingRequests.length }})</span>
        <i class="el-icon-right"></i>
      </div>
      
      <!-- å¥½å‹åˆ†ç»„ -->
      <el-collapse v-model="activeGroups">
        <el-collapse-item title="æˆ‘çš„å¥½å‹" name="my-friends">
          <div 
            v-for="friend in filteredFriends" 
            :key="friend.userId" 
            class="friend-item"
            @click="selectFriend(friend.userId)"
          >
            <el-avatar :size="40" :src="friend.avatar || defaultAvatar"></el-avatar>
            <div class="friend-info">
              <div class="friend-name">{{ friend.nickname }}</div>
              <div class="friend-signature">{{ friend.description || 'è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡å†™' }}</div>
            </div>
          </div>
          
          <div v-if="filteredFriends.length === 0" class="empty-list">
            {{ friends.length === 0 ? 'è¿˜æ²¡æœ‰å¥½å‹' : 'æ²¡æœ‰åŒ¹é…çš„å¥½å‹' }}
          </div>
        </el-collapse-item>
      </el-collapse>
    </div>
  </template>
  
  <script setup>
  import { ref, computed } from 'vue';
  import { ElMessageBox } from 'element-plus';
  import { useDataCenter } from '@/store/dataCenter';
  
  const props = defineProps({
    friends: {
      type: Array,
      default: () => []
    }
  });
  
  const emit = defineEmits(['selectFriend', 'addFriend']);
  
  const dataCenter = useDataCenter();
  const searchText = ref('');
  const activeGroups = ref(['my-friends']);
  const defaultAvatar = '/assets/default-avatar.png';
  
  // è®¡ç®—å±æ€§ï¼šè·å–å¾…å¤„ç†çš„å¥½å‹è¯·æ±‚
  const pendingRequests = computed(() => dataCenter.pendingFriendEvents);
  
  // è®¡ç®—å±æ€§ï¼šç­›é€‰å¥½å‹
  const filteredFriends = computed(() => {
    if (!searchText.value) return props.friends;
    
    return props.friends.filter(friend => 
      friend.nickname.toLowerCase().includes(searchText.value.toLowerCase()) ||
      friend.username.toLowerCase().includes(searchText.value.toLowerCase())
    );
  });
  
  // é€‰æ‹©å¥½å‹
  const selectFriend = (friendId) => {
    emit('selectFriend', friendId);
  };
  
  // æ‰“å¼€å¥½å‹è¯·æ±‚åˆ—è¡¨
  const openFriendRequests = () => {
    ElMessageBox.confirm(
      'æ‚¨æœ‰æœªå¤„ç†çš„å¥½å‹è¯·æ±‚ï¼Œæ˜¯å¦ç°åœ¨å¤„ç†ï¼Ÿ',
      'å¥½å‹è¯·æ±‚',
      {
        confirmButtonText: 'å»å¤„ç†',
        cancelButtonText: 'ç¨å',
        type: 'info'
      }
    ).then(() => {
      // è·³è½¬åˆ°å¥½å‹è¯·æ±‚é¡µé¢
      // å®ç°æ–¹å¼å–å†³äºä½ çš„è·¯ç”±è®¾è®¡
    }).catch(() => {
      // å–æ¶ˆæ“ä½œ
    });
  };
  </script>
  
  <style lang="scss" scoped>
  .friend-list {
    height: 100%;
    overflow-y: auto;
    
    .search-bar {
      padding: 10px 16px;
      
      .el-input {
        margin-bottom: 10px;
      }
    }
    
    .friend-requests {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      margin-bottom: 10px;
      background-color: #f5f7fa;
      border-radius: 4px;
      cursor: pointer;
      
      i.el-icon-bell {
        font-size: 18px;
        color: #409EFF;
        margin-right: 10px;
      }
      
      span {
        flex: 1;
        font-size: 14px;
      }
    }
    
    :deep(.el-collapse) {
      border: none;
      
      .el-collapse-item__header {
        font-size: 15px;
        font-weight: 500;
        height: 40px;
        line-height: 40px;
        background-color: #f5f7fa;
        padding-left: 16px;
      }
      
      .el-collapse-item__wrap {
        border: none;
      }
      
      .el-collapse-item__content {
        padding: 0;
      }
    }
    
    .friend-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      cursor: pointer;
      
      &:hover {
        background-color: #f5f7fa;
      }
      
      .friend-info {
        margin-left: 12px;
        
        .friend-name {
          font-size: 15px;
          color: #333;
          margin-bottom: 4px;
        }
        
        .friend-signature {
          font-size: 13px;
          color: #999;
        }
      }
    }
    
    .empty-list {
      padding: 20px;
      text-align: center;
      color: #909399;
      font-size: 14px;
    }
  }
  </style>

--- FILE: src/components/chat/MessageEditor.vue ---
å†…å®¹:
<template>
    <div class="message-editor">
      <div class="toolbar">
        <el-tooltip content="è¡¨æƒ…" placement="top">
          <el-button icon="el-icon-smile" circle plain @click="showEmoji = !showEmoji"></el-button>
        </el-tooltip>
        
        <el-tooltip content="å›¾ç‰‡" placement="top">
          <el-button icon="el-icon-picture" circle plain @click="selectImage"></el-button>
        </el-tooltip>
        
        <el-tooltip content="æ–‡ä»¶" placement="top">
          <el-button icon="el-icon-folder" circle plain @click="selectFile"></el-button>
        </el-tooltip>
        
        <el-tooltip content="å½•éŸ³" placement="top">
          <el-button 
            icon="el-icon-microphone" 
            circle 
            plain 
            :class="{ 'recording': isRecording }"
            @mousedown="startRecording" 
            @mouseup="stopRecording"
            @mouseleave="cancelRecording"
          ></el-button>
        </el-tooltip>
        
        <input 
          type="file" 
          ref="imageInput" 
          accept="image/*" 
          style="display: none" 
          @change="handleImageSelected"
        />
        
        <input 
          type="file" 
          ref="fileInput" 
          style="display: none" 
          @change="handleFileSelected"
        />
      </div>
      
      <!-- è¡¨æƒ…é¢æ¿ -->
      <div v-if="showEmoji" class="emoji-panel">
        <div 
          v-for="emoji in emojiList" 
          :key="emoji" 
          class="emoji-item"
          @click="insertEmoji(emoji)"
        >
          {{ emoji }}
        </div>
      </div>
      
      <div class="input-area">
        <el-input
          v-model="content"
          type="textarea"
          :rows="3"
          placeholder="è¾“å…¥æ¶ˆæ¯..."
          resize="none"
          @keydown.enter.exact.prevent="sendTextMessage"
        ></el-input>
      </div>
      
      <div class="send-area">
        <span v-if="isRecording" class="recording-tip">
          æ­£åœ¨å½•éŸ³... {{ recordingDuration }}s
        </span>
        <span v-else class="shortcut-tip">
          æŒ‰ Enter å‘é€ï¼ŒShift + Enter æ¢è¡Œ
        </span>
        
        <el-button type="primary" @click="sendTextMessage" :disabled="!content.trim()">
          å‘é€
        </el-button>
      </div>
    </div>
  </template>
  
  <script setup>
  import { ref, onBeforeUnmount } from 'vue';
  import { ElMessage } from 'element-plus';
  
  const emit = defineEmits(['send']);
  
  // çŠ¶æ€å˜é‡
  const content = ref('');
  const showEmoji = ref(false);
  const isRecording = ref(false);
  const recordingDuration = ref(0);
  const recordingTimer = ref(null);
  const mediaRecorder = ref(null);
  const audioChunks = ref([]);
  const imageInput = ref(null);
  const fileInput = ref(null);
  
  // è¡¨æƒ…åˆ—è¡¨
  const emojiList = [
    'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ˜Š', 
    'ğŸ˜‡', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Œ', 'ğŸ˜', 'ğŸ¥°', 'ğŸ˜˜', 'ğŸ˜—', 
    'ğŸ˜™', 'ğŸ˜š', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ¤¨', 'ğŸ§', 
    'ğŸ¤“', 'ğŸ˜', 'ğŸ¤©', 'ğŸ¥³', 'ğŸ˜', 'ğŸ˜’', 'ğŸ˜', 'ğŸ˜”', 'ğŸ˜Ÿ'
  ];
  
  // æ–¹æ³•
  const sendTextMessage = () => {
    if (!content.value.trim()) return;
    
    emit('send', content.value, 'text');
    content.value = '';
    showEmoji.value = false;
  };
  
  const insertEmoji = (emoji) => {
    content.value += emoji;
  };
  
  const selectImage = () => {
    imageInput.value.click();
  };
  
  const handleImageSelected = async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.includes('image/')) {
      ElMessage.error('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
      return;
    }
    
    // é™åˆ¶æ–‡ä»¶å¤§å°
    if (file.size > 10 * 1024 * 1024) {
      ElMessage.error('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡10MB');
      return;
    }
    
    try {
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œå¯èƒ½éœ€è¦å…ˆä¸Šä¼ å›¾ç‰‡ï¼Œç„¶åè·å–å›¾ç‰‡URL
      // const formData = new FormData();
      // formData.append('file', file);
      // const response = await fileApi.uploadImage(formData);
      // emit('send', response.fileUrl, 'image');
      
      // ä¸´æ—¶ä½¿ç”¨æœ¬åœ°é¢„è§ˆ
      const reader = new FileReader();
      reader.onload = (e) => {
        emit('send', e.target.result, 'image');
      };
      reader.readAsDataURL(file);
    } catch (error) {
      console.error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥:', error);
      ElMessage.error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥');
    } finally {
      // æ¸…ç©ºè¾“å…¥æ¡†ï¼Œä»¥ä¾¿ä¸‹æ¬¡é€‰æ‹©åŒä¸€æ–‡ä»¶æ—¶ä»èƒ½è§¦å‘changeäº‹ä»¶
      event.target.value = '';
    }
  };
  
  const selectFile = () => {
    fileInput.value.click();
  };
  
  const handleFileSelected = async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    // é™åˆ¶æ–‡ä»¶å¤§å°
    if (file.size > 100 * 1024 * 1024) {
      ElMessage.error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡100MB');
      return;
    }
    
    try {
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œéœ€è¦å…ˆä¸Šä¼ æ–‡ä»¶ï¼Œç„¶åè·å–æ–‡ä»¶URL
      // const formData = new FormData();
      // formData.append('file', file);
      // const response = await fileApi.uploadFile(formData);
      // emit('send', response.fileUrl, 'file');
      
      // ä¸´æ—¶æ¨¡æ‹Ÿ
      ElMessage.success('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
      emit('send', file.name, 'file');
    } catch (error) {
      console.error('ä¸Šä¼ æ–‡ä»¶å¤±è´¥:', error);
      ElMessage.error('ä¸Šä¼ æ–‡ä»¶å¤±è´¥');
    } finally {
      event.target.value = '';
    }
  };
  
  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      mediaRecorder.value = new MediaRecorder(stream);
      audioChunks.value = [];
      
      mediaRecorder.value.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.value.push(event.data);
        }
      };
      
      mediaRecorder.value.onstop = async () => {
        if (audioChunks.value.length === 0) return;
        
        const audioBlob = new Blob(audioChunks.value, { type: 'audio/wav' });
        
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œéœ€è¦ä¸Šä¼ è¯­éŸ³æ–‡ä»¶
        // const formData = new FormData();
        // formData.append('file', audioBlob);
        // const response = await fileApi.uploadVoice(formData);
        // emit('send', response.fileUrl, 'voice');
        
        // ä¸´æ—¶ä½¿ç”¨æœ¬åœ°URL
        const audioUrl = URL.createObjectURL(audioBlob);
        emit('send', audioUrl, 'voice');
        
        // å…³é—­éº¦å…‹é£
        stopMediaTracks(mediaRecorder.value.stream);
      };
      
      mediaRecorder.value.start();
      isRecording.value = true;
      
      // å¼€å§‹è®¡æ—¶
      recordingDuration.value = 0;
      recordingTimer.value = setInterval(() => {
        recordingDuration.value++;
        
        // é™åˆ¶å½•éŸ³æ—¶é•¿ï¼ˆ60ç§’ï¼‰
        if (recordingDuration.value >= 60) {
          stopRecording();
        }
      }, 1000);
    } catch (error) {
      console.error('å½•éŸ³å¤±è´¥:', error);
      ElMessage.error('æ— æ³•è·å–éº¦å…‹é£æƒé™');
      isRecording.value = false;
    }
  };
  
  const stopRecording = () => {
    if (!isRecording.value || !mediaRecorder.value) return;
    
    clearInterval(recordingTimer.value);
    mediaRecorder.value.stop();
    isRecording.value = false;
  };
  
  const cancelRecording = () => {
    if (!isRecording.value) return;
    
    clearInterval(recordingTimer.value);
    mediaRecorder.value.stop();
    isRecording.value = false;
    
    // æ¸…ç©ºå½•éŸ³æ•°æ®
    audioChunks.value = [];
    
    // å…³é—­éº¦å…‹é£
    if (mediaRecorder.value && mediaRecorder.value.stream) {
      stopMediaTracks(mediaRecorder.value.stream);
    }
  };
  
  const stopMediaTracks = (stream) => {
    if (!stream) return;
    
    stream.getTracks().forEach(track => {
      track.stop();
    });
  };
  
  // ç»„ä»¶é”€æ¯å‰æ¸…ç†èµ„æº
  onBeforeUnmount(() => {
    if (recordingTimer.value) {
      clearInterval(recordingTimer.value);
    }
    
    if (mediaRecorder.value && mediaRecorder.value.stream) {
      stopMediaTracks(mediaRecorder.value.stream);
    }
  });
  </script>
  
  <style lang="scss" scoped>
  .message-editor {
    border-top: 1px solid #eaeaea;
    background-color: #fff;
    
    .toolbar {
      display: flex;
      padding: 10px 20px;
      gap: 10px;
      
      .el-button.recording {
        background-color: #f56c6c;
        color: white;
      }
    }
    
    .emoji-panel {
      display: flex;
      flex-wrap: wrap;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 4px;
      margin: 0 20px;
      
      .emoji-item {
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 20px;
        cursor: pointer;
        
        &:hover {
          background-color: #e0e0e0;
          border-radius: 4px;
        }
      }
    }
    
    .input-area {
      padding: 0 20px;
      
      .el-textarea {
        :deep(.el-textarea__inner) {
          resize: none;
          border: none;
          padding: 10px 0;
          font-size: 15px;
          line-height: 1.5;
          
          &:focus {
            box-shadow: none;
          }
        }
      }
    }
    
    .send-area {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      
      .shortcut-tip, .recording-tip {
        font-size: 13px;
        color: #999;
      }
      
      .recording-tip {
        color: #f56c6c;
        animation: blink 1s infinite;
      }
    }
  }
  
  @keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
  }
  </style>

--- FILE: src/components/chat/SessionList.vue ---
å†…å®¹:
<template>
    <div class="session-list">
      <div 
        v-for="session in sessions" 
        :key="session.chatSessionId" 
        class="session-item"
        :class="{ 'active': session.chatSessionId === currentSessionId }"
        @click="selectSession(session.chatSessionId)"
      >
        <el-avatar :size="40" :src="session.avatar || defaultAvatar"></el-avatar>
        
        <div class="session-info">
          <div class="session-header">
            <span class="session-name">{{ session.chatSessionName }}</span>
            <span class="session-time">{{ formatTime(session.lastMessage?.sendTime) }}</span>
          </div>
          
          <div class="session-content">
            <div class="session-msg">
              {{ formatLastMessage(session.lastMessage) }}
            </div>
            
            <div v-if="session.unreadCount > 0" class="unread-badge">
              {{ session.unreadCount > 99 ? '99+' : session.unreadCount }}
            </div>
          </div>
        </div>
      </div>
      
      <div v-if="sessions.length === 0" class="empty-list">
        <el-empty description="æ²¡æœ‰ä¼šè¯" :image-size="64"></el-empty>
      </div>
    </div>
  </template>
  
  <script setup>
  import { defineProps, defineEmits } from 'vue';
  import { format } from 'date-fns';
  
  const props = defineProps({
    sessions: {
      type: Array,
      default: () => []
    },
    currentSessionId: {
      type: String,
      default: ''
    }
  });
  
  const emit = defineEmits(['selectSession']);
  
  const defaultAvatar = '/assets/default-avatar.png';
  
  // é€‰æ‹©ä¼šè¯
  const selectSession = (sessionId) => {
    emit('selectSession', sessionId);
  };
  
  // æ ¼å¼åŒ–æ—¶é—´
  const formatTime = (timestamp) => {
    if (!timestamp) return '';
    
    const msgDate = new Date(parseInt(timestamp));
    const today = new Date();
    
    if (msgDate.toDateString() === today.toDateString()) {
      return format(msgDate, 'HH:mm');
    } else {
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      
      if (msgDate.toDateString() === yesterday.toDateString()) {
        return 'æ˜¨å¤©';
      } else {
        return format(msgDate, 'MM/dd');
      }
    }
  };
  
  // æ ¼å¼åŒ–æœ€åä¸€æ¡æ¶ˆæ¯
  const formatLastMessage = (message) => {
    if (!message) return '';
    
    switch (message.msgType) {
      case 'text':
        return message.content;
      case 'image':
        return '[å›¾ç‰‡]';
      case 'file':
        return '[æ–‡ä»¶]';
      case 'voice':
        return '[è¯­éŸ³]';
      default:
        return '[æœªçŸ¥æ¶ˆæ¯ç±»å‹]';
    }
  };
  </script>
  
  <style lang="scss" scoped>
  .session-list {
    height: 100%;
    overflow-y: auto;
    
    .session-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      cursor: pointer;
      transition: background-color 0.2s;
      
      &:hover {
        background-color: #f5f7fa;
      }
      
      &.active {
        background-color: #ecf5ff;
      }
      
      .session-info {
        flex: 1;
        margin-left: 12px;
        overflow: hidden;
        
        .session-header {
          display: flex;
          justify-content: space-between;
          margin-bottom: 4px;
          
          .session-name {
            font-size: 15px;
            font-weight: 500;
            color: #333;
          }
          
          .session-time {
            font-size: 12px;
            color: #999;
          }
        }
        
        .session-content {
          display: flex;
          justify-content: space-between;
          align-items: center;
          
          .session-msg {
            flex: 1;
            font-size: 13px;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
          }
          
          .unread-badge {
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            font-size: 12px;
            background-color: #f56c6c;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 5px;
          }
        }
      }
    }
    
    .empty-list {
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #909399;
    }
  }
  </style>

--- FILE: src/components/chat/MessageDisplay.vue ---
å†…å®¹:
<template>
    <div class="message-container" ref="messageContainer">
      <div class="message-list">
        <div v-if="isLoading" class="loading-more">
          <el-spinner type="primary" size="small"></el-spinner>
          <span>åŠ è½½å†å²æ¶ˆæ¯ä¸­...</span>
        </div>
  
        <div v-if="showLoadMore" class="load-more" @click="loadMoreMessages">
          <span>åŠ è½½æ›´å¤šæ¶ˆæ¯</span>
        </div>
        
        <template v-for="(message, index) in messages" :key="message.msgId">
          <!-- æ—¥æœŸåˆ†éš”çº¿ -->
          <div v-if="shouldShowDateDivider(message, index)" class="date-divider">
            <span>{{ formatDate(message.sendTime) }}</span>
          </div>
          
          <!-- æ¶ˆæ¯é¡¹ -->
          <div 
            class="message-item" 
            :class="{ 'self-message': message.senderId === currentUserId }"
          >
            <el-avatar 
              :size="36" 
              :src="getUserAvatar(message.senderId)" 
              class="avatar"
            ></el-avatar>
            
            <div class="message-content">
              <div class="sender-name" v-if="message.senderId !== currentUserId">
                {{ getUserName(message.senderId) }}
              </div>
              
              <div class="message-bubble">
                <!-- æ–‡æœ¬æ¶ˆæ¯ -->
                <div v-if="message.msgType === 'text'" class="text-message">
                  {{ message.content }}
                </div>
                
                <!-- å›¾ç‰‡æ¶ˆæ¯ -->
                <div v-else-if="message.msgType === 'image'" class="image-message">
                  <el-image 
                    :src="message.content" 
                    :preview-src-list="[message.content]"
                    fit="cover"
                  ></el-image>
                </div>
                
                <!-- æ–‡ä»¶æ¶ˆæ¯ -->
                <div v-else-if="message.msgType === 'file'" class="file-message">
                  <div class="file-icon">
                    <i class="el-icon-document"></i>
                  </div>
                  <div class="file-info">
                    <div class="file-name">{{ getFileName(message.content) }}</div>
                    <div class="file-size">{{ getFileSize(message.fileSize) }}</div>
                  </div>
                  <el-button 
                    size="small" 
                    type="primary" 
                    icon="el-icon-download" 
                    circle
                    @click="downloadFile(message.content, message.fileName)"
                  ></el-button>
                </div>
                
                <!-- è¯­éŸ³æ¶ˆæ¯ -->
                <div v-else-if="message.msgType === 'voice'" class="voice-message">
                  <div class="voice-icon" @click="playVoice(message.content)">
                    <i class="el-icon-microphone"></i>
                  </div>
                  <div class="voice-duration">{{ message.duration }}â€³</div>
                </div>
              </div>
              
              <div class="message-time">
                {{ formatTime(message.sendTime) }}
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>
  </template>
  
  <script setup>
  import { ref, computed, onMounted, nextTick, watch } from 'vue';
  import { useDataCenter } from '@/store/dataCenter';
  import { format } from 'date-fns';
  import { ElMessage } from 'element-plus';
  
  const props = defineProps({
    messages: {
      type: Array,
      default: () => []
    },
    currentUserId: {
      type: String,
      required: true
    }
  });
  
  const dataCenter = useDataCenter();
  const messageContainer = ref(null);
  const isLoading = ref(false);
  const showLoadMore = ref(true);
  const currentAudio = ref(null);
  
  // è·å–ç”¨æˆ·å¤´åƒ
  const getUserAvatar = (userId) => {
    if (userId === props.currentUserId) {
      return dataCenter.currentUser?.avatar || '/assets/default-avatar.png';
    }
    
    const friend = dataCenter.friendList.find(f => f.userId === userId);
    return friend?.avatar || '/assets/default-avatar.png';
  };
  
  // è·å–ç”¨æˆ·åç§°
  const getUserName = (userId) => {
    const friend = dataCenter.friendList.find(f => f.userId === userId);
    return friend?.nickname || userId;
  };
  
  // æ ¼å¼åŒ–æ—¥æœŸ
  const formatDate = (timestamp) => {
    const date = new Date(parseInt(timestamp));
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    if (date.toDateString() === today.toDateString()) {
      return 'ä»Šå¤©';
    } else if (date.toDateString() === yesterday.toDateString()) {
      return 'æ˜¨å¤©';
    } else {
      return format(date, 'yyyyå¹´MMæœˆddæ—¥');
    }
  };
  
  // æ ¼å¼åŒ–æ—¶é—´
  const formatTime = (timestamp) => {
    return format(new Date(parseInt(timestamp)), 'HH:mm');
  };
  
  // æ˜¯å¦æ˜¾ç¤ºæ—¥æœŸåˆ†éš”çº¿
  const shouldShowDateDivider = (message, index) => {
    if (index === 0) return true;
    
    const currentDate = new Date(parseInt(message.sendTime));
    const prevDate = new Date(parseInt(props.messages[index - 1].sendTime));
    
    return currentDate.toDateString() !== prevDate.toDateString();
  };
  
  // è·å–æ–‡ä»¶å
  const getFileName = (fileUrl) => {
    const parts = fileUrl.split('/');
    return parts[parts.length - 1];
  };
  
  // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
  const getFileSize = (sizeInBytes) => {
    if (!sizeInBytes) return '';
    
    const kb = sizeInBytes / 1024;
    if (kb < 1024) {
      return `${kb.toFixed(2)} KB`;
    } else {
      return `${(kb / 1024).toFixed(2)} MB`;
    }
  };
  
  // ä¸‹è½½æ–‡ä»¶
  const downloadFile = async (fileUrl, fileName) => {
    try {
      ElMessage.info('æ­£åœ¨ä¸‹è½½æ–‡ä»¶...');
      // å®é™…åº”ç”¨ä¸­ï¼Œéœ€è¦è°ƒç”¨APIè·å–æ–‡ä»¶
      // const response = await fileApi.downloadFile(fileUrl);
      // const url = window.URL.createObjectURL(new Blob([response.data]));
      // const link = document.createElement('a');
      // link.href = url;
      // link.setAttribute('download', fileName || getFileName(fileUrl));
      // document.body.appendChild(link);
      // link.click();
      // document.body.removeChild(link);
      
      ElMessage.success('æ–‡ä»¶ä¸‹è½½å®Œæˆ');
    } catch (error) {
      console.error('ä¸‹è½½æ–‡ä»¶å¤±è´¥:', error);
      ElMessage.error('ä¸‹è½½æ–‡ä»¶å¤±è´¥');
    }
  };
  
  // æ’­æ”¾è¯­éŸ³
  const playVoice = (voiceUrl) => {
    // åœæ­¢å½“å‰æ­£åœ¨æ’­æ”¾çš„è¯­éŸ³
    if (currentAudio.value) {
      currentAudio.value.pause();
      currentAudio.value.currentTime = 0;
    }
    
    // æ’­æ”¾æ–°è¯­éŸ³
    const audio = new Audio(voiceUrl);
    audio.onended = () => {
      currentAudio.value = null;
    };
    audio.play();
    currentAudio.value = audio;
  };
  
  // åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯
  const loadMoreMessages = async () => {
    if (isLoading.value || !props.messages.length) return;
    
    try {
      isLoading.value = true;
      
      const sessionId = dataCenter.currentSessionId;
      const oldestMsgId = props.messages[0]?.msgId;
      
      const success = await dataCenter.getHistoryMessages(sessionId, oldestMsgId, 20);
      
      if (!success || dataCenter.currentMessages.length <= props.messages.length) {
        showLoadMore.value = false;
      }
    } catch (error) {
      console.error('åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥:', error);
      ElMessage.error('åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥');
    } finally {
      isLoading.value = false;
    }
  };
  
  // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  const scrollToBottom = () => {
    nextTick(() => {
      if (messageContainer.value) {
        messageContainer.value.scrollTop = messageContainer.value.scrollHeight;
      }
    });
  };
  
  // ç›‘å¬æ¶ˆæ¯å˜åŒ–ï¼Œè‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  watch(() => props.messages.length, (newVal, oldVal) => {
    if (newVal > oldVal) {
      scrollToBottom();
    }
  });
  
  // ç»„ä»¶æŒ‚è½½å®Œæˆï¼Œæ»šåŠ¨åˆ°åº•éƒ¨
  onMounted(() => {
    scrollToBottom();
  });
  </script>
  
  <style lang="scss" scoped>
  .message-container {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    
    .message-list {
      display: flex;
      flex-direction: column;
      
      .loading-more, .load-more {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px 0;
        color: #999;
        font-size: 14px;
        
        span {
          margin-left: 8px;
        }
      }
      
      .load-more {
        cursor: pointer;
        
        &:hover {
          color: #409EFF;
        }
      }
      
      .date-divider {
        display: flex;
        justify-content: center;
        margin: 16px 0;
        
        span {
          padding: 4px 12px;
          background-color: #f1f1f1;
          border-radius: 16px;
          font-size: 12px;
          color: #999;
        }
      }
      
      .message-item {
        display: flex;
        margin-bottom: 16px;
        
        .avatar {
          margin-right: 12px;
        }
        
        .message-content {
          max-width: 60%;
          
          .sender-name {
            font-size: 13px;
            color: #999;
            margin-bottom: 4px;
          }
          
          .message-bubble {
            padding: 10px 12px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            
            .text-message {
              font-size: 15px;
              line-height: 1.5;
              word-break: break-word;
            }
            
            .image-message {
              img {
                max-width: 300px;
                max-height: 300px;
                border-radius: 4px;
              }
            }
            
            .file-message {
              display: flex;
              align-items: center;
              
              .file-icon {
                font-size: 24px;
                color: #409EFF;
                margin-right: 12px;
              }
              
              .file-info {
                flex: 1;
                
                .file-name {
                  font-size: 14px;
                  margin-bottom: 4px;
                  word-break: break-word;
                }
                
                .file-size {
                  font-size: 12px;
                  color: #999;
                }
              }
            }
            
            .voice-message {
              display: flex;
              align-items: center;
              
              .voice-icon {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                background-color: #409EFF;
                color: #fff;
                display: flex;
                justify-content: center;
                align-items: center;
                cursor: pointer;
                margin-right: 12px;
              }
              
              .voice-duration {
                font-size: 14px;
                color: #666;
              }
            }
          }
          
          .message-time {
            font-size: 12px;
            color: #999;
            margin-top: 4px;
            text-align: left;
          }
        }
        
        &.self-message {
          flex-direction: row-reverse;
          
          .avatar {
            margin-right: 0;
            margin-left: 12px;
          }
          
          .message-content {
            .message-bubble {
              background-color: #e1f3fb;
            }
            
            .message-time {
              text-align: right;
            }
          }
        }
      }
    }
  }
  </style>

--- FILE: src/components/chat/SessionDetailDialog.vue ---
å†…å®¹:
<template>
    <v-dialog v-model="dialog" max-width="290">
        <v-card>
            <v-card-title>
                <span class="headline">Session Detail</span>
            </v-card-title>
            <v-card-text>
                <v-text-field v-model="sessionName" label="Session Name"></v-text-field>
                <v-text-field v-model="sessionDescription" label="Session Description"></v-text-field>
            </v-card-text>
            <v-card-actions>
                <v-spacer></v-spacer>
                <v-btn color="blue darken-1" text @click="dialog = false">Cancel</v-btn>
                <v-btn color="blue darken-1" text @click="updateSession">Update</v-btn>
            </v-card-actions>
        </v-card>
    </v-dialog>
</template>

--- FILE: src/store/dataCenter.js ---
å†…å®¹:
import { defineStore } from 'pinia';
import { userApi, friendApi, messageApi, sessionApi } from '@/network/api';

export const useDataCenter = defineStore('dataCenter', {
  state: () => ({
    currentUser: null,
    friendList: [],
    chatSessions: [],
    currentSessionId: null,
    currentMessages: [],
    pendingFriendEvents: [],
    searchUserResults: [],
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.currentUser,
    currentSession: (state) => 
      state.chatSessions.find(s => s.chatSessionId === state.currentSessionId),
    sessionById: (state) => (id) => 
      state.chatSessions.find(s => s.chatSessionId === id),
  },
  
  actions: {
    // ç”¨æˆ·ç™»å½•
    async login(phoneNumber, password) {
      const response = await userApi.login(phoneNumber, password);
      if (response.success) {
        this.currentUser = response.userInfo;
        localStorage.setItem('sessionId', response.sessionId);
        // åˆå§‹åŒ–WebSocketè¿æ¥
        return true;
      }
      return false;
    },
    
    // è·å–å¥½å‹åˆ—è¡¨
    async getFriendList() {
      const response = await friendApi.getFriendList();
      if (response.success) {
        this.friendList = response.friendList;
      }
      return response.success;
    },
    
    // æœç´¢ç”¨æˆ·
    async searchUserAsync(keyword) {
      const response = await friendApi.searchUser(keyword);
      if (response.success) {
        this.searchUserResults = response.userInfoList;
      }
      return response.success;
    },
    
    // è·å–ä¼šè¯åˆ—è¡¨
    async getChatSessionList() {
      const response = await sessionApi.getChatSessionList();
      if (response.success) {
        this.chatSessions = response.chatSessionInfoList;
      }
      return response.success;
    },
    
    // è·å–æ¶ˆæ¯å†å²
    async getHistoryMessages(sessionId, maxMessageId, count) {
      const response = await messageApi.getHistoryMsg(sessionId, maxMessageId, count);
      if (response.success) {
        if (sessionId === this.currentSessionId) {
          // åˆå¹¶å†å²æ¶ˆæ¯å¹¶æŒ‰æ—¶é—´æ’åº
          const allMessages = [...this.currentMessages, ...response.msgList];
          this.currentMessages = allMessages.sort((a, b) => a.msgId - b.msgId);
        }
      }
      return response.success;
    },
    
    // æ·»åŠ å¥½å‹ç”³è¯·
    async addFriendApplyAsync(userId) {
      return await friendApi.addFriendApply(userId);
    },
    
    // åˆ›å»ºç¾¤èŠä¼šè¯
    async createGroupChatSessionAsync(memberIdList) {
      const response = await sessionApi.createGroupChatSession(memberIdList);
      if (response.success) {
        // æ›´æ–°ä¼šè¯åˆ—è¡¨
        this.getChatSessionList();
      }
      return response.success;
    },
    
    // æ¥æ”¶æ–°æ¶ˆæ¯
    receiveNewMessage(message) {
      // å¤„ç†ä¼šè¯å’Œæ¶ˆæ¯æ›´æ–°é€»è¾‘
      const sessionId = message.chatSessionId;
      
      // æ›´æ–°ä¼šè¯çš„æœ€æ–°æ¶ˆæ¯
      const sessionIndex = this.chatSessions.findIndex(s => s.chatSessionId === sessionId);
      if (sessionIndex !== -1) {
        const session = this.chatSessions[sessionIndex];
        session.lastMessage = message;
        session.unreadCount = sessionId === this.currentSessionId ? 0 : (session.unreadCount || 0) + 1;
        
        // å°†å½“å‰ä¼šè¯ç§»åˆ°é¡¶éƒ¨
        this.chatSessions.splice(sessionIndex, 1);
        this.chatSessions.unshift(session);
      }
      
      // å¦‚æœæ˜¯å½“å‰ä¼šè¯ï¼Œæ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨
      if (sessionId === this.currentSessionId) {
        this.currentMessages.push(message);
      }
    },
    
    // åˆ‡æ¢å½“å‰ä¼šè¯
    async switchSession(sessionId) {
      this.currentSessionId = sessionId;
      this.currentMessages = [];
      
      // åŠ è½½æœ€è¿‘æ¶ˆæ¯
      await this.getRecentMessages(sessionId);
      
      // é‡ç½®æœªè¯»è®¡æ•°
      const sessionIndex = this.chatSessions.findIndex(s => s.chatSessionId === sessionId);
      if (sessionIndex !== -1) {
        this.chatSessions[sessionIndex].unreadCount = 0;
      }
    },
    
    // è·å–æœ€è¿‘æ¶ˆæ¯
    async getRecentMessages(sessionId) {
      const response = await messageApi.getRecentMsg(sessionId, 20);
      if (response.success) {
        this.currentMessages = response.msgList.sort((a, b) => a.msgId - b.msgId);
      }
      return response.success;
    },
    
    // å‘é€æ¶ˆæ¯
    async sendMessage(sessionId, content, type = 'text') {
      const message = {
        chatSessionId: sessionId,
        msgType: type,
        content: content,
        sendTime: Date.now(),
      };
      
      const response = await messageApi.sendNewMessage(message);
      if (response.success) {
        // æ·»åŠ åˆ°æœ¬åœ°æ¶ˆæ¯åˆ—è¡¨
        message.msgId = response.msgId;
        message.senderId = this.currentUser.userId;
        this.currentMessages.push(message);
        
        // æ›´æ–°ä¼šè¯çš„æœ€æ–°æ¶ˆæ¯
        const sessionIndex = this.chatSessions.findIndex(s => s.chatSessionId === sessionId);
        if (sessionIndex !== -1) {
          const session = { ...this.chatSessions[sessionIndex] };
          session.lastMessage = message;
          
          // å°†å½“å‰ä¼šè¯ç§»åˆ°é¡¶éƒ¨
          this.chatSessions.splice(sessionIndex, 1);
          this.chatSessions.unshift(session);
        }
      }
      return response.success;
    },
  }
});

--- FILE: src/router/index.js ---
å†…å®¹:
import { createRouter, createWebHistory } from 'vue-router';
import { useDataCenter } from '@/store/dataCenter';

const routes = [
  {
    path: '/',
    name: 'Main',
    component: () => import('@/views/MainView.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/LoginView.vue'),
    meta: { guest: true }
  },
  {
    path: '/register',
    name: 'Register',
    component: () => import('@/views/RegisterView.vue'),
    meta: { guest: true }
  },
  {
    path: '/friend-requests',
    name: 'FriendRequests',
    component: () => import('@/views/FriendRequestsView.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/user-profile',
    name: 'UserProfile',
    component: () => import('@/views/UserProfileView.vue'),
    meta: { requiresAuth: true }
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

// å¯¼èˆªå®ˆå«
router.beforeEach((to, from, next) => {
  const dataCenter = useDataCenter();
  const isLoggedIn = !!localStorage.getItem('sessionId');
  
  // éœ€è¦ç™»å½•çš„è·¯ç”±
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!isLoggedIn) {
      next({ name: 'Login' });
    } else {
      // å¦‚æœå·²ç™»å½•ä½†æ²¡æœ‰å½“å‰ç”¨æˆ·ä¿¡æ¯ï¼Œåˆ™è·å–ç”¨æˆ·ä¿¡æ¯
      if (!dataCenter.currentUser) {
        dataCenter.getUserInfo();
      }
      next();
    }
  } 
  // æ¸¸å®¢è·¯ç”±ï¼ˆå·²ç™»å½•ç”¨æˆ·ä¸åº”è®¿é—®ï¼‰
  else if (to.matched.some(record => record.meta.guest)) {
    if (isLoggedIn) {
      next({ name: 'Main' });
    } else {
      next();
    }
  } else {
    next();
  }
});

export default router;

--- FILE: src/views/RegisterView.vue ---
å†…å®¹:
<template>
    <div class="register">
      <el-card class="register-card">
        <h2>æ³¨å†Œ</h2>
        <el-form :model="registerForm" :rules="rules" ref="registerForm">
          <el-form-item prop="username">
            <el-input v-model="registerForm.username" placeholder="ç”¨æˆ·å"></el-input>
          </el-form-item>
          <el-form-item prop="password">
            <el-input v-model="registerForm.password" type="password" placeholder="å¯†ç "></el-input>
          </el-form-item>
          <el-form-item prop="confirmPassword">
            <el-input v-model="registerForm.confirmPassword" type="password" placeholder="ç¡®è®¤å¯†ç "></el-input>
          </el-form-item>
          <el-form-item>
            <el-button type="primary" @click="handleRegister">æ³¨å†Œ</el-button>
          </el-form-item>
        </el-form>
        <div class="login-link">
          å·²æœ‰è´¦å·ï¼Ÿ<router-link to="/login">ç«‹å³ç™»å½•</router-link>
        </div>
      </el-card>
    </div>
  </template>
  
  <script>
  export default {
    name: 'RegisterView',
    data() {
      return {
        registerForm: {
          username: '',
          password: '',
          confirmPassword: ''
        },
        rules: {
          username: [
            { required: true, message: 'è¯·è¾“å…¥ç”¨æˆ·å', trigger: 'blur' },
            { min: 3, max: 20, message: 'é•¿åº¦åœ¨ 3 åˆ° 20 ä¸ªå­—ç¬¦', trigger: 'blur' }
          ],
          password: [
            { required: true, message: 'è¯·è¾“å…¥å¯†ç ', trigger: 'blur' },
            { min: 6, message: 'å¯†ç é•¿åº¦è‡³å°‘ä¸º 6 ä¸ªå­—ç¬¦', trigger: 'blur' }
          ],
          confirmPassword: [
            { required: true, message: 'è¯·ç¡®è®¤å¯†ç ', trigger: 'blur' }
          ]
        }
      }
    },
    methods: {
      handleRegister() {
        this.$refs.registerForm.validate((valid) => {
          if (valid) {
            // è¿™é‡Œæ·»åŠ æ³¨å†Œé€»è¾‘
            console.log('æ³¨å†Œè¡¨å•:', this.registerForm)
          }
        })
      }
    }
  }
  </script>
  
  <style scoped>
  .register {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f5f5f5;
  }
  
  .register-card {
    width: 400px;
    padding: 20px;
  }
  
  .login-link {
    text-align: center;
    margin-top: 15px;
  }
  </style>

--- FILE: src/views/MainView.vue ---
å†…å®¹:
<template>
    <div class="main-container">
      <!-- å·¦ä¾§è¾¹æ  - ä¼šè¯åˆ—è¡¨ -->
      <div class="sidebar">
        <div class="user-profile" @click="openUserProfile">
          <el-avatar :size="45" :src="currentUser?.avatar || defaultAvatar"></el-avatar>
          <span class="username">{{ currentUser?.nickname || 'ç”¨æˆ·å' }}</span>
        </div>
        
        <div class="menu-tabs">
          <el-tabs v-model="activeTab" @tab-click="handleTabClick">
            <el-tab-pane label="ä¼šè¯" name="sessions">
              <session-list 
                :sessions="chatSessions" 
                :current-session-id="currentSessionId"
                @select-session="handleSelectSession"
              />
            </el-tab-pane>
            <el-tab-pane label="å¥½å‹" name="friends">
              <friend-list 
                :friends="friendList" 
                @select-friend="handleSelectFriend"
                @add-friend="openAddFriendDialog"
              />
            </el-tab-pane>
          </el-tabs>
        </div>
        
        <div class="action-buttons">
          <el-button type="primary" icon="el-icon-plus" circle @click="openAddFriendDialog"></el-button>
          <el-button type="success" icon="el-icon-user-solid" circle @click="openCreateGroupDialog"></el-button>
        </div>
      </div>
      
      <!-- å³ä¾§èŠå¤©åŒºåŸŸ -->
      <div class="chat-area" v-if="currentSessionId">
        <div class="chat-header">
          <div class="chat-title">
            <span>{{ currentSession?.chatSessionName || 'èŠå¤©' }}</span>
            <el-button icon="el-icon-more" circle plain @click="openSessionDetail"></el-button>
          </div>
        </div>
        
        <message-display 
          :messages="currentMessages" 
          :current-user-id="currentUser?.userId"
        />
        
        <message-editor @send="handleSendMessage" />
      </div>
      
      <div class="empty-chat" v-else>
        <el-empty description="é€‰æ‹©ä¼šè¯æˆ–å¼€å§‹æ–°å¯¹è¯"></el-empty>
      </div>
    </div>
    
    <!-- å¯¹è¯æ¡†ç»„ä»¶ -->
    <add-friend-dialog v-if="showAddFriendDialog" @close="showAddFriendDialog = false" />
    <create-group-dialog v-if="showGroupDialog" @close="showGroupDialog = false" />
    <session-detail-dialog 
      v-if="showSessionDetail" 
      :session-id="currentSessionId"
      @close="showSessionDetail = false" 
    />
    <user-profile-dialog 
      v-if="showUserProfile" 
      :user="currentUser" 
      @close="showUserProfile = false" 
    />
  </template>
  
  <script setup>
  import { ref, computed, onMounted, watchEffect } from 'vue';
  import { useDataCenter } from '@/store/dataCenter';
  import { useRouter } from 'vue-router';
  import { ElMessage } from 'element-plus';
  
  // å¯¼å…¥ç»„ä»¶
  import SessionList from '@/components/chat/SessionList.vue';
  import FriendList from '@/components/friend/FriendList.vue';
  import MessageDisplay from '@/components/chat/MessageDisplay.vue';
  import MessageEditor from '@/components/chat/MessageEditor.vue';
  import AddFriendDialog from '@/components/friend/AddFriendDialog.vue';
  import CreateGroupDialog from '@/components/friend/CreateGroupDialog.vue';
  import SessionDetailDialog from '@/components/chat/SessionDetailDialog.vue';
  import UserProfileDialog from '@/components/user/UserProfileDialog.vue';
  
  const dataCenter = useDataCenter();
  const router = useRouter();
  
  // çŠ¶æ€å˜é‡
  const activeTab = ref('sessions');
  const showAddFriendDialog = ref(false);
  const showGroupDialog = ref(false);
  const showSessionDetail = ref(false);
  const showUserProfile = ref(false);
  const defaultAvatar = '/assets/default-avatar.png';
  
  // è®¡ç®—å±æ€§
  const currentUser = computed(() => dataCenter.currentUser);
  const friendList = computed(() => dataCenter.friendList);
  const chatSessions = computed(() => dataCenter.chatSessions);
  const currentSessionId = computed(() => dataCenter.currentSessionId);
  const currentSession = computed(() => dataCenter.currentSession);
  const currentMessages = computed(() => dataCenter.currentMessages);
  
  // ç”Ÿå‘½å‘¨æœŸé’©å­
  onMounted(async () => {
    if (!dataCenter.isLoggedIn) {
      router.push('/login');
      return;
    }
    
    // åŠ è½½åŸºç¡€æ•°æ®
    try {
      await Promise.all([
        dataCenter.getFriendList(),
        dataCenter.getChatSessionList()
      ]);
    } catch (error) {
      ElMessage.error('åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•');
      console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
    }
  });
  
  // ç›‘å¬å½“å‰ä¼šè¯å˜åŒ–ï¼Œè‡ªåŠ¨åŠ è½½æ¶ˆæ¯
  watchEffect(async () => {
    const sessionId = currentSessionId.value;
    if (sessionId) {
      try {
        await dataCenter.getRecentMessages(sessionId);
      } catch (error) {
        console.error('åŠ è½½æ¶ˆæ¯å¤±è´¥:', error);
      }
    }
  });
  
  // æ–¹æ³•
  const handleTabClick = (tab) => {
    // å¤„ç†æ ‡ç­¾é¡µåˆ‡æ¢é€»è¾‘
  };
  
  const handleSelectSession = (sessionId) => {
    dataCenter.switchSession(sessionId);
  };
  
  const handleSelectFriend = (friendId) => {
    // è·å–æˆ–åˆ›å»ºä¸è¯¥å¥½å‹çš„ä¼šè¯
    const session = chatSessions.value.find(s => 
      s.sessionType === 'single' && s.friendId === friendId
    );
    
    if (session) {
      dataCenter.switchSession(session.chatSessionId);
    } else {
      // åˆ›å»ºæ–°ä¼šè¯
      // å®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦å‘åç«¯è¯·æ±‚åˆ›å»ºä¼šè¯
      ElMessage.info('æ­£åœ¨åˆ›å»ºä¸è¯¥å¥½å‹çš„ä¼šè¯...');
    }
  };
  
  const handleSendMessage = async (content, type = 'text') => {
    if (!currentSessionId.value) {
      ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¼šè¯');
      return;
    }
    
    try {
      await dataCenter.sendMessage(currentSessionId.value, content, type);
    } catch (error) {
      ElMessage.error('å‘é€æ¶ˆæ¯å¤±è´¥');
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
    }
  };
  
  const openAddFriendDialog = () => {
    showAddFriendDialog.value = true;
  };
  
  const openCreateGroupDialog = () => {
    showGroupDialog.value = true;
  };
  
  const openSessionDetail = () => {
    showSessionDetail.value = true;
  };
  
  const openUserProfile = () => {
    showUserProfile.value = true;
  };
  </script>
  
  <style lang="scss" scoped>
  .main-container {
    display: flex;
    height: 100vh;
    overflow: hidden;
    background-color: #f0f2f5;
    
    .sidebar {
      width: 280px;
      display: flex;
      flex-direction: column;
      background-color: #fff;
      border-right: 1px solid #eaeaea;
      
      .user-profile {
        display: flex;
        align-items: center;
        padding: 16px;
        cursor: pointer;
        
        .username {
          margin-left: 12px;
          font-weight: 500;
        }
      }
      
      .menu-tabs {
        flex: 1;
        overflow: hidden;
        
        :deep(.el-tabs__header) {
          padding: 0 16px;
          margin: 0;
        }
        
        :deep(.el-tabs__content) {
          height: calc(100% - 40px);
          overflow: hidden;
        }
        
        :deep(.el-tab-pane) {
          height: 100%;
          overflow-y: auto;
        }
      }
      
      .action-buttons {
        display: flex;
        justify-content: space-around;
        padding: 12px 16px;
        border-top: 1px solid #eaeaea;
      }
    }
    
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: #f5f5f5;
      
      .chat-header {
        padding: 12px 20px;
        background-color: #fff;
        border-bottom: 1px solid #eaeaea;
        
        .chat-title {
          display: flex;
          align-items: center;
          justify-content: space-between;
          
          span {
            font-size: 16px;
            font-weight: 500;
          }
        }
      }
    }
    
    .empty-chat {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #fff;
    }
  }
  </style>

--- FILE: src/views/UserProfileView.vue ---
å†…å®¹:
<template>  
    <div>
        <h1>User Profile</h1>
        <p>Username: {{ user.username }}</p>
        <p>Email: {{ user.email }}</p>
        <p>First Name: {{ user.first_name }}</p>
        <p>Last Name: {{ user.last_name }}</p>
        <p>Friends:</p>
        <div v-for="friend in user.friends" :key="friend.id">
            <p>{{ friend.username }}</p>
        </div>
    </div>
</template>

--- FILE: src/views/FriendRequestsView.vue ---
å†…å®¹:
<template>  
    <div>
        <h1>User Profile</h1>
        <p>Username: {{ user.username }}</p>
        <p>Email: {{ user.email }}</p>
        <p>First Name: {{ user.first_name }}</p>
        <p>Last Name: {{ user.last_name }}</p>
        <p>Friends:</p>
        <div v-for="friend in user.friends" :key="friend.id">
            <p>{{ friend.username }}</p>
        </div>
    </div>
</template>

--- FILE: src/views/LoginView.vue ---
å†…å®¹:
<template>
    <div class="login-container">
      <div class="login-box">
        <div class="logo">
          <img src="@/assets/logo.png" alt="Logo">
          <h1>VueèŠå¤©å®¤</h1>
        </div>
        
        <el-tabs v-model="activeTab" class="login-tabs">
          <el-tab-pane label="è´¦å·å¯†ç ç™»å½•" name="password">
            <el-form ref="loginForm" :model="loginForm" :rules="loginRules" label-width="0">
              <el-form-item prop="phoneNumber">
                <el-input 
                  v-model="loginForm.phoneNumber" 
                  placeholder="æ‰‹æœºå·" 
                  prefix-icon="el-icon-mobile-phone"
                />
              </el-form-item>
              
              <el-form-item prop="password">
                <el-input 
                  v-model="loginForm.password" 
                  type="password" 
                  placeholder="å¯†ç " 
                  prefix-icon="el-icon-lock"
                  @keyup.enter="handleLogin"
                />
              </el-form-item>
              
              <el-form-item>
                <el-button 
                  type="primary" 
                  class="login-button" 
                  :loading="loading" 
                  @click="handleLogin"
                >
                  ç™»å½•
                </el-button>
              </el-form-item>
            </el-form>
          </el-tab-pane>
          
          <el-tab-pane label="çŸ­ä¿¡éªŒè¯ç ç™»å½•" name="sms">
            <el-form ref="smsForm" :model="smsForm" :rules="smsRules" label-width="0">
              <el-form-item prop="phoneNumber">
                <el-input 
                  v-model="smsForm.phoneNumber" 
                  placeholder="æ‰‹æœºå·" 
                  prefix-icon="el-icon-mobile-phone"
                />
              </el-form-item>
              
              <el-form-item prop="verifyCode">
                <div class="verify-code">
                  <el-input 
                    v-model="smsForm.verifyCode" 
                    placeholder="éªŒè¯ç " 
                    prefix-icon="el-icon-key"
                  />
                  <el-button 
                    :disabled="cooldown > 0" 
                    @click="sendVerifyCode"
                  >
                    {{ cooldown > 0 ? `${cooldown}s` : 'è·å–éªŒè¯ç ' }}
                  </el-button>
                </div>
              </el-form-item>
              
              <el-form-item>
                <el-button 
                  type="primary" 
                  class="login-button" 
                  :loading="loading" 
                  @click="handleSmsLogin"
                >
                  ç™»å½•
                </el-button>
              </el-form-item>
            </el-form>
          </el-tab-pane>
        </el-tabs>
        
        <div class="register-link">
          <span>è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ</span>
          <router-link to="/register">ç«‹å³æ³¨å†Œ</router-link>
        </div>
      </div>
    </div>
  </template>
  
  <script setup>
  import { ref, reactive } from 'vue';
  import { useRouter } from 'vue-router';
  import { ElMessage } from 'element-plus';
  import { useDataCenter } from '@/store/dataCenter';
  import { userApi } from '@/network/api';
  import { setupWebSocket } from '@/network/websocket';
  
  const router = useRouter();
  const dataCenter = useDataCenter();
  
  // çŠ¶æ€å˜é‡
  const activeTab = ref('password');
  const loading = ref(false);
  const cooldown = ref(0);
  
  // è¡¨å•æ•°æ®
  const loginForm = reactive({
    phoneNumber: '',
    password: ''
  });
  
  const smsForm = reactive({
    phoneNumber: '',
    verifyCode: ''
  });
  
  // è¡¨å•éªŒè¯è§„åˆ™
  const loginRules = {
    phoneNumber: [
      { required: true, message: 'è¯·è¾“å…¥æ‰‹æœºå·', trigger: 'blur' },
      { pattern: /^1[3-9]\d{9}$/, message: 'æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®', trigger: 'blur' }
    ],
    password: [
      { required: true, message: 'è¯·è¾“å…¥å¯†ç ', trigger: 'blur' },
      { min: 6, message: 'å¯†ç é•¿åº¦ä¸èƒ½å°‘äº6ä½', trigger: 'blur' }
    ]
  };
  
  const smsRules = {
    phoneNumber: [
      { required: true, message: 'è¯·è¾“å…¥æ‰‹æœºå·', trigger: 'blur' },
      { pattern: /^1[3-9]\d{9}$/, message: 'æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®', trigger: 'blur' }
    ],
    verifyCode: [
      { required: true, message: 'è¯·è¾“å…¥éªŒè¯ç ', trigger: 'blur' },
      { pattern: /^\d{6}$/, message: 'éªŒè¯ç æ ¼å¼ä¸æ­£ç¡®', trigger: 'blur' }
    ]
  };
  
  // æ–¹æ³•
  const handleLogin = async () => {
    try {
      loading.value = true;
      
      // ç™»å½•è¯·æ±‚
      const success = await dataCenter.login(loginForm.phoneNumber, loginForm.password);
      
      if (success) {
        // å»ºç«‹WebSocketè¿æ¥
        setupWebSocket(localStorage.getItem('sessionId'));
        
        // ç™»å½•æˆåŠŸï¼Œè·³è½¬åˆ°é¦–é¡µ
        router.push('/');
        ElMessage.success('ç™»å½•æˆåŠŸ');
      } else {
        ElMessage.error('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
      }
    } catch (error) {
      console.error('ç™»å½•å¤±è´¥:', error);
      ElMessage.error('ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      loading.value = false;
    }
  };
  
  const handleSmsLogin = async () => {
    try {
      loading.value = true;
      
      // çŸ­ä¿¡éªŒè¯ç ç™»å½•
      const response = await userApi.smsLogin(smsForm.phoneNumber, smsForm.verifyCode);
      
      if (response.success) {
        // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
        dataCenter.currentUser = response.userInfo;
        localStorage.setItem('sessionId', response.sessionId);
        
        // å»ºç«‹WebSocketè¿æ¥
        setupWebSocket(response.sessionId);
        
        // ç™»å½•æˆåŠŸï¼Œè·³è½¬åˆ°é¦–é¡µ
        router.push('/');
        ElMessage.success('ç™»å½•æˆåŠŸ');
      } else {
        ElMessage.error(response.errmsg || 'éªŒè¯ç é”™è¯¯');
      }
    } catch (error) {
      console.error('ç™»å½•å¤±è´¥:', error);
      ElMessage.error('ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      loading.value = false;
    }
  };
  
  const sendVerifyCode = async () => {
    try {
      // éªŒè¯æ‰‹æœºå·æ ¼å¼
      if (!/^1[3-9]\d{9}$/.test(smsForm.phoneNumber)) {
        ElMessage.warning('è¯·è¾“å…¥æ­£ç¡®çš„æ‰‹æœºå·');
        return;
      }
      
      // å‘é€éªŒè¯ç 
      const response = await userApi.sendVerifyCode(smsForm.phoneNumber);
      
      if (response.success) {
        ElMessage.success('éªŒè¯ç å·²å‘é€');
        
        // å€’è®¡æ—¶
        cooldown.value = 60;
        const timer = setInterval(() => {
          cooldown.value--;
          if (cooldown.value <= 0) {
            clearInterval(timer);
          }
        }, 1000);
      } else {
        ElMessage.error(response.errmsg || 'å‘é€éªŒè¯ç å¤±è´¥');
      }
    } catch (error) {
      console.error('å‘é€éªŒè¯ç å¤±è´¥:', error);
      ElMessage.error('å‘é€éªŒè¯ç å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };
  </script>
  
  <style lang="scss" scoped>
  .login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f5f5f5;
    
    .login-box {
      width: 380px;
      padding: 30px;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
      
      .logo {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 30px;
        
        img {
          width: 80px;
          height: 80px;
        }
        
        h1 {
          margin-top: 16px;
          font-size: 24px;
          color: #333;
        }
      }
      
      .login-tabs {
        margin-bottom: 20px;
      }
      
      .login-button {
        width: 100%;
        height: 40px;
        font-size: 16px;
      }
      
      .verify-code {
        display: flex;
        
        .el-input {
          flex: 1;
          margin-right: 10px;
        }
        
        .el-button {
          width: 120px;
        }
      }
      
      .register-link {
      text-align: center;
      margin-top: 20px;
      font-size: 14px;
      
      span {
        color: #666;
      }
      
      a {
        color: #409EFF;
        text-decoration: none;
        margin-left: 5px;
      }
    }
  }
}
</style>

--- FILE: src/network/index.js ---
å†…å®¹:
import axios from 'axios';
import { setupWebSocket } from './websocket';
import { loadProtobufs } from './protobuf';

// åˆ›å»ºaxioså®ä¾‹
const httpClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/x-protobuf'
  }
});

// è¯·æ±‚æ‹¦æˆªå™¨ - æ·»åŠ ä¼šè¯IDç­‰èº«ä»½ä¿¡æ¯
httpClient.interceptors.request.use(
  config => {
    const sessionId = localStorage.getItem('sessionId');
    if (sessionId) {
      config.headers['Session-Id'] = sessionId;
    }
    return config;
  },
  error => Promise.reject(error)
);

// å“åº”æ‹¦æˆªå™¨ - å¤„ç†protobufå“åº”
httpClient.interceptors.response.use(
  response => {
    // å¤„ç†äºŒè¿›åˆ¶å“åº”
    return response;
  },
  error => Promise.reject(error)
);

export const initNetwork = async () => {
  // åŠ è½½protobufå®šä¹‰
  await loadProtobufs();
  
  // åˆå§‹åŒ–WebSocketè¿æ¥
  const sessionId = localStorage.getItem('sessionId');
  if (sessionId) {
    setupWebSocket(sessionId);
  }
  
  return {
    httpClient
  };
};

export default httpClient;

--- FILE: src/network/api/index.js ---
å†…å®¹:
import httpClient from '../index';
import { encodeRequest, decodeResponse } from '../protobuf';

// ç”¨æˆ·ç›¸å…³API
export const userApi = {
  // è·å–çŸ­ä¿¡éªŒè¯ç 
  async sendVerifyCode(phoneNumber) {
    const payload = {
      request_id: Date.now().toString(),
      phone_number: phoneNumber
    };
    
    const encodedRequest = encodeRequest('PhoneVerifyCodeReq', payload);
    const response = await httpClient.post('/phone_verify_code', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('PhoneVerifyCodeRsp', response.data);
  },
  
  // ç”¨æˆ·åå¯†ç ç™»å½•
  async login(username, password) {
    const payload = {
      request_id: Date.now().toString(),
      username,
      password
    };
    
    const encodedRequest = encodeRequest('UserLoginReq', payload);
    const response = await httpClient.post('/user_login', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('UserLoginRsp', response.data);
  },
  
  // æ‰‹æœºå·éªŒè¯ç ç™»å½•
  async smsLogin(phoneNumber, verifyCode) {
    const payload = {
      request_id: Date.now().toString(),
      phone_number: phoneNumber,
      verify_code: verifyCode
    };
    
    const encodedRequest = encodeRequest('PhoneLoginReq', payload);
    const response = await httpClient.post('/phone_login', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('PhoneLoginRsp', response.data);
  },
  
  // ç”¨æˆ·æ³¨å†Œ
  async register(username, password, nickname) {
    const payload = {
      request_id: Date.now().toString(),
      username,
      password,
      nickname
    };
    
    const encodedRequest = encodeRequest('UserRegisterReq', payload);
    const response = await httpClient.post('/user_register', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('UserRegisterRsp', response.data);
  },
  
  // è·å–ç”¨æˆ·ä¿¡æ¯
  async getUserInfo(sessionId) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: sessionId
    };
    
    const encodedRequest = encodeRequest('GetUserInfoReq', payload);
    const response = await httpClient.post('/get_user_info', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetUserInfoRsp', response.data);
  },
  
  // è®¾ç½®ç”¨æˆ·å¤´åƒ
  async setUserAvatar(sessionId, avatarData) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: sessionId,
      avatar: avatarData
    };
    
    const encodedRequest = encodeRequest('SetUserAvatarReq', payload);
    const response = await httpClient.post('/set_user_avatar', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('SetUserAvatarRsp', response.data);
  }
};

// å¥½å‹ç›¸å…³API
export const friendApi = {
  // è·å–å¥½å‹åˆ—è¡¨
  async getFriendList() {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId')
    };
    
    const encodedRequest = encodeRequest('GetFriendListReq', payload);
    const response = await httpClient.post('/get_friend_list', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetFriendListRsp', response.data);
  },
  
  // æœç´¢ç”¨æˆ·
  async searchUser(keyword) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      search_text: keyword
    };
    
    const encodedRequest = encodeRequest('FriendSearchReq', payload);
    const response = await httpClient.post('/friend_search', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('FriendSearchRsp', response.data);
  },
  
  // æ·»åŠ å¥½å‹ç”³è¯·
  async addFriendApply(respondentId) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      respondent_id: respondentId
    };
    
    const encodedRequest = encodeRequest('FriendAddReq', payload);
    const response = await httpClient.post('/friend_add', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('FriendAddRsp', response.data);
  },
  
  // å¤„ç†å¥½å‹ç”³è¯·
  async processFriendApply(applyUserId, agree) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      apply_user_id: applyUserId,
      agree
    };
    
    const encodedRequest = encodeRequest('FriendAddProcessReq', payload);
    const response = await httpClient.post('/friend_add_process', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('FriendAddProcessRsp', response.data);
  },
  
  // åˆ é™¤å¥½å‹
  async removeFriend(peerId) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      peer_id: peerId
    };
    
    const encodedRequest = encodeRequest('FriendRemoveReq', payload);
    const response = await httpClient.post('/friend_remove', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('FriendRemoveRsp', response.data);
  },
  
  // è·å–å¾…å¤„ç†å¥½å‹ç”³è¯·
  async getPendingFriendEvents() {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId')
    };
    
    const encodedRequest = encodeRequest('GetPendingFriendEventListReq', payload);
    const response = await httpClient.post('/get_pending_friend_event_list', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetPendingFriendEventListRsp', response.data);
  }
};

// ä¼šè¯ç›¸å…³API
export const sessionApi = {
  // è·å–ä¼šè¯åˆ—è¡¨
  async getChatSessionList() {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId')
    };
    
    const encodedRequest = encodeRequest('GetChatSessionListReq', payload);
    const response = await httpClient.post('/get_chat_session_list', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetChatSessionListRsp', response.data);
  },
  
  // åˆ›å»ºç¾¤èŠä¼šè¯
  async createGroupChatSession(memberIdList, sessionName) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      member_id_list: memberIdList,
      chat_session_name: sessionName
    };
    
    const encodedRequest = encodeRequest('ChatSessionCreateReq', payload);
    const response = await httpClient.post('/chat_session_create', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('ChatSessionCreateRsp', response.data);
  },
  
  // è·å–ä¼šè¯æˆå‘˜
  async getChatSessionMember(chatSessionId) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      chat_session_id: chatSessionId
    };
    
    const encodedRequest = encodeRequest('GetChatSessionMemberReq', payload);
    const response = await httpClient.post('/get_chat_session_member', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetChatSessionMemberRsp', response.data);
  }
};

// æ¶ˆæ¯ç›¸å…³API
export const messageApi = {
  // è·å–å†å²æ¶ˆæ¯
  async getHistoryMsg(chatSessionId, maxMsgId, count) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      chat_session_id: chatSessionId,
      max_msg_id: maxMsgId || '0',
      msg_count: count || 20
    };
    
    const encodedRequest = encodeRequest('GetHistoryMsgReq', payload);
    const response = await httpClient.post('/get_history_msg', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetHistoryMsgRsp', response.data);
  },
  
  // è·å–æœ€è¿‘æ¶ˆæ¯
  async getRecentMsg(chatSessionId, count) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      chat_session_id: chatSessionId,
      msg_count: count || 20
    };
    
    const encodedRequest = encodeRequest('GetRecentMsgReq', payload);
    const response = await httpClient.post('/get_recent_msg', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('GetRecentMsgRsp', response.data);
  },
  
  // å‘é€æ–°æ¶ˆæ¯
  async sendNewMessage(message) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      chat_session_id: message.chatSessionId,
      msg_type: message.msgType,
      content: message.content
    };
    
    const encodedRequest = encodeRequest('NewMessageReq', payload);
    const response = await httpClient.post('/new_message', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('NewMessageRsp', response.data);
  },
  
  // æœç´¢æ¶ˆæ¯
  async searchMessage(keyword, chatSessionId) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      chat_session_id: chatSessionId,
      search_text: keyword
    };
    
    const encodedRequest = encodeRequest('MsgSearchReq', payload);
    const response = await httpClient.post('/msg_search', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('MsgSearchRsp', response.data);
  }
};

// æ–‡ä»¶ç›¸å…³API
export const fileApi = {
  // ä¸Šä¼ å•ä¸ªæ–‡ä»¶
  async uploadSingleFile(file) {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('session_id', localStorage.getItem('sessionId'));
    
    const response = await httpClient.post('/file_put_single', formData);
    return response.data;
  },
  
  // ä¸‹è½½å•ä¸ªæ–‡ä»¶
  async downloadSingleFile(fileId) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      file_id: fileId
    };
    
    const encodedRequest = encodeRequest('GetSingleFileReq', payload);
    const response = await httpClient.post('/file_get_single', encodedRequest, {
      responseType: 'blob'
    });
    
    return response.data;
  }
};

// è¯­éŸ³è¯†åˆ«API
export const speechApi = {
  // è¯­éŸ³è½¬æ–‡å­—
  async speechRecognition(audioData) {
    const payload = {
      request_id: Date.now().toString(),
      session_id: localStorage.getItem('sessionId'),
      audio_data: audioData
    };
    
    const encodedRequest = encodeRequest('SpeechRecognitionReq', payload);
    const response = await httpClient.post('/speech_recognition', encodedRequest, {
      responseType: 'arraybuffer'
    });
    
    return decodeResponse('SpeechRecognitionRsp', response.data);
  }
};

--- FILE: src/network/websocket/index.js ---
å†…å®¹:
import { useDataCenter } from '@/store/dataCenter';
import { decodeNotifyMessage } from '../protobuf';

let websocket = null;

export const setupWebSocket = (sessionId) => {
  const wsUrl = `${import.meta.env.VITE_WS_URL}?sessionId=${sessionId}`;
  
  if (websocket) {
    websocket.close();
  }
  
  websocket = new WebSocket(wsUrl);
  
  websocket.binaryType = 'arraybuffer';
  
  websocket.onopen = () => {
    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
    // å‘é€å¿ƒè·³
    startHeartbeat();
  };
  
  websocket.onmessage = (event) => {
    const data = event.data;
    if (typeof data === 'string') {
      // å¤„ç†æ–‡æœ¬æ¶ˆæ¯ï¼Œå¯èƒ½æ˜¯å¿ƒè·³å“åº”
      console.log('æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯:', data);
    } else {
      // å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯ï¼Œä½¿ç”¨protobufè§£ç 
      handleBinaryMessage(data);
    }
  };
  
  websocket.onclose = () => {
    console.log('WebSocketè¿æ¥å·²å…³é—­');
    stopHeartbeat();
    
    // å°è¯•é‡æ–°è¿æ¥
    setTimeout(() => {
      if (localStorage.getItem('sessionId')) {
        setupWebSocket(localStorage.getItem('sessionId'));
      }
    }, 3000);
  };
  
  websocket.onerror = (error) => {
    console.error('WebSocketé”™è¯¯:', error);
  };
  
  return websocket;
};

// å¿ƒè·³å®šæ—¶å™¨
let heartbeatTimer = null;

function startHeartbeat() {
  heartbeatTimer = setInterval(() => {
    if (websocket && websocket.readyState === WebSocket.OPEN) {
      websocket.send('ping');
    }
  }, 30000); // 30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
}

function stopHeartbeat() {
  if (heartbeatTimer) {
    clearInterval(heartbeatTimer);
    heartbeatTimer = null;
  }
}

// å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯
async function handleBinaryMessage(data) {
  try {
    const notify = await decodeNotifyMessage(data);
    const dataCenter = useDataCenter();
    
    // æ ¹æ®é€šçŸ¥ç±»å‹è¿›è¡Œå¤„ç†
    switch (notify.notifyType) {
      case 'CHAT_MESSAGE_NOTIFY':
        // æ–°æ¶ˆæ¯é€šçŸ¥
        dataCenter.receiveNewMessage(notify.newMessageInfo.messageInfo);
        break;
        
      case 'FRIEND_APPLY_NOTIFY':
        // å¥½å‹ç”³è¯·é€šçŸ¥
        dataCenter.pendingFriendEvents.unshift(notify.friendApply);
        break;
        
      case 'FRIEND_APPLY_PROCESSED_NOTIFY':
        // å¥½å‹ç”³è¯·å¤„ç†ç»“æœé€šçŸ¥
        // åˆ·æ–°å¥½å‹åˆ—è¡¨
        dataCenter.getFriendList();
        break;
        
      case 'CHAT_SESSION_CREATE_NOTIFY':
        // æ–°ä¼šè¯åˆ›å»ºé€šçŸ¥
        dataCenter.getChatSessionList();
        break;
        
      case 'FRIEND_REMOVE_NOTIFY':
        // å¥½å‹åˆ é™¤é€šçŸ¥
        dataCenter.getFriendList();
        break;
        
      default:
        console.log('æœªå¤„ç†çš„é€šçŸ¥ç±»å‹:', notify.notifyType);
    }
  } catch (error) {
    console.error('å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯å¤±è´¥:', error);
  }
}

export const sendWebSocketMessage = (message) => {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(message);
    return true;
  }
  return false;
};

export const closeWebSocket = () => {
  if (websocket) {
    websocket.close();
    websocket = null;
    stopHeartbeat();
  }
};

--- FILE: src/network/protobuf/index.js ---
å†…å®¹:
import protobuf from 'protobufjs';

let root = null;
let protoTypes = {};

export const loadProtobufs = async () => {
  try {
    // åŠ è½½protoå®šä¹‰æ–‡ä»¶
    root = await protobuf.load([
      '/proto/base.proto',
      '/proto/user.proto',
      '/proto/friend.proto',
      '/proto/message_transmit.proto',
      '/proto/message_storage.proto',
      '/proto/notify.proto',
      '/proto/file.proto',
      '/proto/gateway.proto',
      '/proto/speech_recognition.proto'
    ]);
    
    // é¢„å…ˆæŸ¥æ‰¾å¸¸ç”¨æ¶ˆæ¯ç±»å‹
    protoTypes.UserLoginReq = root.lookupType('UserLoginReq');
    protoTypes.UserLoginRsp = root.lookupType('UserLoginRsp');
    protoTypes.FriendSearchReq = root.lookupType('FriendSearchReq');
    protoTypes.FriendSearchRsp = root.lookupType('FriendSearchRsp');
    protoTypes.GetHistoryMsgReq = root.lookupType('GetHistoryMsgReq');
    protoTypes.GetHistoryMsgRsp = root.lookupType('GetHistoryMsgRsp');
    protoTypes.NewMessageReq = root.lookupType('NewMessageReq');
    protoTypes.NewMessageRsp = root.lookupType('NewMessageRsp');
    protoTypes.NotifyMessage = root.lookupType('NotifyMessage');
    
    console.log('Protobuf definitions loaded successfully');
    return true;
  } catch (error) {
    console.error('Failed to load protobuf definitions:', error);
    return false;
  }
};

// ç¼–ç è¯·æ±‚æ¶ˆæ¯
export const encodeRequest = (messageType, payload) => {
  try {
    const MessageType = protoTypes[messageType] || root.lookupType(messageType);
    const errMsg = MessageType.verify(payload);
    if (errMsg) {
      throw new Error(errMsg);
    }
    
    const message = MessageType.create(payload);
    return MessageType.encode(message).finish();
  } catch (error) {
    console.error(`Failed to encode ${messageType}:`, error);
    throw error;
  }
};

// è§£ç å“åº”æ¶ˆæ¯
export const decodeResponse = (messageType, buffer) => {
  try {
    const MessageType = protoTypes[messageType] || root.lookupType(messageType);
    const message = MessageType.decode(new Uint8Array(buffer));
    return MessageType.toObject(message, {
      longs: String,
      enums: String,
      bytes: String,
    });
  } catch (error) {
    console.error(`Failed to decode ${messageType}:`, error);
    throw error;
  }
};

// ä¸“é—¨ç”¨äºè§£ç é€šçŸ¥æ¶ˆæ¯
export const decodeNotifyMessage = async (buffer) => {
  try {
    const NotifyMessage = protoTypes.NotifyMessage || root.lookupType('NotifyMessage');
    const message = NotifyMessage.decode(new Uint8Array(buffer));
    return NotifyMessage.toObject(message, {
      longs: String,
      enums: String,
      bytes: String,
    });
  } catch (error) {
    console.error('Failed to decode notify message:', error);
    throw error;
  }
};

