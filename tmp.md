

# File_Server 设计与实现

## 1. 功能设计

1. **文件的上传：**
   - **单个文件的上传：** 这个接口基本用于后台部分，收到文件消息后将文件数据转发给文件子服务进行存储。
   - **多个文件的上传：** 这个接口基本用于后台部分，收到文件消息后将文件数据转发给文件子服务进行存储。

2. **文件的下载：**
   - **单个文件的下载：** 在后台用于获取用户头像文件数据，以及客户端用于获取文件/语音/图片消息的文件数据。
   - **多个文件的下载：** 在后台用于大批量获取用户头像数据（比如获取用户列表的时候），以及前端的批量文件下载。

## 2. 模块划分

1. **参数/配置文件解析模块：**
   - 基于 `gflags` 框架直接使用进行参数/配置文件解析。

2. **日志模块：**
   - 基于 `spdlog` 框架封装的模块直接使用进行日志输出。

3. **服务注册模块：**
   - 基于 `etcd` 框架封装的注册模块直接使用进行文件存储管理子服务的服务注册。

4. **RPC 服务模块：**
   - 基于 `brpc` 框架搭建 RPC 服务器。

5. **文件操作模块：**
   - 基于标准库的文件流操作实现文件读写的封装。

## 3. 模块功能示意图

（此处插入模块功能示意图）

## 4. 接口实现流程

### 4.1 单个文件的上传

1. 获取文件元数据（大小、文件名、文件内容）。
2. 为文件分配文件 ID。
3. 以文件 ID 为文件名打开文件，并写入数据。
4. 组织响应进行返回。

### 4.2 多个文件的上传

>多文件上传相较于单文件上传，就是将处理过程循环进行。

1. 从请求中获取文件元数据。
2. 为文件分配文件 ID。
3. 以文件 ID 为文件名打开文件，并写入数据。
4. 回到第一步进行下一个文件的处理。
5. 当所有文件数据存储完毕，组织响应进行返回。

### 4.3 单个文件的下载

1. 从请求中获取文件 ID。
2. 以文件 ID 作为文件名打开文件，获取文件大小，并从中读取文件数据。
3. 组织响应进行返回。

### 4.4 多个文件的下载

>多文件下载相较于单文件下载，就是将处理过程循环进行。

1. 从请求中获取文件 ID。
2. 以文件 ID 作为文件名打开文件，获取文件大小，并从中读取文件数据。
3. 回到第一步进行下一个文件的处理。
4. 当所有文件数据获取完毕，组织响应进行返回。



# User_Server 设计与开发

## 1. 功能设计

**用户管理子服务：**

>主要用于管理用户的数据，以及关于用户信息的各项操作。用户子服务需要提供以下接口：
  1. 用户注册：用户输入用户名（昵称）以及密码进行用户名的注册。
  2. 用户登录：用户通过用户名和密码进行登录。
  3. 短信验证码获取：当用户通过手机号注册或登录时，需要获取短信验证码。
  4. 手机号注册：用户输入手机号和短信验证码进行手机号的用户注册。
  5. 手机号登录：用户输入手机号和短信验证码进行手机号的用户登录。
  6. 用户信息获取：用户登录后，获取个人信息进行展示。
  7. 头像修改：设置用户头像。
  8. 昵称修改：设置用户昵称。
  9. 签名修改：设置用户签名。
  10. 手机号修改：修改用户的绑定手机号。

## 2. 模块划分

1. **参数/配置文件解析模块：**
   - 基于 `gflags` 框架直接使用进行参数/配置文件解析。

2. **日志模块：**
   - 基于 `spdlog` 框架封装的模块直接使用进行日志输出。

3. **服务注册模块：**
   - 基于 `etcd` 框架封装的注册模块直接使用，进行聊天消息存储子服务的注册。

4. **数据库数据操作模块：**
   - 基于 `odb-mysql` 数据管理封装的模块，实现关系型数据库中的数据操作。
     - 用户进行用户名/手机号注册时在数据库中进行新增信息。
     - 用户修改个人信息时修改数据库中的记录。
     - 用户登录时，在数据库中进行用户名密码的验证。

5. **Redis 客户端模块：**
   - 基于 `redis++` 封装的客户端进行内存数据库数据操作。
     - 用户登录时需要为用户创建登录会话，会话信息保存在 Redis 服务器中。
     - 用户手机号进行获取/验证验证码时，验证码与对应信息保存在 Redis 服务器中。

6. **RPC 服务模块：**
   - 基于 `brpc` 框架搭建 RPC 服务器。

7. **RPC 服务发现与调用模块：**
   - 基于 `etcd` 框架与 `brpc` 框架封装的服务发现与调用模块。
     - 连接文件管理子服务：获取用户信息时，用户头像通过文件形式存储在文件子服务中。
     - 连接消息管理子服务：打开聊天会话时，需要获取最近的一条消息进行展示。

8. **ES 客户端模块：**
   - 基于 `elasticsearch` 框架实现访问客户端，向 ES 服务器中存储用户信息，以便于用户搜索。

9. **短信平台客户端模块：**
   - 基于短信平台 SDK 封装使用，用于向用户手机号发送指定验证码。

## 3. 功能模块示意图

（此处插入功能模块示意图）

## 4. 数据管理

对用户数据的管理：
1. mysql：存储用户元信息，以便用于登录验证以及用户信息获取
2. elasticserarch：存储用户元信息，以便通过关键字搜索用户
3. redis：存储登录会话（session）信息、验证码校验

### 4.1 关系数据库数据管理

**用户数据表：**

- 包含字段：
  1. 主键 ID：自动生成。
  2. 用户 ID：用户唯一标识。
  3. 用户昵称：用户的昵称，也可用作登录用户名。
  4. 用户签名：用户对自己的描述。
  5. 登录密码：登录验证。
  6. 绑定手机号：用户可以绑定手机号，绑定后可以通过手机号登录。
  7. 用户头像文件 ID：头像文件存储的唯一标识，具体头像数据存储在文件子服务器中。

- 提供的操作：
  1. 通过昵称获取用户信息。
  2. 通过手机号获取用户信息。
  3. 通过用户 ID 获取用户信息。
  4. 新增用户。
  5. 更新用户信息。

**ODB 映射数据结构：**

```cpp
#pragma once
#include <string>
#include <cstddef> // std::size_t
#include <boost/date_time/posix_time/posix_time.hpp>
#include <odb/nullable.hxx>
#include <odb/core.hxx>

/* 在 C++ 中，要使用 ODB 将类声明为持久化类，
需要包含 ODB 的核心头文件，并使用 #pragma db object 指令 #pragma db object
指示 ODB 编译器将 person 类视为一个持久化类。 */

typedef boost::posix_time::ptime ptime;

#pragma db object table("user")
class User
{
    friend class odb::access;

private:
#pragma db id auto
    unsigned long _id;
#pragma db type("varchar(64)") index unique
    std::string _user_id;
#pragma db type("varchar(64)") index unique
    odb::nullable<std::string> _nickname;    // 用户昵称-不一定存在
    odb::nullable<std::string> _description; // 用户签名 - 不一定存在
#pragma db type("varchar(64)")
    odb::nullable<std::string> _password;    // 用户密码 - 不一定存在
#pragma db type("varchar(64)") index unique
    odb::nullable<std::string> _phone;       // 用户手机号 - 不一定存在
#pragma db type("varchar(64)")
    odb::nullable<std::string> _avatar_id;   // 用户头像文件ID - 不一定存在

public:
    // 用户名+密码注册
    User(const std::string &uid, const std::string &nickname, const std::string &password) : _user_id(uid), _nickname(nickname), _password(password) {}

    // 手机号+密码注册
    User(const std::string &uid, const std::string &phone) : _user_id(uid), _nickname(uid), _phone(phone) {}

    void user_id(const std::string &val)
    {
        _user_id = val;
    }
    std::string user_id() { return _user_id; }

    std::string nickname()
    {
        if (_nickname)
            return *_nickname;
        return std::string();
    }
    void nickname(const std::string &val) { _nickname = val; }

    std::string description()
    {
        if (!_description)
            return std::string();
        return *_description;
    }
    void description(const std::string &val) { _description = val; }

    std::string password()
    {
        if (!_password)
            return std::string();
        return *_password;
    }
    void password(const std::string &val) { _password = val; }

    std::string phone()
    {
        if (!_phone)
            return std::string();
        return *_phone;
    }
    void phone(const std::string &val) { _phone = val; }

    std::string avatar_id()
    {
        if (!_avatar_id)
            return std::string();
        return *_avatar_id;
    }
    void avatar_id(const std::string &val) { _avatar_id = val; }

    User() {}
    ~User() {}
};

// odb -d mysql --std c++17 --generate-query --generate-schema --profile boost/date-time user.hxx
```


ODB自动生成的SQL代码:
```sql
DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` BIGINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
  `user_id` varchar(64) NOT NULL,
  `nickname` varchar(64) NULL,
  `description` TEXT NULL,
  `password` varchar(64) NULL,
  `phone` varchar(64) NULL,
  `avatar_id` varchar(64) NULL)
 ENGINE=InnoDB;

CREATE UNIQUE INDEX `user_id_i`
  ON `user` (`user_id`);

CREATE UNIQUE INDEX `nickname_i`
  ON `user` (`nickname`);

CREATE UNIQUE INDEX `phone_i`
  ON `user` (`phone`);
```


### 4.2 内存数据库数据管理

**会话信息映射键值对：**

- 映射类型：字符串键值对映射。
- 映射字段：
  1. 会话 ID (key) - 用户 ID (val)：便于通过会话 ID 查找用户 ID，进行后续操作时的连接身份识别鉴权。
     - 在用户登录时新增数据。
     - 在用户登录后的操作时进行验证及查询。
     - 该映射数据在用户退出登录时删除（目前未实现）。
  2. 用户 ID (key) - 空 (val)：这是一个用户登录状态的标记，用于避免重复登录。
     - 在用户登录时新增数据。
     - 在用户连接断开时删除数据。

**验证码信息映射键值对：**

- 映射类型：字符串键值对映射。
- 映射字段：
  1. 验证码 ID (key) - 验证码 (val)：用于生成一个验证码 ID 和验证码。
     - 用户获取短信验证码时新增数据。
     - 验证码通过短信平台发送给用户手机。
     - 验证码 ID 直接响应发送给用户，用户登录时通过这两个信息进行验证。
     - 该映射字段需要设置一个 60s 过期自动删除的时间，并在验证完毕后删除。

### 4.3 文档数据库数据管理

**用户信息的用户 ID、手机号、昵称字段需要在 ES 服务器额外存储一份。**

- 目的：用户搜索通常是一种字符串的模糊匹配方式，用传统的关系型数据库进行模糊匹配效率低，因此采用 ES 服务对索引字段进行分词后构建倒排索引，根据关键词进行搜索，提升效率。

**创建用户索引：**

```json
POST /user/_doc
{
    "settings" : {
        "analysis" : {
            "analyzer" : {
                "ik" : {
                    "tokenizer" : "ik_max_word"
                }
            }
        }
    },
    "mappings" : {
        "dynamic" : true,
        "properties" : {
            "nickname" : {
                "type" : "text",
                "analyzer" : "ik_max_word"
            },
            "user_id" : {
                "type" : "keyword",
                "analyzer" : "standard"
            },
            "phone" : {
                "type" : "keyword",
                "analyzer" : "standard"
            },
            "description" : {
                "type" : "text",
                "index": "not_analyzed"
            },
            "avatar_id" : {
                "type" : "text",
                "index": "not_analyzed"
            }
        }
    }
}
```

**新增测试数据：**

```json
POST /user/_doc/_bulk
{"index":{"_id":"1"}}
{"user_id" : "USER4b862aaa-2df8654a-7eb4bb65-e3507f66","nickname" : "昵称 1","phone" : "手机号 1","description" : "签名 1","avatar_id" : "头像 1"}
{"index":{"_id":"2"}}
{"user_id" : "USER14eeeaa5-442771b9-0262e455-e4663d1d","nickname" : "昵称 2","phone" : "手机号 2","description" : "签名 2","avatar_id" : "头像 2"}
{"index":{"_id":"3"}}
{"user_id" : "USER484a6734-03a124f0-996c169d-d05c1869","nickname" : "昵称 3","phone" : "手机号 3","description" : "签名 3","avatar_id" : "头像 3"}
{"index":{"_id":"4"}}
{"user_id" : "USER186ade83-4460d4a6-8c08068f-83127b5d","nickname" : "昵称 4","phone" : "手机号 4","description" : "签名 4","avatar_id" : "头像 4"}
{"index":{"_id":"5"}}
{"user_id" : "USER6f19d074-c33891cf-23bf5a83-57189a19","nickname" : "

昵称 5","phone" : "手机号 5","description" : "签名 5","avatar_id" : "头像 5"}
{"index":{"_id":"6"}}
{"user_id" : "USER97605c64-9833ebb7-d0455353-35a59195","nickname" : "昵称 6","phone" : "手机号 6","description" : "签名 6","avatar_id" : "头像 6"}
```

**进行搜索测试：**

```json
GET /user/_doc/_search?pretty
{
    "query": {
        "match_all": {}
    }
}
```

```json
GET /user/_doc/_search?pretty
{
    "query" : {
        "bool" : {
            "must_not" : [
                {
                    "terms" : {
                        "user_id.keyword" : [
                            "USER4b862aaa-2df8654a-7eb4bb65-e3507f66",
                            "USER14eeeaa5-442771b9-0262e455-e4663d1d",
                            "USER484a6734-03a124f0-996c169d-d05c1869"
                        ]
                    }
                }
            ],
            "should" : [
                {
                    "match" : {
                        "user_id" : "昵称"
                    }
                },
                {
                    "match" : {
                        "nickname" : "昵称"
                    }
                },
                {
                    "match" : {
                        "phone" : "昵称"
                    }
                }
            ]
        }
    }
}
```

**删除用户索引：**

```json
DELETE /user
```

## 5. 接口实现流程

### 5.1 用户注册

1. 从请求中取出昵称和密码。
2. 检查昵称是否合法（只能包含字母，数字，连字符-，下划线_，长度限制 3~15 之间）。
3. 检查密码是否合法（只能包含字母，数字，长度限制 6~15 之间）。
4. 根据昵称在数据库中判断是否昵称已存在。
5. 向数据库新增数据。
6. 向 ES 服务器中新增用户信息。
7. 组织响应，返回成功与否。

### 5.2 用户登录

1. 从请求中取出昵称和密码。
2. 通过昵称获取用户信息，进行密码是否一致的判断。
3. 根据 Redis 中的登录标记信息判断用户是否已经登录。
4. 构造会话 ID，生成会话键值对，向 Redis 中添加会话信息以及登录标记信息。
5. 组织响应，返回生成的会话 ID。

### 5.3 获取短信验证码

1. 从请求中取出手机号码。
2. 验证手机号码格式是否正确（必须以 1 开始，第二位 3~9 之间，后边 9 个数字字符）。
3. 生成 4 位随机验证码。
4. 基于短信平台 SDK 发送验证码。
5. 构造验证码 ID，添加到 Redis 验证码映射键值索引中。
6. 组织响应，返回生成的验证码 ID。

### 5.4 手机号注册

1. 从请求中取出手机号码和验证码。
2. 检查注册手机号码是否合法。
3. 从 Redis 数据库中进行验证码 ID-验证码一致性匹配。
4. 通过数据库查询判断手机号是否已注册。
5. 向数据库新增用户信息。
6. 向 ES 服务器中新增用户信息。
7. 组织响应，返回注册成功与否。

### 5.5 手机号登录

1. 从请求中取出手机号码和验证码 ID，以及验证码。
2. 检查注册手机号码是否合法。
3. 从 Redis 数据库中进行验证码 ID-验证码一致性匹配。
4. 根据手机号从数据库查询用户信息，判断用户是否存在。
5. 根据 Redis 中的登录标记信息判断用户是否已经登录。
6. 构造会话 ID，生成会话键值对，向 Redis 中添加会话信息以及登录标记信息。
7. 组织响应，返回生成的会话 ID。

### 5.6 获取用户信息

1. 从请求中取出用户 ID。
2. 通过用户 ID 从数据库中查询用户信息。
3. 根据用户信息中的头像 ID，从文件服务器获取头像文件数据，组织完整用户信息。
4. 组织响应，返回用户信息。

### 5.7 设置头像

1. 从请求中取出用户 ID 与头像数据。
2. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在。
3. 上传头像文件到文件子服务。
4. 将返回的头像文件 ID 更新到数据库中。
5. 更新 ES 服务器中用户信息。
6. 组织响应，返回更新成功与否。

### 5.8 设置昵称

1. 从请求中取出用户 ID 与新的昵称。
2. 判断昵称格式是否正确。
3. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在。
4. 将新的昵称更新到数据库中。
5. 更新 ES 服务器中用户信息。
6. 组织响应，返回更新成功与否。

### 5.9 设置签名

1. 从请求中取出用户 ID 与新的签名。
2. 从数据库通过用户 ID 进行用户信息查询，判断用户是否存在。
3. 将新的签名更新到数据库中。
4. 更新 ES 服务器中用户信息。
5. 组织响应，返回更新成功与否。

### 5.10 设置绑定手机号

1. 从请求中取出手机号码和验证码 ID，以及验证码。
2. 检查注册手机号码是否合法。
3. 从 Redis 数据库中进行验证码 ID-验证码一致性匹配。
4. 根据手机号从数据库查询用户信息，判断用户是否存在。
5. 将新的手机号更新到数据库中。
6. 更新 ES 服务器中用户信息。
7. 组织响应，返回更新成功与否。

### 5.10 设置密码



# MessageTransmitServer 设计与实现

## 1. 功能设计

**转发子服务：**

- 主要用于针对一条消息内容，组织消息的 ID 以及各项所需元素，然后告知网关服务器一条消息应该发给谁。
- 通常消息都是以聊天会话为基础进行发送的，根据会话找到它的所有成员，这就是转发的目标。
- 转发子服务将收到的消息放入消息队列中，由消息存储管理子服务进行消费存储。

**核心功能：**

1. 获取消息转发目标：针对消息内容，组织消息，并告知网关转发目标。

## 2. 模块划分

1. **参数/配置文件解析模块：**
   - 基于 `gflags` 框架直接使用进行参数/配置文件解析。

2. **日志模块：**
   - 基于 `spdlog` 框架封装的模块直接使用进行日志输出。

3. **服务注册模块：**
   - 基于 `etcd` 框架封装的注册模块直接使用进行消息转发服务的服务注册。

4. **数据库数据操作模块：**
   - 基于 `odb-mysql` 数据管理封装的模块，从数据库获取会话成员。

5. **服务发现与调用模块：**
   - 基于 `etcd` 框架与 `brpc` 框架封装的服务发现与调用模块，从用户子服务获取消息发送者的用户信息。

6. **RPC 服务模块：**
   - 基于 `brpc` 框架搭建 RPC 服务器。

7. **MQ 发布模块：**
   - 基于 `rabbitmq-client` 封装的模块将消息发布到消息队列，让消息存储子服务进行消费，对消息进行存储。

## 3. 功能模块示意图

（此处插入功能模块示意图）

## 4. 接口实现流程

**获取消息转发目标与消息处理：**

1. 从请求中取出消息内容、会话 ID、用户 ID。
2. 根据用户 ID 从用户子服务获取当前发送者用户信息。
3. 根据消息内容构造完整的消息结构（分配消息 ID，填充发送者信息，填充消息产生时间）。
4. 将消息序列化后发布到 MQ 消息队列中，让消息存储子服务对消息进行持久化存储。
5. 从数据库获取目标会话所有成员 ID。
6. 组织响应（完整消息 + 目标用户 ID），发送给网关，告知网关该将消息发送给谁。





# MessageStoreServer设计

## 15.1 功能设计

**消息管理子服务：**

- 主要用于管理消息的存储：
  - **文本消息：** 储存在 ElasticSearch 文档搜索服务中。
  - **文件/语音/图片：** 需要转储到文件管理子服务中。
  
- 还需管理消息的搜索与获取，对外提供以下接口：
  1. **获取历史消息：**
     - 获取最近 N 条消息：用于登录成功后，点击对方头像打开聊天框时显示最近的消息。
     - 获取指定时间段内的消息：用户可以按时间搜索聊天消息。
  2. **关键字消息搜索：** 用户可以针对指定好友的聊天消息进行关键字搜索。

## 15.2 模块划分

1. **参数/配置文件解析模块：**
   - 基于 `gflags` 框架直接使用进行参数/配置文件解析。

2. **日志模块：**
   - 基于 `spdlog` 框架封装的模块直接使用进行日志输出。

3. **服务注册模块：**
   - 基于 `etcd` 框架封装的注册模块直接使用，进行聊天消息存储子服务的注册。

4. **数据库数据操作模块：**
   - 基于 `odb-mysql` 数据管理封装的模块，进行数据库数据操作，用于从 MQ 中消费到消息后，向数据库中存储一份，以便通过时间进行范围性查找。
   - 从数据库根据指定用户的所有好友信息。

5. **RPC 服务模块：**
   - 基于 `brpc` 框架搭建 RPC 服务器。

6. **服务发现与调用模块：**
   - 基于 `etcd` 和 `brpc` 框架封装的服务发现与调用模块。
   - 连接文件管理子服务：将文件/语音/图片类型的消息以及用户头像之类的文件数据转储到文件管理子服务。
   - 连接用户管理子服务：在消息搜索时，根据发送用户的 ID 获取发送者用户信息。

7. **ES 客户端模块：**
   - 基于 `elasticsearch` 框架实现访问客户端，向 ES 服务器进行文本聊天消息的存储，以便于文本消息的关键字搜索。

8. **MQ 消费模块：**
   - 基于 `rabbitmq-client` 封装的消费者模块从消息队列服务器消费获取聊天消息，将文本消息存储到 ElasticSearch 服务，将文件消息转储到文件管理子服务，所有消息的简息都需要向数据库存储一份。

## 15.3 数据管理

### 15.3.1 数据库消息管理

**说明：**

- 在消息的存储管理中，所有的消息简息都要在数据库中存储一份，进行消息的持久化，以便于进行时间范围性查询和离线消息的实现。
- 消息类型有四种：文本，文件，语音，图片。数据库中只存储文本消息和其他类型消息的元信息。

**数据库表结构：**

- 消息 ID：唯一标识。
- 消息产生时间：用于进行时间性搜索。
- 消息发送者用户 ID：明确消息的发送者。
- 消息产生会话 ID：明确消息属于哪个会话。
- 消息类型：明确消息的类型。
- 消息内容：只存储文本消息；文件/语音/图片数据不进行存储，或存储在文件子服务中。
- 文件 ID：只有文件/语音/图片类消息会用到。
- 文件大小：只有文件/语音/图片类消息会用到。
- 文件名称：只有文件类消息会用到。

**数据库操作：**

- 新增消息。
- 通过消息 ID 获取消息信息。
- 通过会话 ID，时间范围，获取指定时间段之内的消息，并按时间进行排序。
- 通过会话 ID，消息数量，获取最近的 N 条消息（逆序 + limit 即可）。

**ODB 映射数据结构：**

```cpp
#include <string>
#include <cstddef>
#include <odb/core.hxx>
#include <odb/nullable.hxx>
#include <boost/date_time/posix_time/posix_time.hpp>

#pragma db object
class message
{
public:
    message (){}
private:
    friend class odb::access;

    #pragma db id auto
    unsigned long _id;
    #pragma db unique type("VARCHAR(127)")
    std::string _message_id ;
    #pragma db type("TIMESTAMP") not_null
    boost::posix_time::ptime _created_time;
    #pragma db type("VARCHAR(127)")
    std::string _from_user_id ;
    #pragma db type("VARCHAR(127)")
    std::string _to_session_id ;
    #pragma db not_null
    signed char _message_type ;
    odb::nullable<std::string> _content;
    #pragma db type("VARCHAR(127)")
    odb::nullable<std::string> _file_id ;
    #pragma db type("VARCHAR(127)")
    odb::nullable<std::string> _filename ;
    odb::nullable<unsigned long> _filesize;
};
```

### 15.3.2 ES 文本消息管理

**说明：**

- 为了实现聊天内容的关键字搜索功能，而不在数据库中进行模糊匹配，采用 ES 进行消息内容存储与搜索。在搜索时，需要进行会话的过滤，因此需要考虑 ES 索引的构造。

**ES 文档 INDEX：**

```json
POST /message/_doc
{
    "settings" : {
        "analysis" : {
            "analyzer" : {
                "ik" : {
                    "tokenizer" : "ik_max_word"
                }
            }
        }
    },
    "mappings" : {
        "dynamic" : true,
        "properties" : {
            "chat_session_id" : {
                "type" : "keyword",
                "analyzer" : "standard"
            },
            "message_id" : {
                "type" : "keyword",
                "analyzer" : "standard"
            },
            "content" : {
                "type" : "text",
                "analyzer" : "ik_max_word"
            }
        }
    }
}
```

**ES 消息测试用例：**

**新增数据：**

```json
POST /message/_doc/_bulk
{"index":{"_id":"1"}}
{"chat_session_id" : "会话 ID1","message_id" : "消息 ID1","content" : "吃饭了么？"}
{"index":{"_id":"2"}}
{"chat_session_id" : "会话 ID1","message_id" : "消息 ID2","content" : "吃的盖浇饭。"}
{"index":{"_id":"3"}}
{"chat_session_id" : "会话 ID2","message_id" : "消息 ID3","content" : "昨天吃饭了么？"}
{"index":{"_id":"4"}}
{"chat_session_id" : "会话 ID2","message_id" : "消息 ID4","content" : "昨天吃的盖浇饭。"}
```

**查看数据：**

```json
GET /message/_doc/_search?pretty
{
    "query": {
        "match_all": {}
    }
}
```

**搜索数据：**

```json
GET /message/_doc/_search?pretty
{
    "query" : {
        "bool" : {
            "must" : [
                {
                    "term" : { "chat_session_id.keyword" : "会话 ID1" }
                },
                {
                    "match" : { "content" : "盖浇饭" }
                }
            ]
        }
    }
}
```

**删除索引：**

```json
DELETE /message
```

## 15.4 接口实现流程

### 15.4.1 最近 N 条消息获取

1. 从请求中，获取会话 ID，和要获取的消息数量。
2. 访问数据库，从数据库中按时间排序，获取指定数量的消息简略信息（消息 ID，会话 ID，消息类型，产生时间，发送者用户 ID，文本消息内容，文件消息元信息）。
3. 循环构造完整消息（从用户子服务获取消息的发送者用户信息，从文件子服务获取文件/语音/图片数据）。
4. 组织响应返回给网关服务器。

### 15.4.2 指定时间段消息搜索

1. 从请求中，获取会话 ID，以及要获取的消息的起始时间与结束时间。
2. 访问数据库，从数据库中按时间进行范围查询，获取消息简略信息（消息 ID，会话 ID，消息类型，产生时间，发送者用户 ID，文本消息内容，文件消息元信息）。
3. 循环构造完整消息（从用户子服务获取消息的发送者用户信息，从文件子服务获取文件/语音/图片数据）。
4. 组织响应返回给网关服务器。

### 15.4.3 关键字消息搜索

1. 从请求中，获取会话 ID，以及搜索关键字。
2. 基于封装的 ES 客户端，访问 ES 服务器进行文本消息搜索（以消息内容进行搜索，并以会话 ID 进行过滤），从 ES 服务器获取到消息简略信息（消息 ID

，会话 ID，文本消息内容）。
3. 循环从数据库根据消息 ID 获取消息简略信息（消息 ID，消息类型，会话 ID，发送者 ID，产生时间，文本消息内容，文件消息元数据）。
4. 循环从用户子服务获取所有消息的发送者用户信息，构造完整消息。
5. 组织响应返回给网关服务器。
# FriendServer 设计

## 19.1 功能设计

好友管理子服务，主要用于管理好友相关的数据与操作，因此主要负责以下接口：

1. **好友列表的获取：** 当用户登录成功之后，获取自己好友列表进行展示。
2. **申请好友：** 搜索用户之后，点击申请好友，向对方发送好友申请。
3. **待处理申请的获取：** 当用户登录成功之后，会获取离线的好友申请请求以待处理。
4. **好友申请的处理：** 针对收到的好友申请进行同意/拒绝的处理。
5. **删除好友：** 删除当前好友列表中的好友。
6. **用户搜索：** 可以进行用户的搜索用于申请好友。
7. **聊天会话列表的获取：** 每个单人/多人聊天都有一个聊天会话，在登录成功后可以获取聊天会话，查看历史的消息以及对方的各项信息。
8. **多人聊天会话的创建：** 单人聊天会话在对方同意好友时创建，而多人会话需要调用该接口进行手动创建。
9. **聊天成员列表的获取：** 多人聊天会话中，可以点击查看群成员按钮，查看群成员信息。

## 19.2 模块划分

1. **参数/配置文件解析模块：** 基于 `gflags` 框架直接使用进行参数/配置文件解析。
2. **日志模块：** 基于 `spdlog` 框架封装的模块直接使用进行日志输出。
3. **服务注册模块：** 基于 `etcd` 框架封装的注册模块直接使用，进行聊天消息存储子服务的注册。
4. **数据库数据操作模块：** 基于 `odb-mysql` 数据管理封装的模块，实现数据库中数据的操作。
   - 申请好友的时候，根据数据库中的数据判断两人是否已经是好友关系。
   - 申请好友的时候，根据数据库中的数据判断是否已经申请过好友。
   - 申请好友的时候，针对两位用户 ID 建立好友申请事件信息。
   - 好友信息处理的时候，找到申请事件，进行删除。
   - 获取待处理好友申请事件的时候，从数据库根据用户 ID 查询出所有的申请信息。
   - 同意好友申请的时候，需要创建单聊会话，向数据库中插入会话信息。
   - 从数据库根据指定用户 ID 获取所有好友 ID。
   - 创建群聊的时候，需要创建群聊会话，向数据库中插入会话信息。
   - 查看群聊成员的时候，从数据库根据会话 ID 获取所有会话成员 ID。
   - 获取会话列表的时候，从数据库根据用户 ID 获取到所有会话信息。
   - 删除好友的时候，从数据库中删除两人的好友关系，以及单聊会话，以及会话成员信息。
5. **RPC 服务模块：** 基于 `brpc` 框架搭建 RPC 服务器。
6. **RPC 服务发现与调用模块：** 基于 `etcd` 框架与 `brpc` 框架封装的服务发现与调用模块。
   - 连接用户管理子服务：获取好友列表，会话成员，好友申请事件的时候获取用户信息。
   - 连接消息管理子服务：在打开聊天会话的时候，需要获取最近的一条消息进行展示。
7. **ES 客户端模块：** 基于 `elasticsearch` 框架实现访问客户端，从 ES 服务器进行用户的关键字搜索（用户信息由用户子服务在用户注册的时候添加进去）。

## 19.3 功能模块示意图

（此处插入功能模块示意图）

## 19.4 数据管理

### 19.4.1 数据库数据管理

**用户信息表**

- 该表由用户操作服务进行创建，并在用户注册时添加数据，好友这里只进行查询。
- 通过用户 ID 获取详细用户信息。

**用户关系表**

- 因为本身用户服务器已经管理了用户个人信息，因此没必要再整一份用户信息出来。因为当前用户之间只有好友关系（目前未实现：黑名单，陌生人等），因此这里是一个好友关系表，表示谁和谁是好友。
- 包含字段：
  - ID：作为主键。
  - 用户 ID。
  - 好友 ID。
- 需要注意的是两个用户结为好友时，需要添加 (1,2)、(2,1) 两条数据。

**提供的操作：**

- 新增用户关系：
  - 新增好友，通常伴随着新增会话，新增会话伴随着新增会话成员。
- 移除用户关系：
  - 移除好友，通常伴随着移除会话，移除会话伴随着移除会话成员。
- 判断两人是否是好友关系。
- 以用户 ID 获取用户的所有好友 ID。
- 与用户表连接，以用户 ID 获取所有好友详细信息。

**ODB 映射结构：**

```cpp
#pragma once
#include <odb/core.hxx>
#include <odb/nullable.hxx>

#pragma db object
class friend_relation {
    public:
        friend_relation(){} 
    private:
        friend class odb::access;
        #pragma db id auto 
        long int _id; 
        #pragma db index type("VARCHAR(127)") 
        std::string _user_id; 
        #pragma db type("VARCHAR(127)") 
        std::string _friend_id; 
};
```

**会话信息**

- 在多人聊天中，舍弃了群的概念，添加了聊天会话的概念，因为会话既可以是两人单聊会话，也可以是多人聊天会话，这样就可以统一管理了。
- 包含字段：
  - ID：作为主键。
  - 会话 ID：会话标识。
  - 会话名称：单聊会话则设置为'单聊会话'或直接为空就行，因为单聊会话名称就是对方名称，头像就是对方头像。
  - 会话类型：`SINGLE`-单聊 / `GROUP`-多人（单聊由服务器在同意好友时创建，多人由用户申请创建）。

**提供的操作：**

- 新增会话：
  - 向会话成员表中新增会话成员信息。
  - 向会话表中新增会话信息。
- 删除会话：
  - 删除会话成员表中的所有会话成员信息。
  - 删除会话表中的会话信息。
- 通过会话 ID，获取会话的详细信息。
- 通过用户 ID 获取所有的好友单聊会话（连接会话成员表和用户表）。
  - 所需字段：
    - 会话 ID。
    - 会话名称：好友的昵称。
    - 会话类型：单聊类型。
    - 会话头像 ID：好友的头像 ID。
    - 好友 ID。
- 通过用户 ID 获取所有自己的群聊会话（连接会话成员表和用户表）。
  - 所需字段：
    - 会话 ID。
    - 会话名称。
    - 会话类型：群聊类型。

**ODB 映射结构：**

```cpp
#pragma once
#include <odb/core.hxx>
#include <odb/nullable.hxx>

enum class session_type_t { 
    SINGLE = 1, 
    GROUP = 2 
}; 

#pragma db object 
class chat_session { 
    public: 
        chat_session() {} 
    private: 
        friend class odb::access; 
        #pragma db id auto 
        long int _id; 
        #pragma db unique type("VARCHAR(127)") 
        std::string _session_id; 
        #pragma db type("VARCHAR(127)") 
        odb::nullable<std::string> _session_name; 
        #pragma db type("TINYINT") 
        session_type_t _session_type;
};
```

**会话成员**

- 每个会话中都会有两个及以上的成员，只有两个成员的会话是单聊会话，超过两个是多人聊天会话。为了明确哪个用户属于哪个会话，或者说会话中有哪些成员，因此需要有会话成员的数据管理。
- 包含字段：
  - ID：作为主键。
  - 会话 ID：会话标识。
  - 用户 ID：用户标识。

**提供的操作：**

- 向指定会话中添加单个成员。
- 向指定会话中添加多个成员。
- 从指定会话中删除单个成员。
- 通过会话 ID，获取会话的所有成员 ID。
- 删除会话所有成员：在删除会话的时候使用。

**ODB 映射结构：**

```cpp
#pragma once
#include <odb/core.hxx>
#include <odb/nullable.hxx>

#pragma db object 
class chat_session_member {
    public: 
        chat_session_member (){} 
    private: 
        friend class odb::access; 
        #pragma db id auto 
        unsigned long _id; 
        #pragma db index type("VARCHAR(127)") 
        std::string _session_id; 
        #pragma db type("VARCHAR(127)") 
        std::string _user_id; 
};
```

**好友申请事件**

- 在好友的操作中有个操作需要额外的管理，那就是申请好友的事件。因为用户 A 申请用户 B 为好友，并非一次性完成，需要用户 B 对本次申请进行处理，同意后才算是

一次完整的流程。而在两次操作之间我们就需要为两次操作建立起相匹配的关系映射。
- 包含字段：
  - ID：作为主键。
  - 事件 ID。
  - 请求者用户 ID。
  - 响应者用户 ID。
  - 状态：用于表示本次请求的处理阶段，其包含三种状态：待处理-todo，同意-accept，拒绝-reject。

**提供的操作：**

- 新增好友申请事件：申请的时候新增。
- 删除好友申请事件：处理完毕（同意/拒绝）的时候删除。
- 获取指定用户的所有待处理事件及关联申请者用户信息（连接用户表）。

**ODB 映射结构：**

```cpp
enum class fevent_status{
    PENDING = 1, 
    ACCEPT = 2, 
    REJECT = 3 
}; 

#pragma db object 
class friend_event {
    public: 
        friend_event() {} 
    private: 
        friend class odb::access; 
        #pragma db id auto 
        long int _id; 
        #pragma db unique type("VARCHAR(127)") 
        std::string _event_id; 
        #pragma db type("VARCHAR(127)") 
        std::string _req_user_id; 
        #pragma db type("VARCHAR(127)") 
        std::string _rsp_user_id; 
        #pragma db type("TINYINT") 
        fevent_status _status; 
};
```

### 19.4.2 ES用户信息管理

**创建用户索引**

```json
POST /user/_doc 
{ 
    "settings" : { 
        "analysis" : { 
            "analyzer" : { 
                "ik" : { 
                    "tokenizer" : "ik_max_word" 
                } 
            } 
        } 
    }, 
    "mappings" : { 
        "dynamic" : true, 
        "properties" : { 
            "nickname" : { 
                "type" : "text", 
                "analyzer" : "ik_max_word" 
            }, 
            "user_id" : { 
                "type" : "keyword", 
                "analyzer" : "standard" 
            }, 
            "phone" : { 
                "type" : "keyword", 
                "analyzer" : "standard" 
            }, 
            "description" : { 
                "type" : "text", 
                "index": "not_analyzed" 
            }, 
            "avatar_id" : { 
                "type" : "text", 
                "index": "not_analyzed" 
            } 
        } 
    } 
}
```

**新增测试数据**

```json
POST /user/_doc/_bulk 
{"index":{"_id":"1"}} 
{"user_id" : "USER4b862aaa-2df8654a-7eb4bb65-e3507f66","nickname" : "昵称 1","phone" : "手机号 1","description" : "签名 1","avatar_id" : "头像 1"} 
{"index":{"_id":"2"}} 
{"user_id" : "USER14eeeaa5-442771b9-0262e455-e4663d1d","nickname" : "昵称 2","phone" : "手机号 2","description" : "签名 2","avatar_id" : "头像 2"} 
{"index":{"_id":"3"}} 
{"user_id" : "USER484a6734-03a124f0-996c169d-d05c1869","nickname" : "昵称 3","phone" : "手机号 3","description" : "签名 3","avatar_id" : "头像 3"} 
{"index":{"_id":"4"}} 
{"user_id" : "USER186ade83-4460d4a6-8c08068f-83127b5d","nickname" : "昵称 4","phone" : "手机号 4","description" : "签名 4","avatar_id" : "头像 4"} 
{"index":{"_id":"5"}} 
{"user_id" : "USER6f19d074-c33891cf-23bf5a83-57189a19","nickname" : "昵称 5","phone" : "手机号 5","description" : "签名 5","avatar_id" : "头像 5"} 
{"index":{"_id":"6"}} 
{"user_id" : "USER97605c64-9833ebb7-d0455353-35a59195","nickname" : "昵称 6","phone" : "手机号 6","description" : "签名 6","avatar_id" : "头像 6"} 
```

**进行搜索测试**

```json
GET /user/_doc/_search?pretty 
{ 
    "query": { 
        "match_all": {} 
    } 
}
```

```json
GET /user/_doc/_search?pretty 
{ 
    "query" : { 
        "bool" : { 
            "must_not" : [ 
                { 
                    "terms" : { 
                        "user_id.keyword" : [ 
                            "USER4b862aaa-2df8654a-7eb4bb65-e3507f66", 
                            "USER14eeeaa5-442771b9-0262e455-e4663d1d", 
                            "USER484a6734-03a124f0-996c169d-d05c1869" 
                        ] 
                    } 
                } 
            ], 
            "should" : [ 
                { 
                    "match" : { 
                        "user_id" : "昵称" 
                    } 
                }, 
                { 
                    "match" : { 
                        "nickname" : "昵称" 
                    } 
                }, 
                { 
                    "match" : { 
                        "phone" : "昵称" 
                    } 
                } 
            ] 
        } 
    } 
}
```

**删除用户索引**

```json
DELETE /user
```

## 19.5 接口实现流程

### 19.5.1 获取好友列表

1. 获取请求中的用户 ID。
2. 根据用户 ID，从数据库的好友关系表和用户表中取出该用户所有的好友简息。
3. 根据好友简息中的好友头像 ID，批量获取头像数据，组织完整用户信息结构。
4. 组织响应，将好友列表返回给网关。

### 19.5.2 申请添加好友

1. 取出请求中的请求者 ID 和被请求者 ID。
2. 判断两人是否已经是好友。
3. 判断该用户是否已经申请过好友关系。
4. 向好友申请事件表中，新增申请信息。
5. 组织响应，将事件 ID 信息响应给网关。

### 19.5.3 获取待处理好友申请事件

1. 取出请求中的用户 ID。
2. 根据用户 ID，从申请事件表和用户表中找到该用户所有状态为 `PENDING` 的待处理事件关联申请人用户简息。
3. 根据申请人用户头像 ID，从文件存储子服务器获取所有用户头像信息，组织用户信息结构。
4. 组织响应，将申请事件列表响应给网关。

### 19.5.4 处理好友申请

1. 取出请求中的申请人 ID 和被申请人 ID，以及处理结果。
2. 根据两人 ID 在申请事件表中查询判断是否存在申请事件。
3. 判断两人是否已经是好友（互相加好友的情况）。
4. 不管拒绝还是同意，删除申请事件表中的事件信息（该事件处理完毕）。
5. 若同意申请，则向用户关系表中添加好友关系数据，向会话表中新增会话信息，向会话成员表中新增成员信息。
6. 组织响应，将新生成的会话 ID 响应给网关。

### 19.5.5 删除好友

1. 取出请求中的删除者 ID 和被删除者 ID。
2. 从用户好友关系表中删除相关关系数据，从会话表中删除单聊会话，从会话成员表中删除会话成员信息。
3. 组织响应，返回给网关。

### 19.5.6 搜索好友

1. 取出请求中的用户 ID 和搜索关键字。
2. 从好友关系表中取出该用户所有好友 ID。
3. 根据关键字从 ES 服务器中进行用户搜索，搜索的时候需要将关键字作为用户 ID、手机号、昵称的搜索关键字进行搜索，且需要根据自己的 ID 和好友 ID 过滤掉自己和自己的好友。
4. 根据搜索到的用户简息中的头像 ID，从文件服务器批量获取用户头像数据。
5. 组织响应，将搜索到的用户列表响应给网关。

### 19.5.7 创建会话

1. 从请求中取出用户 ID 与会话名称，以及会话的成员 ID 列表。
2. 生成会话 ID，并向会话表中新增会话信息数据，会话为群聊会话（单聊会话是同意好友申请的时候创建的）。
3. 向会话成员表中新增所有的成员信息。
4. 组织响应，将组织好的会话信息响应给网关。

### 19.5.

8 获取会话列表

1. 从请求中取出用户 ID。
2. 根据用户 ID，从会话表、会话成员表和用户表中取出好友的单聊会话列表（会话 ID、好友用户 ID、好友昵称、好友头像 ID），并组织会话信息结构对象。
   - 单聊会话中，对方的昵称就是会话名称，对方的头像就是会话头像，会话类型为单聊类型。
3. 根据单聊会话 ID，从消息存储子服务获取会话的最后一条消息。
4. 根据好友头像 ID，从文件存储子服务批量获取好友头像数据。
5. 组织好单聊会话结构数据。
6. 根据用户 ID，从会话表和会话成员表中取出群聊会话列表（会话 ID，会话名称）。
7. 根据群聊会话 ID，从消息存储子服务获取会话的最后一条消息。
8. 组织好群聊会话结构数据。
9. 将单聊会话数据和群聊会话数据组织到一起，响应给网关。

### 19.5.9 获取会话成员

1. 取出请求中用户 ID 和会话 ID。
2. 根据会话 ID，从会话成员表和用户表中取出所有的成员用户信息。
3. 根据成员信息中的头像 ID，从文件存储子服务批量获取头像数据组织用户信息结构。
4. 组织响应，将会话的成员用户信息列表响应给网关。




# GatewayServer 设计

## 20.1 功能设计

网关服务器在设计中，最重要的两个功能：

- 作为入口服务器接收客户端的所有请求，进行请求的子服务分发，得到响应后进行响应。
- 对客户端进行事件通知（好友申请和处理及删除，单聊/群聊会话创建，新消息）。

基于以上的两个功能，网关服务器包含两项通信：

- **HTTP 通信：** 进行业务处理。
- **WebSocket 通信：** 进行事件通知。

## 20.2 模块划分

1. **参数/配置文件解析模块：** 基于 `gflags` 框架直接使用进行参数/配置文件解析。

2. **日志模块：** 基于 `spdlog` 框架封装的模块直接使用进行日志输出。

3. **RPC 服务发现与调用模块：** 基于 `etcd` 框架与 `brpc` 框架封装的服务发现与调用模块。
   - 因为要分发处理所有请求，因此所有的子服务都需要进行服务发现。

4. **Redis 客户端模块：** 基于 `redis++` 封装的客户端进行内存数据库数据操作。
   - 根据用户子服务添加的会话信息进行用户连接身份识别与鉴权。

5. **HTTP 通信服务器模块：** 基于 `cpp-httplib` 库搭建 HTTP 服务器，接收 HTTP 请求进行业务处理。

6. **WebSocket 服务器模块：** 基于 `WebSocketpp` 库，搭建 WebSocket 服务器，进行事件通知。

7. **客户端长连接管理模块：** 建立用户 ID 与长连接句柄映射关系，便于后续根据用户 ID 找到连接进行事件通知。

## 20.3 模块功能示意图

（此处插入模块功能示意图）

## 20.4 接口实现流程

### 20.4.1 用户名注册

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 查找用户子服务。
3. 调用子服务对应接口进行业务处理。
4. 将处理结果响应给客户端。

### 20.4.2 用户名登录

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 查找用户子服务。
3. 调用子服务对应接口进行业务处理。
4. 将处理结果响应给客户端。

### 20.4.3 短信验证码获取

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 查找用户子服务。
3. 调用子服务对应接口进行业务处理。
4. 将处理结果响应给客户端。

### 20.4.4 手机号码注册

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 查找用户子服务。
3. 调用子服务对应接口进行业务处理。
4. 将处理结果响应给客户端。

### 20.4.5 手机号码登录

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 查找用户子服务。
3. 调用子服务对应接口进行业务处理。
4. 将处理结果响应给客户端。

### 20.4.6 用户信息获取

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.7 修改用户头像

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.8 修改用户签名

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.9 修改用户昵称

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.10 修改用户绑定手机号

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.11 获取好友列表

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.12 发送好友申请

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 根据请求中的用户 ID，调用用户子服务，获取用户的详细信息。
5. 查找好友子服务。
6. 调用子服务对应接口进行业务处理。
7. 若处理成功，则通过被申请人 ID，查找对方长连接。
   - 若长连接存在（对方在线），则组织好友申请通知进行事件通知。
8. 将处理结果响应给客户端。

### 20.4.13 获取待处理好友申请

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.14 好友申请处理

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找用户子服务。
4. 根据请求中的用户 ID，调用用户子服务，获取申请人与被申请人的详细信息。
5. 查找好友子服务。
6. 调用子服务对应接口进行业务处理。
7. 若处理成功，则通过申请人 ID，查找申请人长连接，进行申请处理结果的通知。
   - 若处理结果是同意，则意味着新聊天会话的创建，对申请人进行聊天会话创建通知。
     1. 从处理结果中取出会话 ID，使用对方的昵称作为会话名称，对方的头像作为会话头像组织会话信息。
   - 若处理结果是同意，则对当前处理者用户 ID 查找长连接，进行聊天会话创建的通知。
     1. 从处理结果中取出会话 ID，使用对方的昵称作为会话名称，对方的头像作为会话头像组织会话信息。
   - 清理响应中的会话 ID 信息。
8. 将处理结果响应给客户端。

### 20.4.15 删除好友

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 若处理成功，则通过被删除者用户 ID，查找对方长连接。
   - 若长连接存在（对方在线），则组织好友删除通知进行事件通知。
6. 将处理结果响应给客户端。

### 20.4.16 搜索用户

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.17 获取用户聊天会话列表

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.18 创建多人聊天会话

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。


2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 若处理成功，循环根据会话成员的 ID 找到他们的长连接。
   - 根据响应中的会话信息，逐个进行会话创建的通知。
   - 清理响应中的会话信息。
6. 将处理结果响应给客户端。

### 20.4.19 获取消息会话成员列表

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找好友子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.20 发送新消息

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找消息转发子服务。
4. 调用子服务对应接口进行业务处理。
5. 若处理成功，则根据处理结果中的用户 ID 列表，循环找到目标长连接，根据处理结果中的消息字段组织新消息通知，逐个对目标进行新消息通知。
6. 若处理失败，则根据处理结果中的错误提示信息，设置响应内容。
7. 将处理结果响应给客户端。

### 20.4.21 获取指定时间段消息列表

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找消息存储子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.22 获取最近 N 条消息列表

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找消息存储子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.23 搜索关键字历史消息

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找消息存储子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.24 单个文件数据获取

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找文件子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.25 多个文件数据获取

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找文件子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.26 单个文件数据上传

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找文件子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.27 多个文件数据上传

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找文件子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。

### 20.4.28 语音转文字

1. 取出 HTTP 请求正文，进行 ProtoBuf 反序列化。
2. 根据请求中的会话 ID 进行鉴权，并获取用户 ID，向请求中设置用户 ID。
3. 查找语音子服务。
4. 调用子服务对应接口进行业务处理。
5. 将处理结果响应给客户端。


